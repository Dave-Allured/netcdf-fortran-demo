.TH "f90-user-defined-data-types" 3 "Wed Jan 17 2018" "Version 4.5.0-development" "NetCDF-Fortran" \" -*- nroff -*-
.ad l
.nh
.SH NAME
f90-user-defined-data-types5 User Defined Data Types 
 \- 
.SH "5\&.1 User Defined Types Introduction "
.PP
NetCDF-4 has added support for four different user defined data types\&.
.PP
\fCcompound type\fP
.PP
: Like a C struct, a compound type is a collection of types, including other user defined types, in one package\&.
.PP
\fCvariable length array type\fP
.PP
: The variable length array may be used to store ragged arrays\&.
.PP
\fCopaque type\fP
.PP
: This type has only a size per element, and no other type information\&.
.PP
\fCenum type\fP
.PP
: Like an enumeration in C, this type lets you assign text values to integer values, and store the integer values\&.
.PP
Users may construct user defined type with the various NF90_DEF_* functions described in this section\&. They may learn about user defined types by using the NF90_INQ_ functions defined in this section\&.
.PP
Once types are constructed, define variables of the new type with NF90_DEF_VAR (see section \fCCreate a Variable: \fCNF90_DEF_VAR\fP\fP)\&. Write to them with NF90_PUT_VAR (see section \fCWriting Data Values: \fCNF90_PUT_VAR\fP\fP)\&. Read data of user-defined type with NF90_GET_VAR (see section \fCReading Data Values: \fCNF90_GET_VAR\fP\fP)\&.
.PP
Create attributes of the new type with NF90_PUT_ATT (see section \fCCreate an Attribute: NF90_PUT_ATT\fP)\&. Read attributes of the new type with NF90_GET_ATT (see section \fCGet Attribute’s Values: NF90_GET_ATT\fP)\&.
.SH "5\&.2 Learn the IDs of All Types in Group: NF90_INQ_TYPEIDS "
.PP
Learn the number of types defined in a group, and their IDs\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_typeids(ncid, ntypes, typeids)
  integer, intent(in) :: ncid
  integer, intent(out) :: ntypes
  integer, intent(out) :: typeids
  integer :: nf90_inq_typeids
.fi
.PP
.PP
\fCNCID\fP
.PP
: The group id\&.
.PP
\fCNTYPES\fP
.PP
: A pointer to int which will get the number of types defined in the group\&. If NULL, ignored\&.
.PP
\fCTYPEIDS\fP
.PP
: A pointer to an int array which will get the typeids\&. If NULL, ignored\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_BADID\fP
.PP
: Bad ncid\&.
.PP
.SS "Example"
.SH "5\&.3 Find a Typeid from Group and Name: nf90_inq_typeid "
.PP
Given a group ID and a type name, find the ID of the type\&. If the type is not found in the group, then the parents are searched\&. If still not found, the entire file is searched\&.
.PP
.SS "Usage"
.PP
.PP
.nf
int nf90_inq_typeid(int ncid, char *name, nf90_type *typeidp);
.fi
.PP
.PP
\fCncid\fP
.PP
: The group id\&.
.PP
\fCname\fP
.PP
: The name of a type\&.
.PP
\fCtypeidp\fP
.PP
: The typeid, if found\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Bad ncid\&.
.PP
\fCNF90_EBADTYPE\fP
.PP
: Can’t find type\&.
.PP
.SS "Example"
.SH "5\&.4 Learn About a User Defined Type: NF90_INQ_TYPE "
.PP
Given an ncid and a typeid, get the information about a type\&. This function will work on any type, including atomic and any user defined type, whether compound, opaque, enumeration, or variable length array\&.
.PP
For even more information about a user defined type \fCLearn About a User Defined Type: NF90_INQ_USER_TYPE\fP\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_type(ncid, xtype, name, size)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer, intent(out) :: size
  integer :: nf90_inq_type
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid for the group containing the type (ignored for atomic types)\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this type, as returned by NF90_DEF_COMPOUND, NF90_DEF_OPAQUE, NF90_DEF_ENUM, NF90_DEF_VLEN, or NF90_INQ_VAR, or as found in netcdf\&.inc in the list of atomic types (NF90_CHAR, NF90_INT, etc\&.)\&.
.PP
\fCNAME\fP
.PP
: The name of the user defined type will be copied here\&. It will be NF90_MAX_NAME bytes or less\&. For atomic types, the type name from CDL will be given\&.
.PP
\fCSIZEP\fP
.PP
: The (in-memory) size of the type (in bytes) will be copied here\&. VLEN type size is the size of one element of the VLEN\&. String size is returned as the size of one char\&.
.PP
.SS "Return Codes"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad typeid\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Seeking a user-defined type in a netCDF-3 file\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: Seeking a user-defined type in a netCDF-4 file for which classic model has been turned on\&.
.PP
\fCNF90_EBADGRPID\fP
.PP
: Bad group ID in ncid\&.
.PP
\fCNF90_EBADID\fP
.PP
: Type ID not found\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SH "5\&.5 Learn About a User Defined Type: NF90_INQ_USER_TYPE "
.PP
Given an ncid and a typeid, get the information about a user defined type\&. This function will work on any user defined type, whether compound, opaque, enumeration, or variable length array\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_user_type(ncid, xtype, name, size, base_typeid, nfields, class)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer, intent(out) :: size
  integer, intent(out) :: base_typeid
  integer, intent(out) :: nfields
  integer, intent(out) :: class
  integer :: nf90_inq_user_type
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid for the group containing the user defined type\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this type, as returned by NF90_DEF_COMPOUND, NF90_DEF_OPAQUE, NF90_DEF_ENUM, NF90_DEF_VLEN, or NF90_INQ_VAR\&.
.PP
\fCNAME\fP
.PP
: The name of the user defined type will be copied here\&. It will be NF90_MAX_NAME bytes or less\&.
.PP
\fCSIZE\fP
.PP
: The (in-memory) size of the user defined type will be copied here\&.
.PP
\fCBASE_NF90_TYPE\fP
.PP
: The base typeid will be copied here for vlen and enum types\&.
.PP
\fCNFIELDS\fP
.PP
: The number of fields will be copied here for enum and compound types\&.
.PP
\fCCLASS\fP
.PP
: The class of the user defined type, NF90_VLEN, NF90_OPAQUE, NF90_ENUM, or NF90_COMPOUND, will be copied here\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad typeid\&.
.PP
\fCNF90_EBADFIELDID\fP
.PP
: Bad fieldid\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SS "5\&.5\&.1 Set a Variable Length Array with NF90_PUT_VLEN_ELEMENT"
Use this to set the element of the (potentially) n-dimensional array of VLEN\&. That is, this sets the data in one variable length array\&.
.PP
.SS "Usage"
.PP
.PP
.nf
INTEGER FUNCTION nf90_put_vlen_element(INTEGER NCID, INTEGER XTYPE,
        CHARACTER*(*) vlen_element, integer len, data)
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid of the file that contains the VLEN type\&.
.PP
\fCXTYPE\fP
.PP
: The type of the VLEN\&.
.PP
\fCVLEN_ELEMENT\fP
.PP
: The VLEN element to be set\&.
.PP
\fCLEN\fP
.PP
: The number of entries in this array\&.
.PP
\fCDATA\fP
.PP
: The data to be stored\&. Must match the base type of this VLEN\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPE\fP
.PP
: Can’t find the typeid\&.
.PP
\fCNF90_EBADID\fP
.PP
: ncid invalid\&.
.PP
\fCNF90_EBADGRPID\fP
.PP
: Group ID part of ncid was invalid\&.
.PP
.SS "Example"
.PP
This example is from nf90_test/ftst_vars4\&.F\&.
.PP
.PP
.nf
C     Set up the vlen with this helper function, since F90 can't deal
C     with pointers\&.
      retval = nf90_put_vlen_element(ncid, vlen_typeid, vlen,
     &     vlen_len, data1)
      if (retval \&.ne\&. nf90_noerr) call handle_err(retval)
.fi
.PP
.SS "5\&.5\&.2 Set a Variable Length Array with NF90_GET_VLEN_ELEMENT"
Use this to set the element of the (potentially) n-dimensional array of VLEN\&. That is, this sets the data in one variable length array\&.
.PP
.SS "Usage"
.PP
.PP
.nf
INTEGER FUNCTION nf90_get_vlen_element(INTEGER NCID, INTEGER XTYPE,
        CHARACTER*(*) vlen_element, integer len, data)
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid of the file that contains the VLEN type\&.
.PP
\fCXTYPE\fP
.PP
: The type of the VLEN\&.
.PP
\fCVLEN_ELEMENT\fP
.PP
: The VLEN element to be set\&.
.PP
\fCLEN\fP
.PP
: This will be set to the number of entries in this array\&.
.PP
\fCDATA\fP
.PP
: The data will be copied here\&. Sufficient storage must be available or bad things will happen to you\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPE\fP
.PP
: Can’t find the typeid\&.
.PP
\fCNF90_EBADID\fP
.PP
: ncid invalid\&.
.PP
\fCNF90_EBADGRPID\fP
.PP
: Group ID part of ncid was invalid\&.
.PP
.SS "Example"
.SH "5\&.6 Compound Types Introduction "
.PP
NetCDF-4 added support for compound types, which allow users to construct a new type - a combination of other types, like a C struct\&.
.PP
Compound types are not supported in classic or 64-bit offset format files\&.
.PP
To write data in a compound type, first use nf90_def_compound to create the type, multiple calls to nf90_insert_compound to add to the compound type, and then write data with the appropriate nf90_put_var1, nf90_put_vara, nf90_put_vars, or nf90_put_varm call\&.
.PP
To read data written in a compound type, you must know its structure\&. Use the NF90_INQ_COMPOUND functions to learn about the compound type\&.
.PP
In Fortran a character buffer must be used for the compound data\&. The user must read the data from within that buffer in the same way that the C compiler which compiled netCDF would store the structure\&.
.PP
The use of compound types introduces challenges and portability issues for Fortran users\&.
.SS "5\&.6\&.1 Creating a Compound Type: NF90_DEF_COMPOUND"
Create a compound type\&. Provide an ncid, a name, and a total size (in bytes) of one element of the completed compound type\&.
.PP
After calling this function, fill out the type with repeated calls to NF90_INSERT_COMPOUND (see section \fCInserting a Field into a Compound Type: NF90_INSERT_COMPOUND\fP)\&. Call NF90_INSERT_COMPOUND once for each field you wish to insert into the compound type\&.
.PP
Note that there does not seem to be a fully portable way to read such types into structures in Fortran 90 (and there are no structures in Fortran 77)\&. Dozens of top-notch programmers are swarming over this problem in a sub-basement of Unidata’s giant underground bunker in Wyoming\&.
.PP
Fortran users may use character buffers to read and write compound types\&. User are invited to try classic Fortran features such as the equivilence and the common block statment\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_def_compound(ncid, size, name, typeid)
  integer, intent(in) :: ncid
  integer, intent(in) :: size
  character (len = *), intent(in) :: name
  integer, intent(out) :: typeid
  integer :: nf90_def_compound
.fi
.PP
.PP
\fCNCID\fP
.PP
: The groupid where this compound type will be created\&.
.PP
\fCSIZE\fP
.PP
: The size, in bytes, of the compound type\&.
.PP
\fCNAME\fP
.PP
: The name of the new compound type\&.
.PP
\fCTYPEIDP\fP
.PP
: The typeid of the new type will be placed here\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Bad group id\&.
.PP
\fCNF90_ENAMEINUSE\fP
.PP
: That name is in use\&. Compound type names must be unique in the data file\&.
.PP
\fCNF90_EMAXNAME\fP
.PP
: Name exceeds max length NF90_MAX_NAME\&.
.PP
\fCNF90_EBADNAME\fP
.PP
: Name contains illegal characters\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Attempting a netCDF-4 operation on a netCDF-3 file\&. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
\fCNF90_EPERM\fP
.PP
: Attempt to write to a read-only file\&.
.PP
\fCNF90_ENOTINDEFINE\fP
.PP
: Not in define mode\&.
.PP
.SS "Example"
.SS "5\&.6\&.2 Inserting a Field into a Compound Type: NF90_INSERT_COMPOUND"
Insert a named field into a compound type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_insert_compound(ncid, xtype, name, offset, field_typeid)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(in) :: name
  integer, intent(in) :: offset
  integer, intent(in) :: field_typeid
  integer :: nf90_insert_compound
.fi
.PP
.PP
\fCTYPEID\fP
.PP
: The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR\&.
.PP
\fCNAME\fP
.PP
: The name of the new field\&.
.PP
\fCOFFSET\fP
.PP
: Offset in byte from the beginning of the compound type for this field\&.
.PP
\fCFIELD_TYPEID\fP
.PP
: The type of the field to be inserted\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Bad group id\&.
.PP
\fCNF90_ENAMEINUSE\fP
.PP
: That name is in use\&. Field names must be unique within a compound type\&.
.PP
\fCNF90_EMAXNAME\fP
.PP
: Name exceed max length NF90_MAX_NAME\&.
.PP
\fCNF90_EBADNAME\fP
.PP
: Name contains illegal characters\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Attempting a netCDF-4 operation on a netCDF-3 file\&. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
\fCNF90_ENOTINDEFINE\fP
.PP
: Not in define mode\&.
.PP
.SS "Example"
.SS "5\&.6\&.3 Inserting an Array Field into a Compound Type: NF90_INSERT_ARRAY_COMPOUND"
Insert a named array field into a compound type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_insert_array_compound(ncid, xtype, name, offset, field_typeid, &
     ndims, dim_sizes)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(in) :: name
  integer, intent(in) :: offset
  integer, intent(in) :: field_typeid
  integer, intent(in) :: ndims
  integer, intent(in) :: dim_sizes
  integer :: nf90_insert_array_compound
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ID of the file that contains the array type and the compound type\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this compound type, as returned by nf90_def_compound, or nf90_inq_var\&.
.PP
\fCNAME\fP
.PP
: The name of the new field\&.
.PP
\fCOFFSET\fP
.PP
: Offset in byte from the beginning of the compound type for this field\&.
.PP
\fCFIELD_TYPEID\fP
.PP
: The base type of the array to be inserted\&.
.PP
\fCNDIMS\fP
.PP
: The number of dimensions for the array to be inserted\&.
.PP
\fCDIM_SIZES\fP
.PP
: An array containing the sizes of each dimension\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Bad group id\&.
.PP
\fCNF90_ENAMEINUSE\fP
.PP
: That name is in use\&. Field names must be unique within a compound type\&.
.PP
\fCNF90_EMAXNAME\fP
.PP
: Name exceed max length NF90_MAX_NAME\&.
.PP
\fCNF90_EBADNAME\fP
.PP
: Name contains illegal characters\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Attempting a netCDF-4 operation on a netCDF-3 file\&. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
\fCNF90_ENOTINDEFINE\fP
.PP
: Not in define mode\&.
.PP
\fCNF90_ETYPEDEFINED\fP
.PP
: Attempt to change type that has already been committed\&. The first time the file leaves define mode, all defined types are committed, and can’t be changed\&. If you wish to add an array to a compound type, you must do so before the compound type is committed\&.
.PP
.SS "Example"
.SS "5\&.6\&.4 Learn About a Compound Type: NF90_INQ_COMPOUND"
Get the number of fields, length in bytes, and name of a compound type\&.
.PP
In addtion to the NF90_INQ_COMPOUND function, three additional functions are provided which get only the name, size, and number of fields\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_compound(ncid, xtype, name, size, nfields)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer, intent(out) :: size
  integer, intent(out) :: nfields
  integer :: nf90_inq_compound

function nf90_inq_compound_name(ncid, xtype, name)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer :: nf90_inq_compound_name

function nf90_inq_compound_size(ncid, xtype, size)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(out) :: size
  integer :: nf90_inq_compound_size

function nf90_inq_compound_nfields(ncid, xtype, nfields)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(out) :: nfields
  integer :: nf90_inq_compound_nfields
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ID of any group in the file that contains the compound type\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR\&.
.PP
\fCNAME\fP
.PP
: Character array which will get the name of the compound type\&. It will have a maximum length of NF90_MAX_NAME\&.
.PP
\fCSIZEP\fP
.PP
: The size of the compound type in bytes will be put here\&.
.PP
\fCNFIELDSP\fP
.PP
: The number of fields in the compound type will be placed here\&.
.PP
.SS "Return Codes"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Couldn’t find this ncid\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Not a netCDF-4/HDF5 file\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: A netCDF-4/HDF5 file, but with CLASSIC_MODEL\&. No user defined types are allowed in the classic model\&.
.PP
\fCNF90_EBADTYPE\fP
.PP
: This type not a compound type\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad type id\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SS "5\&.6\&.5 Learn About a Field of a Compound Type: NF90_INQ_COMPOUND_FIELD"
Get information about one of the fields of a compound type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_compound_field(ncid, xtype, fieldid, name, offset, &
     field_typeid, ndims, dim_sizes)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: fieldid
  character (len = *), intent(out) :: name
  integer, intent(out) :: offset
  integer, intent(out) :: field_typeid
  integer, intent(out) :: ndims
  integer, intent(out) :: dim_sizes
  integer :: nf90_inq_compound_field

function nf90_inq_compound_fieldname(ncid, xtype, fieldid, name)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: fieldid
  character (len = *), intent(out) :: name
  integer :: nf90_inq_compound_fieldname

function nf90_inq_compound_fieldindex(ncid, xtype, name, fieldid)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(in) :: name
  integer, intent(out) :: fieldid
  integer :: nf90_inq_compound_fieldindex

function nf90_inq_compound_fieldoffset(ncid, xtype, fieldid, offset)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: fieldid
  integer, intent(out) :: offset
  integer :: nf90_inq_compound_fieldoffset

function nf90_inq_compound_fieldtype(ncid, xtype, fieldid, field_typeid)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: fieldid
  integer, intent(out) :: field_typeid
  integer :: nf90_inq_compound_fieldtype

function nf90_inq_compound_fieldndims(ncid, xtype, fieldid, ndims)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: fieldid
  integer, intent(out) :: ndims
  integer :: nf90_inq_compound_fieldndims

function nf90_inq_cmp_fielddim_sizes(ncid, xtype, fieldid, dim_sizes)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: fieldid
  integer, intent(out) :: dim_sizes
  integer :: nf90_inq_cmp_fielddim_sizes
.fi
.PP
.PP
\fCNCID\fP
.PP
: The groupid where this compound type exists\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR\&.
.PP
\fCFIELDID\fP
.PP
: A one-based index number specifying a field in the compound type\&.
.PP
\fCNAME\fP
.PP
: A character array which will get the name of the field\&. The name will be NF90_MAX_NAME characters, at most\&.
.PP
\fCOFFSETP\fP
.PP
: An integer which will get the offset of the field\&.
.PP
\fCFIELD_TYPEID\fP
.PP
: An integer which will get the typeid of the field\&.
.PP
\fCNDIMSP\fP
.PP
: An integer which will get the number of dimensions of the field\&.
.PP
\fCDIM_SIZESP\fP
.PP
: An integer array which will get the dimension sizes of the field\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad type id\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SH "5\&.7 Variable Length Array Introduction "
.PP
NetCDF-4 added support for a variable length array type\&. This is not supported in classic or 64-bit offset files, or in netCDF-4 files which were created with the NF90_CLASSIC_MODEL flag\&.
.PP
A variable length array is represented in C as a structure from HDF5, the nf90_vlen_t structure\&. It contains a len member, which contains the length of that array, and a pointer to the array\&.
.PP
So an array of VLEN in C is an array of nc_vlen_t structures\&. The only way to handle this in Fortran is with a character buffer sized correctly for the platform\&.
.PP
VLEN arrays are handled differently with respect to allocation of memory\&. Generally, when reading data, it is up to the user to malloc (and subsequently free) the memory needed to hold the data\&. It is up to the user to ensure that enough memory is allocated\&.
.PP
With VLENs, this is impossible\&. The user cannot know the size of an array of VLEN until after reading the array\&. Therefore when reading VLEN arrays, the netCDF library will allocate the memory for the data within each VLEN\&.
.PP
It is up to the user, however, to eventually free this memory\&. This is not just a matter of one call to free, with the pointer to the array of VLENs; each VLEN contains a pointer which must be freed\&.
.PP
Compression is permitted but may not be effective for VLEN data, because the compression is applied to the nc_vlen_t structures, rather than the actual data\&.
.SS "5\&.7\&.1 Define a Variable Length Array (VLEN): NF90_DEF_VLEN"
Use this function to define a variable length array type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_def_vlen(ncid, name, base_typeid, xtypeid)
  integer, intent(in) :: ncid
  character (len = *), intent(in) :: name
  integer, intent(in) :: base_typeid
  integer, intent(out) :: xtypeid
  integer :: nf90_def_vlen
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid of the file to create the VLEN type in\&.
.PP
\fCNAME\fP
.PP
: A name for the VLEN type\&.
.PP
\fCBASE_TYPEID\fP
.PP
: The typeid of the base type of the VLEN\&. For example, for a VLEN of shorts, the base type is NF90_SHORT\&. This can be a user defined type\&.
.PP
\fCXTYPEP\fP
.PP
: The typeid of the new VLEN type will be set here\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EMAXNAME\fP
.PP
: NF90_MAX_NAME exceeded\&.
.PP
\fCNF90_ENAMEINUSE\fP
.PP
: Name is already in use\&.
.PP
\fCNF90_EBADNAME\fP
.PP
: Attribute or variable name contains illegal characters\&.
.PP
\fCNF90_EBADID\fP
.PP
: ncid invalid\&.
.PP
\fCNF90_EBADGRPID\fP
.PP
: Group ID part of ncid was invalid\&.
.PP
\fCNF90_EINVAL\fP
.PP
: Size is invalid\&.
.PP
\fCNF90_ENOMEM\fP
.PP
: Out of memory\&.
.PP
.SS "Example"
.SS "5\&.7\&.2 Learning about a Variable Length Array (VLEN) Type: NF90_INQ_VLEN"
Use this type to learn about a vlen\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_vlen(ncid, xtype, name, datum_size, base_nc_type)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer, intent(out) :: datum_size
  integer, intent(out) :: base_nc_type
  integer :: nf90_inq_vlen
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid of the file that contains the VLEN type\&.
.PP
\fCXTYPE\fP
.PP
: The type of the VLEN to inquire about\&.
.PP
\fCNAME\fP
.PP
: The name of the VLEN type\&. The name will be NF90_MAX_NAME characters or less\&.
.PP
\fCDATUM_SIZEP\fP
.PP
: A pointer to a size_t, this will get the size of one element of this vlen\&.
.PP
\fCBASE_NF90_TYPEP\fP
.PP
: An integer that will get the type of the VLEN base type\&. (In other words, what type is this a VLEN of?)
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPE\fP
.PP
: Can’t find the typeid\&.
.PP
\fCNF90_EBADID\fP
.PP
: ncid invalid\&.
.PP
\fCNF90_EBADGRPID\fP
.PP
: Group ID part of ncid was invalid\&.
.PP
.SS "Example"
.SS "5\&.7\&.3 Releasing Memory for a Variable Length Array (VLEN) Type: NF90_FREE_VLEN"
When a VLEN is read into user memory from the file, the HDF5 library performs memory allocations for each of the variable length arrays contained within the VLEN structure\&. This memory must be freed by the user to avoid memory leaks\&.
.PP
This violates the normal netCDF expectation that the user is responsible for all memory allocation\&. But, with VLEN arrays, the underlying HDF5 library allocates the memory for the user, and the user is responsible for deallocating that memory\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_free_vlen(vl)
  character (len = *), intent(in) :: vlen
  integer :: nf90_free_vlen
end function nf90_free_vlen
.fi
.PP
.PP
\fCVL\fP
.PP
: The variable length array structure which is to be freed\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPE\fP
.PP
: Can’t find the typeid\&.
.PP
.SS "Example"
.SH "5\&.8 Opaque Type Introduction "
.PP
NetCDF-4 added support for the opaque type\&. This is not supported in classic or 64-bit offset files\&.
.PP
The opaque type is a type which is a collection of objects of a known size\&. (And each object is the same size)\&. Nothing is known to netCDF about the contents of these blobs of data, except their size in bytes, and the name of the type\&.
.PP
To use an opaque type, first define it with \fCCreating Opaque Types: NF90_DEF_OPAQUE\fP\&. If encountering an enum type in a new data file, use \fCLearn About an Opaque Type: NF90_INQ_OPAQUE\fP to learn its name and size\&.
.SS "5\&.8\&.1 Creating Opaque Types: NF90_DEF_OPAQUE"
Create an opaque type\&. Provide a size and a name\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_def_opaque(ncid, size, name, xtype)
  integer, intent(in) :: ncid
  integer, intent(in) :: size
  character (len = *), intent(in) :: name
  integer, intent(out) :: xtype
  integer :: nf90_def_opaque
.fi
.PP
.PP
\fCNCID\fP
.PP
: The groupid where the type will be created\&. The type may be used anywhere in the file, no matter what group it is in\&.
.PP
\fCNAME\fP
.PP
: The name for this type\&. Must be shorter than NF90_MAX_NAME\&.
.PP
\fCSIZE\fP
.PP
: The size of each opaque object\&.
.PP
\fCTYPEIDP\fP
.PP
: Pointer where the new typeid for this type is returned\&. Use this typeid when defining variables of this type with \fCCreate a Variable: \fCNF90_DEF_VAR\fP\fP\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad typeid\&.
.PP
\fCNF90_EBADFIELDID\fP
.PP
: Bad fieldid\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SS "5\&.8\&.2 Learn About an Opaque Type: NF90_INQ_OPAQUE"
Given a typeid, get the information about an opaque type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_opaque(ncid, xtype, name, size)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer, intent(out) :: size
  integer :: nf90_inq_opaque
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid for the group containing the opaque type\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this opaque type, as returned by NF90_DEF_COMPOUND, or NF90_INQ_VAR\&.
.PP
\fCNAME\fP
.PP
: The name of the opaque type will be copied here\&. It will be NF90_MAX_NAME bytes or less\&.
.PP
\fCSIZEP\fP
.PP
: The size of the opaque type will be copied here\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad typeid\&.
.PP
\fCNF90_EBADFIELDID\fP
.PP
: Bad fieldid\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SH "5\&.9 Enum Type Introduction "
.PP
NetCDF-4 added support for the enum type\&. This is not supported in classic or 64-bit offset files\&.
.SS "5\&.9\&.1 Creating a Enum Type: NF90_DEF_ENUM"
Create an enum type\&. Provide an ncid, a name, and a base integer type\&.
.PP
After calling this function, fill out the type with repeated calls to NF90_INSERT_ENUM (see section \fCInserting a Field into a Enum Type: NF90_INSERT_ENUM\fP)\&. Call NF90_INSERT_ENUM once for each value you wish to make part of the enumeration\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_def_enum(ncid, base_typeid, name, typeid)
  integer, intent(in) :: ncid
  integer, intent(in) :: base_typeid
  character (len = *), intent(in) :: name
  integer, intent(out) :: typeid
  integer :: nf90_def_enum
.fi
.PP
.PP
\fCNCID\fP
.PP
: The groupid where this compound type will be created\&.
.PP
\fCBASE_TYPEID\fP
.PP
: The base integer type for this enum\&. Must be one of: NF90_BYTE, NF90_UBYTE, NF90_SHORT, NF90_USHORT, NF90_INT, NF90_UINT, NF90_INT64, NF90_UINT64\&.
.PP
\fCNAME\fP
.PP
: The name of the new enum type\&.
.PP
\fCTYPEIDP\fP
.PP
: The typeid of the new type will be placed here\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Bad group id\&.
.PP
\fCNF90_ENAMEINUSE\fP
.PP
: That name is in use\&. Compound type names must be unique in the data file\&.
.PP
\fCNF90_EMAXNAME\fP
.PP
: Name exceeds max length NF90_MAX_NAME\&.
.PP
\fCNF90_EBADNAME\fP
.PP
: Name contains illegal characters\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Attempting a netCDF-4 operation on a netCDF-3 file\&. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
\fCNF90_EPERM\fP
.PP
: Attempt to write to a read-only file\&.
.PP
\fCNF90_ENOTINDEFINE\fP
.PP
: Not in define mode\&.
.PP
.SS "Example"
.SS "5\&.9\&.2 Inserting a Field into a Enum Type: NF90_INSERT_ENUM"
Insert a named member into a enum type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_insert_enum(ncid, xtype, name, value)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(in) :: name
  integer, intent(in) :: value
  integer :: nf90_insert_enum
.fi
.PP
.PP
\fCNCID\fP
.PP
: The ncid of the group which contains the type\&.
.PP
\fCTYPEID\fP
.PP
: The typeid for this enum type, as returned by nf90_def_enum, or nf90_inq_var\&.
.PP
\fCIDENTIFIER\fP
.PP
: The identifier of the new member\&.
.PP
\fCVALUE\fP
.PP
: The value that is to be associated with this member\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADID\fP
.PP
: Bad group id\&.
.PP
\fCNF90_ENAMEINUSE\fP
.PP
: That name is in use\&. Field names must be unique within a enum type\&.
.PP
\fCNF90_EMAXNAME\fP
.PP
: Name exceed max length NF90_MAX_NAME\&.
.PP
\fCNF90_EBADNAME\fP
.PP
: Name contains illegal characters\&.
.PP
\fCNF90_ENOTNC4\fP
.PP
: Attempting a netCDF-4 operation on a netCDF-3 file\&. NetCDF-4 operations can only be performed on files defined with a create mode which includes flag NF90_NETCDF4\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_ESTRICTNC3\fP
.PP
: This file was created with the strict netcdf-3 flag, therefore netcdf-4 operations are not allowed\&. (see section \fCNF90_OPEN\fP)\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
\fCNF90_ENOTINDEFINE\fP
.PP
: Not in define mode\&.
.PP
.SS "Example"
.SS "5\&.9\&.3 Learn About a Enum Type: NF90_INQ_ENUM"
Get information about a user-defined enumeration type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_enum(ncid, xtype, name, base_nc_type, base_size, num_members)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  character (len = *), intent(out) :: name
  integer, intent(out) :: base_nc_type
  integer, intent(out) :: base_size
  integer, intent(out) :: num_members
  integer :: nf90_inq_enum
.fi
.PP
.PP
\fCNCID\fP
.PP
: The group ID of the group which holds the enum type\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this enum type, as returned by NF90_DEF_ENUM, or NF90_INQ_VAR\&.
.PP
\fCNAME\fP
.PP
: Character array which will get the name\&. It will have a maximum length of NF90_MAX_NAME\&.
.PP
\fCBASE_NF90_TYPE\fP
.PP
: An integer which will get the base integer type of this enum\&.
.PP
\fCBASE_SIZE\fP
.PP
: An integer which will get the size (in bytes) of the base integer type of this enum\&.
.PP
\fCNUM_MEMBERS\fP
.PP
: An integer which will get the number of members defined for this enumeration type\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad type id\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SS "5\&.9\&.4 Learn the Name of a Enum Type: nf90_inq_enum_member"
Get information about a member of an enum type\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_enum_member(ncid, xtype, idx, name, value)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: idx
  character (len = *), intent(out) :: name
  integer, intent(in) :: value
  integer :: nf90_inq_enum_member
.fi
.PP
.PP
\fCNCID\fP
.PP
: The groupid where this enum type exists\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this enum type\&.
.PP
\fCIDX\fP
.PP
: The one-based index number for the member of interest\&.
.PP
\fCNAME\fP
.PP
: A character array which will get the name of the member\&. It will have a maximum length of NF90_MAX_NAME\&.
.PP
\fCVALUE\fP
.PP
: An integer that will get the value associated with this member\&.
.PP
.SS "Errors"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad type id\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
.SS "Example"
.SS "5\&.9\&.5 Learn the Name of a Enum Type: NF90_INQ_ENUM_IDENT"
Get the name which is associated with an enum member value\&.
.PP
This is similar to NF90_INQ_ENUM_MEMBER, but instead of using the index of the member, you use the value of the member\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inq_enum_ident(ncid, xtype, value, idx)
  integer, intent(in) :: ncid
  integer, intent(in) :: xtype
  integer, intent(in) :: value
  integer, intent(out) :: idx
  integer :: nf90_inq_enum_ident
.fi
.PP
.PP
\fCNCID\fP
.PP
: The groupid where this enum type exists\&.
.PP
\fCXTYPE\fP
.PP
: The typeid for this enum type\&.
.PP
\fCVALUE\fP
.PP
: The value for which an identifier is sought\&.
.PP
\fCIDENTIFIER\fP
.PP
: A character array that will get the identifier\&. It will have a maximum length of NF90_MAX_NAME\&.
.PP
.SS "Return Code"
.PP
\fCNF90_NOERR\fP
.PP
: No error\&.
.PP
\fCNF90_EBADTYPEID\fP
.PP
: Bad type id, or not an enum type\&.
.PP
\fCNF90_EHDFERR\fP
.PP
: An error was reported by the HDF5 layer\&.
.PP
\fCNF90_EINVAL\fP
.PP
: The value was not found in the enum\&.
.PP
.SS "Example"

