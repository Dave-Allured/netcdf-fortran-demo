.TH "f90-attributes" 3 "Wed Jan 17 2018" "Version 4.5.0-development" "NetCDF-Fortran" \" -*- nroff -*-
.ad l
.nh
.SH NAME
f90-attributes7 Attributes 
 \- 
.SH "7\&.1 Attributes Introduction "
.PP
Attributes may be associated with each netCDF variable to specify such properties as units, special values, maximum and minimum valid values, scaling factors, and offsets\&. Attributes for a netCDF dataset are defined when the dataset is first created, while the netCDF dataset is in define mode\&. Additional attributes may be added later by reentering define mode\&. A netCDF attribute has a netCDF variable to which it is assigned, a name, a type, a length, and a sequence of one or more values\&. An attribute is designated by its variable ID and name\&. When an attribute name is not known, it may be designated by its variable ID and number in order to determine its name, using the function NF90_INQ_ATTNAME\&.
.PP
The attributes associated with a variable are typically defined immediately after the variable is created, while still in define mode\&. The data type, length, and value of an attribute may be changed even when in data mode, as long as the changed attribute requires no more space than the attribute as originally defined\&.
.PP
It is also possible to have attributes that are not associated with any variable\&. These are called global attributes and are identified by using NF90_GLOBAL as a variable pseudo-ID\&. Global attributes are usually related to the netCDF dataset as a whole and may be used for purposes such as providing a title or processing history for a netCDF dataset\&.
.PP
Attributes are much more useful when they follow established community conventions\&. See \fCAttribute Conventions\fP in {No value for ‘n-man’}\&.
.PP
Operations supported on attributes are:
.PP
.IP "\(bu" 2
Create an attribute, given its variable ID, name, data type, length, and value\&.
.IP "\(bu" 2
Get attribute’s data type and length from its variable ID and name\&.
.IP "\(bu" 2
Get attribute’s value from its variable ID and name\&.
.IP "\(bu" 2
Copy attribute from one netCDF variable to another\&.
.IP "\(bu" 2
Get name of attribute from its number\&.
.IP "\(bu" 2
Rename an attribute\&.
.IP "\(bu" 2
Delete an attribute\&.
.PP
.SH "7\&.2 Create an Attribute: NF90_PUT_ATT "
.PP
The function NF90_PUT_ATTadds or changes a variable attribute or global attribute of an open netCDF dataset\&. If this attribute is new, or if the space required to store the attribute is greater than before, the netCDF dataset must be in define mode\&.
.PP
.SS "Usage"
.PP
Although it’s possible to create attributes of all types, text and double attributes are adequate for most purposes\&.
.PP
.PP
.nf
function nf90_put_att(ncid, varid, name, values)
  integer,            intent( in) :: ncid, varid
  character(len = *), intent( in) :: name
  scalar character string or any numeric type, scalar, or array of rank 1, &
                      intent( in) :: values
  integer                         :: nf90_put_att
.fi
.PP
.PP
\fCncid\fP
.PP
: NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE\&.
.PP
\fCvarid\fP
.PP
: Variable ID of the variable to which the attribute will be assigned or NF90_GLOBAL for a global attribute\&.
.PP
\fCname\fP
.PP
: Attribute name\&. Attribute name conventions are assumed by some netCDF generic applications, e\&.g\&., ‘units’ as the name for a string attribute that gives the units for a netCDF variable\&. See \fCAttribute Conventions\fP in {No value for ‘n-man’}\&.
.PP
\fCvalues\fP
.PP
: A numeric rank 1 array of attribute values or a scalar\&. The external data type of the attribute is set to match the internal representation of the argument, that is if values is a two byte integer array, the attribute will be of type NF90_INT2\&. Fortran 90 intrinsic functions can be used to convert attributes to the desired type\&.
.PP
.SS "Errors"
.PP
NF90_PUT_ATT returns the value NF90_NOERR if no errors occurred\&. Otherwise, the returned status indicates an error\&. Possible causes of errors include:
.PP
.IP "\(bu" 2
The variable ID is invalid for the specified netCDF dataset\&.
.IP "\(bu" 2
The specified netCDF type is invalid\&.
.IP "\(bu" 2
The specified length is negative\&.
.IP "\(bu" 2
The specified open netCDF dataset is in data mode and the specified attribute would expand\&.
.IP "\(bu" 2
The specified open netCDF dataset is in data mode and the specified attribute does not already exist\&.
.IP "\(bu" 2
The specified netCDF ID does not refer to an open netCDF dataset\&.
.IP "\(bu" 2
The number of attributes for this variable exceeds NF90_MAX_ATTRS\&.
.PP
.PP
.SS "Example"
.PP
Here is an example using NF90_PUT_ATT to add a variable attribute named valid_range for a netCDF variable named rh and a global attribute named title to an existing netCDF dataset named foo\&.nc:
.PP
.PP
.nf
use netcdf
implicit none
integer :: ncid, status, rhvarid
\&.\&.\&.
status = nf90_open("foo\&.nc", nf90_write, ncid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
! Enter define mode so we can add the attribute
status = nf90_redef(ncid)
if (status /= nf90_noerr) call handle_err(status)
! Get the variable ID for "rh"\&.\&.\&.
status = nf90_inq_varid(ncid, "rh", rhvarid)
if (status /= nf90_noerr) call handle_err(status)
! \&.\&.\&.  put the range attribute, setting it to eight byte reals\&.\&.\&.
status = nf90_put_att(ncid, rhvarid, "valid_range", real((/ 0, 100 /))
! \&.\&.\&. and the title attribute\&.
if (status /= nf90_noerr) call handle_err(status)
status = nf90_put_att(ncid, rhvarid, "title", "example netCDF dataset") )
if (status /= nf90_noerr) call handle_err(status)
! Leave define mode
status = nf90_enddef(ncid)
if (status /= nf90_noerr) call handle_err(status)
.fi
.PP
.SH "7\&.3 Get Information about an Attribute: NF90_INQUIRE_ATTRIBUTE and NF90_INQ_ATTNAME "
.PP
The function NF90_INQUIRE_ATTRIBUTE returns information about a netCDF attribute given the variable ID and attribute name\&. Information about an attribute includes its type, length, name, and number\&. See NF90_GET_ATT for getting attribute values\&.
.PP
The function NF90_INQ_ATTNAME gets the name of an attribute, given its variable ID and number\&. This function is useful in generic applications that need to get the names of all the attributes associated with a variable, since attributes are accessed by name rather than number in all other attribute functions\&. The number of an attribute is more volatile than the name, since it can change when other attributes of the same variable are deleted\&. This is why an attribute number is not called an attribute ID\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_inquire_attribute(ncid, varid, name, xtype, len, attnum)
  integer,             intent( in)           :: ncid, varid
  character (len = *), intent( in)           :: name
  integer,             intent(out), optional :: xtype, len, attnum
  integer                                    :: nf90_inquire_attribute
function nf90_inq_attname(ncid, varid, attnum, name)
  integer,             intent( in) :: ncid, varid, attnum
  character (len = *), intent(out) :: name
  integer                          :: nf90_inq_attname
.fi
.PP
.PP
\fCncid\fP
.PP
: NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE\&.
.PP
\fCvarid\fP
.PP
: Variable ID of the attribute’s variable, or NF90_GLOBAL for a global attribute\&.
.PP
\fCname\fP
.PP
: Attribute name\&. For NF90_INQ_ATTNAME, this is a pointer to the location for the returned attribute name\&.
.PP
\fCxtype\fP
.PP
: Returned attribute type, one of the set of predefined netCDF external data types\&. The valid netCDF external data types are NF90_BYTE, NF90_CHAR, NF90_SHORT, NF90_INT, NF90_FLOAT, and NF90_DOUBLE\&.
.PP
\fClen\fP
.PP
: Returned number of values currently stored in the attribute\&. For a string-valued attribute, this is the number of characters in the string\&.
.PP
\fCattnum\fP
.PP
: For NF90_INQ_ATTNAME, the input attribute number; for NF90_INQ_ATTID, the returned attribute number\&. The attributes for each variable are numbered from 1 (the first attribute) to NATTS, where NATTS is the number of attributes for the variable, as returned from a call to NF90_INQ_VARNATTS\&.
.PP
(If you already know an attribute name, knowing its number is not very useful, because accessing information about an attribute requires its name\&.)
.PP
.SS "Errors"
.PP
Each function returns the value NF90_NOERR if no errors occurred\&. Otherwise, the returned status indicates an error\&. Possible causes of errors include:
.PP
.IP "\(bu" 2
The variable ID is invalid for the specified netCDF dataset\&.
.IP "\(bu" 2
The specified attribute does not exist\&.
.IP "\(bu" 2
The specified netCDF ID does not refer to an open netCDF dataset\&.
.IP "\(bu" 2
For NF90_INQ_ATTNAME, the specified attribute number is negative or more than the number of attributes defined for the specified variable\&.
.PP
.PP
.SS "Example"
.PP
Here is an example using NF90_INQUIRE_ATTRIBUTE to inquire about the lengths of an attribute named valid_range for a netCDF variable named rh and a global attribute named title in an existing netCDF dataset named foo\&.nc:
.PP
.PP
.nf
use netcdf
implicit none
integer :: ncid, status
integer :: rhvarid                       ! Variable ID
integer :: validrangelength, titlelength ! Attribute lengths
\&.\&.\&.
status = nf90_open("foo\&.nc", nf90_nowrite, ncid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
! Get the variable ID for "rh"\&.\&.\&.
status = nf90_inq_varid(ncid, "rh", rhvarid)
if (status /= nf90_noerr) call handle_err(status)
! \&.\&.\&.  get the length of the "valid_range" attribute\&.\&.\&.
status = nf90_inquire_attribute(ncid, rhvarid, "valid_range", &
                          len = validrangelength)
if (status /= nf90_noerr) call handle_err(status)
! \&.\&.\&. and the global title attribute\&.
status = nf90_inquire_attribute(ncid, nf90_global, "title", len = titlelength)
if (status /= nf90_noerr) call handle_err(status)
.fi
.PP
.SH "7\&.4 Get Attribute’s Values: NF90_GET_ATT "
.PP
Function nf90_get_att gets the value(s) of a netCDF attribute, given its variable ID and name\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_get_att(ncid, varid, name, values)
  integer,            intent( in) :: ncid, varid
  character(len = *), intent( in) :: name
  any valid type, scalar or array of rank 1, &
                      intent(out) :: values
  integer                         :: nf90_get_att
.fi
.PP
.PP
\fCncid\fP
.PP
: NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE\&.
.PP
\fCvarid\fP
.PP
: Variable ID of the attribute’s variable, or NF90_GLOBAL for a global attribute\&.
.PP
\fCname\fP
.PP
: Attribute name\&.
.PP
\fCvalues\fP
.PP
: Returned attribute values\&. All elements of the vector of attribute values are returned, so you must provide enough space to hold them\&. If you don’t know how much space to reserve, call NF90_INQUIRE_ATTRIBUTE first to find out the length of the attribute\&. If there is only a single attribute values may be a scalar\&. If the attribute is of type character values should be a varble of type character with the len Fortran 90 attribute set to an appropriate value (i\&.e\&. character (len = 80) :: values)\&. You cannot read character data from a numeric variable or numeric data from a text variable\&. For numeric data, if the type of data differs from the netCDF variable type, type conversion will occur\&. See \fCType Conversion\fP in NetCDF Users Guide\&.
.PP
.SS "Errors"
.PP
.PP
.nf
nf90\_get\_att\_ type returns the value nf90\_noerr if no errors
occurred\&. otherwise, the returned status indicates an error\&. possible
causes of errors include:

-   the variable id is invalid for the specified netcdf dataset\&.
-   the specified attribute does not exist\&.
-   the specified netcdf id does not refer to an open netcdf dataset\&.
-   one or more of the attribute values are out of the range of values
    representable by the desired type\&.
.fi
.PP
.PP
.SS "Example"
.PP
Here is an example using NF90_GET_ATT to determine the values of an attribute named valid_range for a netCDF variable named rh and a global attribute named title in an existing netCDF dataset named foo\&.nc\&. In this example, it is assumed that we don’t know how many values will be returned, so we first inquire about the length of the attributes to make sure we have enough space to store them:
.PP
.PP
.nf
use netcdf
implicit none
integer              :: ncid, status
integer              :: rhvarid                       ! Variable ID
integer              :: validrangelength, titlelength ! Attribute lengths
real, dimension(:), allocatable, &
                     :: validrange
character (len = 80) :: title
\&.\&.\&.
status = nf90_open("foo\&.nc", nf90_nowrite, ncid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
! Find the lengths of the attributes
status = nf90_inq_varid(ncid, "rh", rhvarid)
if (status /= nf90_noerr) call handle_err(status)
status = nf90_inquire_attribute(ncid, rhvarid, "valid_range", &
                          len = validrangelength)
if (status /= nf90_noerr) call handle_err(status)
status = nf90_inquire_attribute(ncid, nf90_global, "title", len = titlelength)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
!Allocate space to hold attribute values, check string lengths
allocate(validrange(validrangelength), stat = status)
if(status /= 0 \&.or\&. len(title) < titlelength)
  print *, "Not enough space to put attribute values\&."
  exit
end if
! Read the attributes\&.
status = nf90_get_att(ncid, rhvarid, "valid_range", validrange)
if (status /= nf90_noerr) call handle_err(status)
status = nf90_get_att(ncid, nf90_global, "title", title)
if (status /= nf90_noerr) call handle_err(status)
.fi
.PP
.SH "7\&.5 Copy Attribute from One NetCDF to Another: NF90_COPY_ATT "
.PP
The function NF90_COPY_ATT copies an attribute from one open netCDF dataset to another\&. It can also be used to copy an attribute from one variable to another within the same netCDF dataset\&.
.PP
If used to copy an attribute of user-defined type, then that user-defined type must already be defined in the target file\&. In the case of user-defined attributes, enddef/redef is called for ncid_in and ncid_out if they are in define mode\&. (This is the ensure that all user-defined types are committed to the file(s) before the copy is attempted\&.)
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
  integer,             intent( in) :: ncid_in,  varid_in
  character (len = *), intent( in) :: name
  integer,             intent( in) :: ncid_out, varid_out
  integer                          :: nf90_copy_att
.fi
.PP
.PP
\fCncid_in\fP
.PP
: The netCDF ID of an input netCDF dataset from which the attribute will be copied, from a previous call to NF90_OPEN or NF90_CREATE\&.
.PP
\fCvarid_in\fP
.PP
: ID of the variable in the input netCDF dataset from which the attribute will be copied, or NF90_GLOBAL for a global attribute\&.
.PP
\fCname\fP
.PP
: Name of the attribute in the input netCDF dataset to be copied\&.
.PP
\fCncid_out\fP
.PP
: The netCDF ID of the output netCDF dataset to which the attribute will be copied, from a previous call to NF90_OPEN or NF90_CREATE\&. It is permissible for the input and output netCDF IDs to be the same\&. The output netCDF dataset should be in define mode if the attribute to be copied does not already exist for the target variable, or if it would cause an existing target attribute to grow\&.
.PP
\fCvarid_out\fP
.PP
: ID of the variable in the output netCDF dataset to which the attribute will be copied, or NF90_GLOBAL to copy to a global attribute\&.
.PP
.SS "Errors"
.PP
NF90_COPY_ATT returns the value NF90_NOERR if no errors occurred\&. Otherwise, the returned status indicates an error\&. Possible causes of errors include:
.PP
.IP "\(bu" 2
The input or output variable ID is invalid for the specified netCDF dataset\&.
.IP "\(bu" 2
The specified attribute does not exist\&.
.IP "\(bu" 2
The output netCDF is not in define mode and the attribute is new for the output dataset is larger than the existing attribute\&.
.IP "\(bu" 2
The input or output netCDF ID does not refer to an open netCDF dataset\&.
.PP
.PP
.SS "Example"
.PP
Here is an example using NF90_COPY_ATT to copy the variable attribute units from the variable rh in an existing netCDF dataset named foo\&.nc to the variable avgrh in another existing netCDF dataset named bar\&.nc, assuming that the variable avgrh already exists, but does not yet have a units attribute:
.PP
.PP
.nf
use netcdf
implicit none
integer :: ncid1, ncid2, status
integer :: rhvarid, avgrhvarid    ! Variable ID
\&.\&.\&.
status = nf90_open("foo\&.nc", nf90_nowrite, ncid1)
if (status /= nf90_noerr) call handle_err(status)
status = nf90_open("bar\&.nc", nf90_write, ncid2)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
! Find the IDs of the variables
status = nf90_inq_varid(ncid1, "rh", rhvarid)
if (status /= nf90_noerr) call handle_err(status)
status = nf90_inq_varid(ncid1, "avgrh", avgrhvarid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
status = nf90_redef(ncid2)   ! Enter define mode
if (status /= nf90_noerr) call handle_err(status)
! Copy variable attribute from "rh" in file 1 to "avgrh" in file 1
status = nf90_copy_att(ncid1, rhvarid, "units", ncid2, avgrhvarid)
if (status /= nf90_noerr) call handle_err(status)
status = nf90_enddef(ncid2)
if (status /= nf90_noerr) call handle_err(status)
.fi
.PP
.SH "7\&.6 Rename an Attribute: NF90_RENAME_ATT "
.PP
The function NF90_RENAME_ATT changes the name of an attribute\&. If the new name is longer than the original name, the netCDF dataset must be in define mode\&. You cannot rename an attribute to have the same name as another attribute of the same variable\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_rename_att(ncid, varid, curname, newname)
  integer,             intent( in) :: ncid,  varid
  character (len = *), intent( in) :: curname, newname
  integer                          :: nf90_rename_att
.fi
.PP
.PP
\fCncid\fP
.PP
: NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE
.PP
\fCvarid\fP
.PP
: ID of the attribute’s variable, or NF90_GLOBAL for a global attribute
.PP
\fCcurname\fP
.PP
: The current attribute name\&.
.PP
\fCnewname\fP
.PP
: The new name to be assigned to the specified attribute\&. If the new name is longer than the current name, the netCDF dataset must be in define mode\&.
.PP
.SS "Errors"
.PP
NF90_RENAME_ATT returns the value NF90_NOERR if no errors occurred\&. Otherwise, the returned status indicates an error\&. Possible causes of errors include:
.PP
.IP "\(bu" 2
The specified variable ID is not valid\&.
.IP "\(bu" 2
The new attribute name is already in use for another attribute of the specified variable\&.
.IP "\(bu" 2
The specified netCDF dataset is in data mode and the new name is longer than the old name\&.
.IP "\(bu" 2
The specified attribute does not exist\&.
.IP "\(bu" 2
The specified netCDF ID does not refer to an open netCDF dataset\&.
.PP
.PP
.SS "Example"
.PP
Here is an example using NF90_RENAME_ATT to rename the variable attribute units to Units for a variable rh in an existing netCDF dataset named foo\&.nc:
.PP
.PP
.nf
use netcdf
implicit none
integer :: ncid1, status
integer :: rhvarid         ! Variable ID
\&.\&.\&.
status = nf90_open("foo\&.nc", nf90_nowrite, ncid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
! Find the IDs of the variables
status = nf90_inq_varid(ncid, "rh", rhvarid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
status = nf90_rename_att(ncid, rhvarid, "units", "Units")
if (status /= nf90_noerr) call handle_err(status)
.fi
.PP
.SH "7\&.7 NF90_DEL_ATT "
.PP
The function NF90_DEL_ATT deletes a netCDF attribute from an open netCDF dataset\&. The netCDF dataset must be in define mode\&.
.PP
.SS "Usage"
.PP
.PP
.nf
function nf90_del_att(ncid, varid, name)
  integer,             intent( in) :: ncid, varid
  character (len = *), intent( in) :: name
  integer                          :: nf90_del_att
.fi
.PP
.PP
\fCncid\fP
.PP
: NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE\&.
.PP
\fCvarid\fP
.PP
: ID of the attribute’s variable, or NF90_GLOBAL for a global attribute\&.
.PP
\fCname\fP
.PP
: The name of the attribute to be deleted\&.
.PP
.SS "Errors"
.PP
NF90_DEL_ATT returns the value NF90_NOERR if no errors occurred\&. Otherwise, the returned status indicates an error\&. Possible causes of errors include:
.PP
.IP "\(bu" 2
The specified variable ID is not valid\&.
.IP "\(bu" 2
The specified netCDF dataset is in data mode\&.
.IP "\(bu" 2
The specified attribute does not exist\&.
.IP "\(bu" 2
The specified netCDF ID does not refer to an open netCDF dataset\&.
.PP
.PP
.SS "Example"
.PP
Here is an example using NF90_DEL_ATT to delete the variable attribute Units for a variable rh in an existing netCDF dataset named foo\&.nc:
.PP
.PP
.nf
use netcdf
implicit none
integer :: ncid1, status
integer :: rhvarid         ! Variable ID
\&.\&.\&.
status = nf90_open("foo\&.nc", nf90_nowrite, ncid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
! Find the IDs of the variables
status = nf90_inq_varid(ncid, "rh", rhvarid)
if (status /= nf90_noerr) call handle_err(status)
\&.\&.\&.
status = nf90_redef(ncid)   ! Enter define mode
if (status /= nf90_noerr) call handle_err(status)
status = nf90_del_att(ncid, rhvarid, "Units")
if (status /= nf90_noerr) call handle_err(status)
status = nf90_enddef(ncid)
if (status /= nf90_noerr) call handle_err(status)
.fi
.PP
 
