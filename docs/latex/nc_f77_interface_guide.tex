This document describes the F\+O\+R\+T\+R\+A\+N-\/77 interface to the net\+C\+DF library.\hypertarget{nc_f77_interface_guide_f77_Use_of_the_NetCDF_Library}{}\section{1 Use of the Net\+C\+D\+F Library }\label{nc_f77_interface_guide_f77_Use_of_the_NetCDF_Library}
You can use the net\+C\+DF library without knowing about all of the net\+C\+DF interface. If you are creating a net\+C\+DF dataset, only a handful of routines are required to define the necessary dimensions, variables, and attributes, and to write the data to the net\+C\+DF dataset. (Even less are needed if you use the ncgen utility to create the dataset before runninga program using net\+C\+DF library calls to write data. See section ‘ncgen’ in The Net\+C\+DF Users Guide.) Similarly, if you are writing software to access data stored in a particular net\+C\+DF object, only a smallbset of the net\+C\+DF library is required to open the net\+C\+DF dataset and access the data. Authors of generic applications that access arbitrary net\+C\+DF datasets need to be familiar with more of the net\+C\+DF library.

In this we provide templates of common sequences of net\+C\+DF calls needed for common uses. For clarity we present only the names of routines; omit declarations and error checking; omit the type-\/specific suffixes of routine names for variables and attributes; indent statements that are typically invoked multiple times; and use ... to represent arbitrary sequences of other statements. Full parameter lists are described in laters.\hypertarget{nc_f77_interface_guide_f77_Creating_a_NetCDF_Dataset}{}\subsection{1.\+1 Creating a Net\+C\+D\+F Dataset }\label{nc_f77_interface_guide_f77_Creating_a_NetCDF_Dataset}
Here is a typical sequence of net\+C\+DF calls used to create a new net\+C\+DF dataset\+:

 

\begin{DoxyVerb}NF_CREATE           ! create netCDF dataset: enter define mode
     ...
   NF_DEF_DIM       ! define dimensions: from name and length
     ...
   NF_DEF_VAR       ! define variables: from name, type, dims
     ...
   NF_PUT_ATT       ! assign attribute values
     ...
NF_ENDDEF           ! end definitions: leave define mode
     ...
   NF_PUT_VAR       ! provide values for variable
     ...
NF_CLOSE            ! close: save new netCDF dataset
\end{DoxyVerb}


Only one call is needed to create a net\+C\+DF dataset, at which point you will be in the first of two net\+C\+DF modes. When accessing an open net\+C\+DF dataset, it is either in define mode or data mode. In define mode, you can create dimensions, variables, and new attributes, but you cannot read or write variable data. In data mode, you can access data and change existing attributes, but you are not permitted to create new dimensions, variables, or attributes.

One call to N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM is needed for each dimension created. Similarly, one call to N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR is needed for each variable creation, and one call to a member of the N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+TT family is needed for each attribute defined and assigned a value. To leave define mode and enter data mode, call N\+F\+\_\+\+E\+N\+D\+D\+EF.

Once in data mode, you can add new data to variables, change old values, and change values of existing attributes (so long as the attribute changes do not require more storage space). Single values may be written to a net\+C\+DF variable with one of the members of the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1 family, depending on what type of data you have to write. All the values of a variable may be written at once with one of the members of the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+AR family. Arrays or array crosss of a variable may be written using members of the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RA family. Subsampled array sections may be written using members of the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RS family. Mapped arrays may be written using members of the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RM family. (Subsampled and mapped access are general forms of data access that are explained later.)

Finally, you should explicitly close all net\+C\+DF datasets that have been opened for writing by calling N\+F\+\_\+\+C\+L\+O\+SE. By default, access to the file system is buffered by the net\+C\+DF library. If a program terminates abnormally with net\+C\+DF datasets open for writing, your most recent modifications may be lost. This default buffering of data is disabled by setting the N\+F\+\_\+\+S\+H\+A\+RE flag when opening the dataset. But even if this flag is set, changes to attribute values or changes made in define mode are not written out until N\+F\+\_\+\+S\+Y\+NC or N\+F\+\_\+\+C\+L\+O\+SE is called.\hypertarget{nc_f77_interface_guide_f77_Reading_a_NetCDF_Dataset_with_Known_Names}{}\subsection{1.\+2 Reading a Net\+C\+D\+F Dataset with Known Names }\label{nc_f77_interface_guide_f77_Reading_a_NetCDF_Dataset_with_Known_Names}
Here we consider the case where you know the names of not only the net\+C\+DF datasets, but also the names of their dimensions, variables, and attributes. (Otherwise you would have to do \char`\"{}inquire\char`\"{} calls.) The order of typical C calls to read data from those variables in a net\+C\+DF dataset is\+:

 

\begin{DoxyVerb}NF_OPEN               ! open existing netCDF dataset
     ...
   NF_INQ_DIMID       ! get dimension IDs
     ...
   NF_INQ_VARID       ! get variable IDs
     ...
   NF_GET_ATT         ! get attribute values
     ...
   NF_GET_VAR         ! get values of variables
     ...
NF_CLOSE              ! close netCDF dataset
\end{DoxyVerb}


First, a single call opens the net\+C\+DF dataset, given the dataset name, and returns a net\+C\+DF ID that is used to refer to the open net\+C\+DF dataset in allbsequent calls.

Next, a call to N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID for each dimension of interest gets the dimension ID from the dimension name. Similarly, each required variable ID is determined from its name by a call to N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+I\+D.\+Once variable I\+Ds are known, variable attribute values can be retrieved using the net\+C\+DF ID, the variable ID, and the desired attribute name as input to a member of the N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+TT family (typically N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+T\+E\+XT or N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE) for each desired attribute. Variable data values can be directly accessed from the net\+C\+DF dataset with calls to members of the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1 family for single values, the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+AR family for entire variables, or various other members of the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RA, N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RS, or N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RM families for array,bsampled or mapped access.

Finally, the net\+C\+DF dataset is closed with N\+F\+\_\+\+C\+L\+O\+SE. There is no need to close a dataset open only for reading.\hypertarget{nc_f77_interface_guide_f77_Reading_a_netCDF_Dataset_with_Unknown_Names}{}\subsection{1.\+3 Reading a net\+C\+D\+F Dataset with Unknown Names }\label{nc_f77_interface_guide_f77_Reading_a_netCDF_Dataset_with_Unknown_Names}
It is possible to write programs (e.\+g., generic software) which doch things as processing every variable, without needing to know in advance the names of these variables. Similarly, the names of dimensions and attributes may be unknown.

Names and other information about net\+C\+DF objects may be obtained from net\+C\+DF datasets by calling inquire functions. These return information about a whole net\+C\+DF dataset, a dimension, a variable, or an attribute. The following template illustrates how they are used\+:

 

\begin{DoxyVerb}NF_OPEN                   ! open existing netCDF dataset
  ...
NF_INQ                    ! find out what is in it
     ...
   NF_INQ_DIM             ! get dimension names, lengths
     ...
   NF_INQ_VAR             ! get variable names, types, shapes
        ...
      NF_INQ_ATTNAME      ! get attribute names
        ...
      NF_INQ_ATT          ! get attribute values
        ...
      NF_GET_ATT          ! get attribute values
        ...
   NF_GET_VAR             ! get values of variables
     ...
NF_CLOSE                  ! close netCDF dataset
\end{DoxyVerb}


As in the previous example, a single call opens the existing net\+C\+DF dataset, returning a net\+C\+DF ID. This net\+C\+DF ID is given to the N\+F\+\_\+\+I\+NQ routine, which returns the number of dimensions, the number of variables, the number of global attributes, and the ID of the unlimited dimension, if there is one.

All the inquire functions are inexpensive to use and require no I/O, since the information they provide is stored in memory when a net\+C\+DF dataset is first opened.

Dimension I\+Ds use consecutive integers, beginning at 1. Also dimensions, once created, cannot be deleted. Therefore, knowing the number of dimension I\+Ds in a net\+C\+DF dataset means knowing all the dimension I\+Ds\+: they are the integers 1, 2, 3, ... up to the number of dimensions. For each dimension ID, a call to the inquire function N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+IM returns the dimension name and length.

Variable I\+Ds are also assigned from consecutive integers 1, 2, 3, ... up to the number of variables. These can be used in N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR calls to find out the names, types, shapes, and the number of attributes assigned to each variable.

Once the number of attributes for a variable is known,ccessive calls to N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME return the name for each attribute given the net\+C\+DF ID, variable ID, and attribute number. Armed with the attribute name, a call to N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+TT returns its type and length. Given the type and length, you can allocate enough space to hold the attribute values. Then a call to a member of the N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+TT family returns the attribute values.

Once the I\+Ds and shapes of net\+C\+DF variables are known, data values can be accessed by calling a member of the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1 family for single values, or members of the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+AR, N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RA, N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RS, or N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RM for various kinds of array access.\hypertarget{nc_f77_interface_guide_f77_Adding_New_Dimensions__Variables__Attributes}{}\subsection{1.\+4 Adding New Dimensions, Variables, Attributes }\label{nc_f77_interface_guide_f77_Adding_New_Dimensions__Variables__Attributes}
An existing net\+C\+DF dataset can be extensively altered. New dimensions, variables, and attributes can be added or existing ones renamed, and existing attributes can be deleted. Existing dimensions, variables, and attributes can be renamed. The following code template lists a typical sequence of calls to add new net\+C\+DF components to an existing dataset\+:

 

\begin{DoxyVerb}NF_OPEN             ! open existing netCDF dataset
  ...
NF_REDEF            ! put it into define mode
    ...
  NF_DEF_DIM        ! define additional dimensions (if any)
    ...
  NF_DEF_VAR        ! define additional variables (if any)
    ...
  NF_PUT_ATT        ! define other attributes (if any)
    ...
NF_ENDDEF           ! check definitions, leave define mode
    ...
  NF_PUT_VAR        ! provide new variable values
    ...
NF_CLOSE            ! close netCDF dataset
\end{DoxyVerb}


A net\+C\+DF dataset is first opened by the N\+F\+\_\+\+O\+P\+EN call. This call puts the open dataset in data mode, which means existing data values can be accessed and changed, existing attributes can be changed (so long as they do not grow), but nothing can be added. To add new net\+C\+DF dimensions, variables, or attributes you must enter define mode, by calling N\+F\+\_\+\+R\+E\+D\+E\+F.\+In define mode, call N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM to define new dimensions, N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR to define new variables, and a member of the N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+TT family to assign new attributes to variables or enlarge old attributes.

You can leave define mode and reenter data mode, checking all the new definitions for consistency and committing the changes to disk, by calling N\+F\+\_\+\+E\+N\+D\+D\+EF. If you do not wish to reenter data mode, just call N\+F\+\_\+\+C\+L\+O\+SE, which will have the effect of first calling N\+F\+\_\+\+E\+N\+D\+D\+EF.

Until the N\+F\+\_\+\+E\+N\+D\+D\+EF call, you may back out of all the redefinitions made in define mode and restore the previous state of the net\+C\+DF dataset by calling N\+F\+\_\+\+A\+B\+O\+RT. You may also use the N\+F\+\_\+\+A\+B\+O\+RT call to restore the net\+C\+DF dataset to a consistent state if the call to N\+F\+\_\+\+E\+N\+D\+D\+EF fails. If you have called N\+F\+\_\+\+C\+L\+O\+SE from definition mode and the implied call to N\+F\+\_\+\+E\+N\+D\+D\+EF fails, N\+F\+\_\+\+A\+B\+O\+RT will automatically be called to close the net\+C\+DF dataset and leave it in its previous consistent state (before you entered define mode).

At most one process should have a net\+C\+DF dataset open for writing at one time. The library is designed to provide limitedpport for multiple concurrent readers with one writer, via disciplined use of the N\+F\+\_\+\+S\+Y\+NC function and the N\+F\+\_\+\+S\+H\+A\+RE flag. If a writer makes changes in define mode,ch as the addition of new variables, dimensions, or attributes, some means external to the library is necessary to prevent readers from making concurrent accesses and to inform readers to call N\+F\+\_\+\+S\+Y\+NC before the next access.\hypertarget{nc_f77_interface_guide_f77_Error_Handling_1_5}{}\subsection{1.\+5 Error Handling }\label{nc_f77_interface_guide_f77_Error_Handling_1_5}
The net\+C\+DF library provides the facilities needed to handle errors in a flexible way. Each net\+C\+DF function returns an integer status value. If the returned status value indicates an error, you may handle it in any way desired, from printing an associated error message and exiting to ignoring the error indication and proceeding (not recommended!). For simplicity, the examples in this guide check the error status and call a separate function to handle any errors.

The N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+OR function is available to convert a returned integer error status into an error message string.

Occasionally, low-\/level I/O errors may occur in a layer below the net\+C\+DF library. For example, if a write operation causes you to exceed disk quotas or to attempt to write to a device that is no longer available, you may get an error from a layer below the net\+C\+DF library, but the rlting write error will still be reflected in the returned status value.\hypertarget{nc_f77_interface_guide_f77_Compiling_and_Linking_with_the_NetCDF_Library}{}\subsection{1.\+6 Compiling and Linking with the Net\+C\+D\+F Library }\label{nc_f77_interface_guide_f77_Compiling_and_Linking_with_the_NetCDF_Library}
Details of how to compile and link a program that uses the net\+C\+DF C or F\+O\+R\+T\+R\+AN interfaces differ, depending on the operating system, the available compilers, and where the net\+C\+DF library and include files are installed. Nevertheless, we provide here examples of how to compile and link a program that uses the net\+C\+DF library on a Unix platform, so that you can adjust these examples to fit your installation.

Every F\+O\+R\+T\+R\+AN file that references net\+C\+DF functions or constants must contain an appropriate I\+N\+C\+L\+U\+DE statement before the first reference\+: \begin{DoxyVerb}INCLUDE 'netcdf.inc'
\end{DoxyVerb}


Unless the netcdf.\+inc file is installed in a standard directory where the F\+O\+R\+T\+R\+AN compiler always looks, you must use the -\/I option when invoking the compiler, to specify a directory where netcdf.\+inc is installed, for example\+: \begin{DoxyVerb}f77 -c -I/usr/local/include myprogram.f
\end{DoxyVerb}


Unless the net\+C\+DF library is installed in a standard directory where the linker always looks, you must use the -\/L and -\/l options to link an object file that uses the net\+C\+DF library. Since version 4.\+1.\+3, the net\+C\+DF Fortran library (named ‘libnetcdff’) is distinct from the net\+C\+DF C library (named ‘libnetcdf’), but depends on it. If it is installed as a shared library, you need only use ‘-\/lnetcdff’ to specify the Fortran library for linking.

For example, if installed as a shared library, use something like\+:

\begin{DoxyVerb}f77 -o myprogram myprogram.o -L/usr/local/lib -lnetcdff
\end{DoxyVerb}


If installed as a static library, you will at least need to mention the net\+C\+DF C library and perhaps other libraries,ch as hdf5 or curl, depending on how the C library was built. For example\+:

 

\begin{DoxyVerb}f77 -o myprogram myprogram.o -L/usr/local/lib -lnetcdff -lnetcdf
\end{DoxyVerb}


Use of the nf-\/config utility program, installed as part of the netcdf-\/fortran software, provides an easier way to compile and link, without needing to know the details of where the library has been installed, or whether it is installed as a shared or static library.

To see all the options for ‘nf-\/config’, invoke it with the ‘–help’ argument.

Here’s an example of how you could use ‘nf-\/config’ to compile and link a Fortran program in one step\+:

 

\begin{DoxyVerb}f77 myprogram.f -o myprogram `nf-config --fflags --flibs`
\end{DoxyVerb}


If it is installed on your system, you could also use the ‘pkg-\/config’ utility to compile and link Fortran programs with the net\+C\+DF libraries. This is especially useful in Makefiles, to ilate them from changes to library versions and dependencies. Here is an example of how you could compile and link a Fortran program with net\+C\+DF libraries using pkg-\/config\+:

 

\begin{DoxyVerb}export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig
f77 myprogram.f -o myprogram `pkg-config --cflags --libs netcdf-fortran`
\end{DoxyVerb}


where here ‘–cflags’ means compiler flags and ‘libs’ requests that the approriate libraries be linked in.\hypertarget{nc_f77_interface_guide_f77_Datasets}{}\section{2. Datasets  }\label{nc_f77_interface_guide_f77_Datasets}
\hypertarget{nc_f77_interface_guide_f77_Datasets_Introduction}{}\subsection{2.\+1 Datasets Introduction }\label{nc_f77_interface_guide_f77_Datasets_Introduction}
This presents the interfaces of the net\+C\+DF functions that deal with a net\+C\+DF dataset or the whole net\+C\+DF library.

A net\+C\+DF dataset that has not yet been opened can only be referred to by its dataset name. Once a net\+C\+DF dataset is opened, it is referred to by a net\+C\+DF ID, which is a small nonnegative integer returned when you create or open the dataset. A net\+C\+DF ID is much like a file descriptor in C or a logical unit number in F\+O\+R\+T\+R\+AN. In any single program, the net\+C\+DF I\+Ds of distinct open net\+C\+DF datasets are distinct. A single net\+C\+DF dataset may be opened multiple times and will then have multiple distinct net\+C\+DF I\+Ds; however at most one of the open instances of a single net\+C\+DF dataset should permit writing. When an open net\+C\+DF dataset is closed, the ID is no longer associated with a net\+C\+DF dataset.

Functions that deal with the net\+C\+DF library include\+:


\begin{DoxyItemize}
\item Get version of library.
\item Get error message corresponding to a returned error code.
\end{DoxyItemize}

The operationspported on a net\+C\+DF dataset as a single object are\+:


\begin{DoxyItemize}
\item Create, given dataset name and whether to overwrite or not.
\item Open for access, given dataset name and read or write intent.
\item Put into define mode, to add dimensions, variables, or attributes.
\item Take out of define mode, checking consistency of additions.
\item Close, writing to disk if required.
\item Inquire about the number of dimensions, number of variables, number of global attributes, and ID of the unlimited dimension, if any.
\item Synchronize to disk to makere it is current.
\item Set and unset nofill mode for optimized sequential writes.
\item After ammary of conventions used in describing the net\+C\+DF interfaces, the rest of this presents a detailed description of the interfaces for these operations.
\end{DoxyItemize}\hypertarget{nc_f77_interface_guide_f77_NetCDF_Library_Interface_Descriptions}{}\subsection{2.\+2 Net\+C\+D\+F Library Interface Descriptions }\label{nc_f77_interface_guide_f77_NetCDF_Library_Interface_Descriptions}
Each interface description for a particular net\+C\+DF function in this and laters contains\+:


\begin{DoxyItemize}
\item a description of the purpose of the function;
\item a F\+O\+R\+T\+R\+AN function prototype that presents the type and order of the formal parameters to the function;
\item a description of each formal parameter in the C interface;
\item a list of possible error conditions; and
\item an example of a F\+O\+R\+T\+R\+AN program fragment calling the net\+C\+DF function (and perhaps other net\+C\+DF functions).
\end{DoxyItemize}

The examples follow a simple convention for error handling, always checking the error status returned from each net\+C\+DF function call and calling a handle\+\_\+error function in case an error was detected. For an example ofch a function, see Section 5.\+2 \char`\"{}\+Get error message
corresponding to error status\+: nf\textbackslash{}\+\_\+strerror\char`\"{}.\hypertarget{nc_f77_interface_guide_f77_NF_STRERROR}{}\subsection{2.\+3 N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+O\+R }\label{nc_f77_interface_guide_f77_NF_STRERROR}
The function N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+OR returns a static reference to an error message string corresponding to an integer net\+C\+DF error status or to a system error number, prmably returned by a previous call to some other net\+C\+DF function. The list of net\+C\+DF error status codes is available in the appropriate include file for each language binding.

\subsubsection*{Usage}


\begin{DoxyCode}
CHARACTER*80 FUNCTION NF\_STRERROR(INTEGER NCERR)
\end{DoxyCode}


{\ttfamily N\+C\+E\+RR} \+: An error status that might have been returned from a previous call to some net\+C\+DF function.

\subsubsection*{Errors}

If you provide an invalid integer error status that does not correspond to any net\+C\+DF error message or or to any system error message (as understood by the system strerror function), N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+OR returns a string indicating that there is noch error status.

\subsubsection*{Example}

Here is an example of a simple error handling function that uses N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+OR to print the error message corresponding to the net\+C\+DF error status returned from any net\+C\+DF function call and then exit\+:

 


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
SUBROUTINE HANDLE\_ERR(STATUS)
INTEGER STATUS
IF (STATUS .NE. NF\_NOERR) THEN
  PRINT *, NF\_STRERROR(STATUS)
  STOP 'Stopped'
ENDIF
END
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_Get_netCDF_library_version_NF_INQ_LIBVERS}{}\subsection{2.\+4 Get net\+C\+D\+F library version\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+L\+I\+B\+V\+E\+R\+S }\label{nc_f77_interface_guide_f77_Get_netCDF_library_version_NF_INQ_LIBVERS}
The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+L\+I\+B\+V\+E\+RS returns a string identifying the version of the net\+C\+DF library, and when it was built.

\subsubsection*{Usage}


\begin{DoxyCode}
CHARACTER*80 FUNCTION NF\_INQ\_LIBVERS()
\end{DoxyCode}


\subsubsection*{Errors}

This function takes no arguments, and thus no errors are possible in its invocation.

\subsubsection*{Example}

Here is an example using nf\+\_\+inq\+\_\+libvers to print the version of the net\+C\+DF library with which the program is linked\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
PRINT *, NF\_INQ\_LIBVERS()
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF_CREATE}{}\subsection{2.\+5 N\+F\+\_\+\+C\+R\+E\+A\+T\+E }\label{nc_f77_interface_guide_f77_NF_CREATE}
This function creates a new net\+C\+DF dataset, returning a net\+C\+DF ID that can sequently be used to refer to the net\+C\+DF dataset in other net\+C\+DF function calls. The new net\+C\+DF dataset opened for write access and placed in define mode, ready for you to add dimensions, variables, and attributes.

A creation mode flag specifies whether to overwrite any existing dataset with the same name and whether access to the dataset is shared.

\subsubsection*{Usage}

  
\begin{DoxyCode}
INTEGER FUNCTION NF\_CREATE (CHARACTER*(*) PATH, INTEGER CMODE,
                            INTEGER ncid)
\end{DoxyCode}


{\ttfamily P\+A\+TH}\+: The file name of the new net\+C\+DF dataset.

{\ttfamily C\+M\+O\+DE}\+: The creation mode flag. The following flags are available\+: N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+F\+\_\+\+S\+H\+A\+RE, N\+F\+\_\+64\+B\+I\+T\+\_\+\+O\+F\+F\+S\+ET, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 and N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL. You can combine the affect of multiple flags in a single argument by using the bitwise OR operator. For example, to specify both N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER and N\+F\+\_\+\+S\+H\+A\+RE, you could provide the argument O\+R(\+N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+E\+R, N\+F\+\_\+\+S\+H\+A\+R\+E).

A zero value (defined for convenience as N\+F\+\_\+\+C\+L\+O\+B\+B\+ER) specifies the default behavior\+: overwrite any existing dataset with the same file name and buffer and cache accesses for efficiency. The dataset will be in net\+C\+DF classic format. See \textquotesingle{}Net\+C\+DF Classic Format Limitations\textquotesingle{} in The Net\+C\+DF Users Guide.

Setting N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER means you do not want to clobber (overwrite) an existing dataset; an error (N\+F\+\_\+\+E\+E\+X\+I\+ST) is returned if the specified dataset already exists.

The N\+F\+\_\+\+S\+H\+A\+RE flag is appropriate when one process may be writing the dataset and one or more other processes reading the dataset concurrently; it means that dataset accesses are not buffered and caching is limited. Since the buffering scheme is optimized for sequential access, programs that do not access data sequentially may see some performance improvement by setting the N\+F\+\_\+\+S\+H\+A\+RE flag. This only applied to classic and 64-\/bit offset format files.

Setting N\+F\+\_\+64\+B\+I\+T\+\_\+\+O\+F\+F\+S\+ET causes net\+C\+DF to create a 64-\/bit offset format file, instead of a net\+C\+DF classic format file. The 64-\/bit offset format imposes far fewer restrictions on very large (i.\+e. over 2 GB) data files. See \href{netcdf.html#Large-File-Support}{\tt (netcdf)Large File Support} ‘\+Large File Support’ in The Net\+C\+DF Users Guide.

Setting N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 causes net\+C\+DF to create a net\+C\+D\+F-\/4/\+H\+D\+F5 format file. Oring N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL with N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 causes the net\+C\+DF library to create a net\+C\+D\+F-\/4/\+H\+D\+F5 data file, with the net\+C\+DF classic model enforced -\/ none of the new features of the net\+C\+D\+F-\/4 data model may be usedinch a file, for example groups and user-\/defined types.

{\ttfamily ncid} \+: Returned net\+C\+DF ID.

\subsubsection*{Errors}

N\+F\+\_\+\+C\+R\+E\+A\+TE returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Passing a dataset name that includes a directory that does not exist.
\item Specifying a dataset name of a file that exists and also specifying N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER.
\item Specifying a meaningless value for the creation mode.
\item Attempting to create a net\+C\+DF dataset in a directory where you don’t have permission to create files.
\end{DoxyItemize}

\subsubsection*{Example}

In this example we create a net\+C\+DF dataset named foo.\+nc; we want the dataset to be created in the current directory only if a dataset with that name does not already exist\+:

 


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
  ...
INTEGER NCID, STATUS
...
STATUS = NF\_CREATE('foo.nc', NF\_NOCLOBBER, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_F__CREATE}{}\subsection{2.\+6 N\+F\+\_\+\+\_\+\+C\+R\+E\+A\+T\+E }\label{nc_f77_interface_guide_f77_F__CREATE}
This function is a variant of N\+F\+\_\+\+C\+R\+E\+A\+TE, N\+F\+\_\+\+\_\+\+C\+R\+E\+A\+TE (note the double underscore) allows users to specify two tuning parameters for the file that it is creating. These tuning parameters are not written to the data file, they are only used for so long as the file remains open after an N\+F\+\_\+\+\_\+\+C\+R\+E\+A\+TE.

This function creates a new net\+C\+DF dataset, returning a net\+C\+DF ID that canbsequently be used to refer to the net\+C\+DF dataset in other net\+C\+DF function calls. The new net\+C\+DF dataset opened for write access and placed in define mode, ready for you to add dimensions, variables, and attributes.

A creation mode flag specifies whether to overwrite any existing dataset with the same name and whether access to the dataset is shared.

\subsubsection*{Usage}


\begin{DoxyCode}
INTEGER FUNCTION NF\_\_CREATE (CHARACTER*(*) PATH, INTEGER CMODE, INTEGER INITIALSZ,
                            INTEGER BUFRSIZEHINT, INTEGER ncid)
\end{DoxyCode}
 {\ttfamily P\+A\+TH} \+: The file name of the new net\+C\+DF dataset.

{\ttfamily C\+M\+O\+DE} \+: The creation mode flag. The following flags are available\+: N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+F\+\_\+\+S\+H\+A\+RE, N\+F\+\_\+64\+B\+I\+T\+\_\+\+O\+F\+F\+S\+ET, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, and N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL.

Setting N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER means you do not want to clobber (overwrite) an existing dataset; an error (N\+F\+\_\+\+E\+E\+X\+I\+ST) is returned if the specified dataset already exists.

The N\+F\+\_\+\+S\+H\+A\+RE flag is appropriate when one process may be writing the dataset and one or more other processes reading the dataset concurrently; it means that dataset accesses are not buffered and caching is limited. Since the buffering scheme is optimized for sequential access, programs that do not access data sequentially may see some performance improvement by setting the N\+F\+\_\+\+S\+H\+A\+RE flag. This flag has no effect with net\+C\+D\+F-\/4/\+H\+D\+F5 files.

Setting N\+F\+\_\+64\+B\+I\+T\+\_\+\+O\+F\+F\+S\+ET causes net\+C\+DF to create a 64-\/bit offset format file, instead of a net\+C\+DF classic format file. The 64-\/bit offset format imposes far fewer restrictions on very large (i.\+e. over 2 GB) data files. See \href{netcdf.html#Large-File-Support}{\tt (netcdf)Large File Support} ‘\+Large File Support’ in The Net\+C\+DF Users Guide.

Setting N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL causes net\+C\+DF to enforce the classic data model in this file. (This only has effect for net\+C\+D\+F-\/4/\+H\+D\+F5 files, as classic and 64-\/bit offset files always use the classic model.) When used with N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, this flag eres that the rlting net\+C\+D\+F-\/4/\+H\+D\+F5 file may never contain any new constructs from the enhanced data model. That is, it cannot contain groups, user defined types, multiple unlimited dimensions, or new atomic types. The advantage of this restriction is thatch files are guarenteed to work with existing net\+C\+DF software.

A zero value (defined for convenience as N\+F\+\_\+\+C\+L\+O\+B\+B\+ER) specifies the default behavior\+: overwrite any existing dataset with the same file name and buffer and cache accesses for efficiency. The dataset will be in net\+C\+DF classic format. See \href{netcdf.html#NetCDF-Classic-Format-Limitations}{\tt (netcdf)Net\+C\+DF Classic Format Limitations} ‘\+Net\+C\+DF Classic Format Limitations’ in The Net\+C\+DF Users Guide.

{\ttfamily I\+N\+I\+T\+I\+A\+L\+SZ} \+: This parameter sets the initial size of the file at creation time.

{\ttfamily B\+U\+F\+R\+S\+I\+Z\+E\+H\+I\+NT} \+: The argument referenced by B\+U\+F\+R\+S\+I\+Z\+E\+H\+I\+NT controls a space ves time tradeoff, memory allocated in the netcdf library ves number of system calls.

Because of internal requirements, the value may not be set to exactly the value requested. The actual value chosen is returned by reference.

Using the value N\+F\+\_\+\+S\+I\+Z\+E\+H\+I\+N\+T\+\_\+\+D\+E\+F\+A\+U\+LT causes the library to choose a default. How the system chooses the default depends on the system. On many systems, the \char`\"{}preferred I/\+O block size\char`\"{} is available from the stat() system call, struct stat member st\+\_\+blksize. If this is available it is used. Lacking that, twice the system pagesize is used.

Lacking a call to discover the system pagesize, we just set default bufrsize to 8192.

The B\+U\+F\+R\+S\+I\+ZE is a property of a given open netcdf descriptor ncid, it is not a persistent property of the netcdf dataset.

{\ttfamily ncid} \+: Returned net\+C\+DF ID.

\subsubsection*{Errors}

N\+F\+\_\+\+\_\+\+C\+R\+E\+A\+TE returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Passing a dataset name that includes a directory that does not exist.
\item Specifying a dataset name of a file that exists and also specifying N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER.
\item Specifying a meaningless value for the creation mode.
\item Attempting to create a net\+C\+DF dataset in a directory where you don’t have permission to create files.
\end{DoxyItemize}

\subsubsection*{Example}

In this example we create a net\+C\+DF dataset named foo.\+nc; we want the dataset to be created in the current directory only if a dataset with that name does not already exist\+:

 


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
  ...
INTEGER NCID, STATUS, INITIALSZ, BUFRSIZEHINT
...
INITIALSZ = 2048
BUFRSIZEHINT = 1024
STATUS = NF\_\_CREATE('foo.nc', NF\_NOCLOBBER, INITIALSZ, BUFRSIZEHINT, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF_CREATE_PAR}{}\subsection{2.\+7 N\+F\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+P\+A\+R }\label{nc_f77_interface_guide_f77_NF_CREATE_PAR}
This function is a variant of nf\+\_\+create, nf\+\_\+create\+\_\+par allows users to open a file on a M\+P\+I/\+IO or M\+P\+I/\+Posix parallel file system.

The parallel parameters are not written to the data file, they are only used for so long as the file remains open after an nf\+\_\+create\+\_\+par.

This function is only available if the net\+C\+DF library was built with parallel I/O.

This function creates a new net\+C\+DF dataset, returning a net\+C\+DF ID that canbsequently be used to refer to the net\+C\+DF dataset in other net\+C\+DF function calls. The new net\+C\+DF dataset opened for write access and placed in define mode, ready for you to add dimensions, variables, and attributes.

When a net\+C\+D\+F-\/4 file is created for parallel access, independent operations are the default. To use collective access on a variable, See section \href{#NF_005fVAR_005fPAR_005fACCESS}{\tt Change between Collective and Independent Parallel Access\+: N\+F\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+SS}.

\subsubsection*{Usage}


\begin{DoxyCode}
INTEGER FUNCTION NF\_CREATE\_PAR(CHARACTER*(*) PATH, INTEGER CMODE,
                               INTEGER MPI\_COMM, INTEGER MPI\_INFO,
                               INTEGER ncid)
\end{DoxyCode}


{\ttfamily P\+A\+TH} \+: The file name of the new net\+C\+DF dataset.

{\ttfamily C\+M\+O\+DE} \+: The creation mode flag. The following flags are available\+: N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 and N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL. You can combine the affect of multiple flags in a single argument by using the bitwise OR operator. For example, to specify both N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER and N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, you could provide the argument OR(N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4).

Setting N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 causes net\+C\+DF to create a net\+C\+D\+F-\/4/\+H\+D\+F5 format file. Oring N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL with N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 causes the net\+C\+DF library to create a net\+C\+D\+F-\/4/\+H\+D\+F5 data file, with the net\+C\+DF classic model enforced -\/ none of the new features of the net\+C\+D\+F-\/4 data model may be usedinch a file, for example groups and user-\/defined types.

Only net\+C\+D\+F-\/4/\+H\+D\+F5 files may be used with parallel I/O.

{\ttfamily M\+P\+I\+\_\+\+C\+O\+MM} \+: The M\+PI communicator.

{\ttfamily M\+P\+I\+\_\+\+I\+N\+FO} \+: The M\+PI info.

{\ttfamily ncid} \+: Returned net\+C\+DF ID.

\subsubsection*{Errors}

N\+F\+\_\+\+C\+R\+E\+A\+TE returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Passing a dataset name that includes a directory that does not exist.
\item Specifying a dataset name of a file that exists and also specifying N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER.
\item Specifying a meaningless value for the creation mode.
\item Attempting to create a net\+C\+DF dataset in a directory where you don’t have permission to create files.
\end{DoxyItemize}

\subsubsection*{Example}

This example is from test program nf\+\_\+test/ftst\+\_\+parallel.\+F.

 


\begin{DoxyCode}
!     Create the netCDF file.
      mode\_flag = IOR(nf\_netcdf4, nf\_classic\_model)
      retval = nf\_create\_par(FILE\_NAME, mode\_flag, MPI\_COMM\_WORLD,
     $     MPI\_INFO\_NULL, ncid)
      if (retval .ne. nf\_noerr) stop 2
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF_OPEN_}{}\subsection{2.\+8 N\+F\+\_\+\+O\+P\+E\+N  }\label{nc_f77_interface_guide_f77_NF_OPEN_}
The function N\+F\+\_\+\+O\+P\+EN opens an existing net\+C\+DF dataset for access.

\subsubsection*{Usage}


\begin{DoxyCode}
INTEGER FUNCTION NF\_OPEN(CHARACTER*(*) PATH, INTEGER OMODE, INTEGER ncid)
\end{DoxyCode}


{\ttfamily P\+A\+TH} \+: File name for net\+C\+DF dataset to be opened. This may be an O\+Pe\+N\+D\+AP U\+RL if D\+A\+Ppport is enabled.

{\ttfamily O\+M\+O\+DE} \+: A zero value (or N\+F\+\_\+\+N\+O\+W\+R\+I\+TE) specifies\+: open the dataset with read-\/only access, buffering and caching accesses for efficiency.

Otherwise, the creation mode is N\+F\+\_\+\+W\+R\+I\+TE, N\+F\+\_\+\+S\+H\+A\+RE, or O\+R(\+N\+F\+\_\+\+W\+R\+I\+T\+E, N\+F\+\_\+\+S\+H\+A\+R\+E). Setting the N\+F\+\_\+\+W\+R\+I\+TE flag opens the dataset with read-\/write access. (\char`\"{}\+Writing\char`\"{} means any kind of change to the dataset, including appending or changing data, adding or renaming dimensions, variables, and attributes, or deleting attributes.) The N\+F\+\_\+\+S\+H\+A\+RE flag is appropriate when one process may be writing the dataset and one or more other processes reading the dataset concurrently; it means that dataset accesses are not buffered and caching is limited. Since the buffering scheme is optimized for sequential access, programs that do not access data sequentially may see some performance improvement by setting the N\+F\+\_\+\+S\+H\+A\+RE flag.

{\ttfamily ncid} \+: Returned net\+C\+DF ID.

\subsubsection*{Errors}

N\+F\+\_\+\+O\+P\+EN returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset does not exist.
\item A meaningless mode was specified.
\end{DoxyItemize}

\subsubsection*{Example}

Here is an example using N\+F\+\_\+\+O\+P\+EN to open an existing net\+C\+DF dataset named foo.\+nc for read-\/only, non-\/shared access\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
 ...
INTEGER NCID, STATUS
...
STATUS = NF\_OPEN('foo.nc', 0, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_NF__OPEN_}{}\subsection{2.\+9 N\+F\+\_\+\+\_\+\+O\+P\+E\+N  }\label{nc_f77_interface_guide_NF__OPEN_}
The function N\+F\+\_\+\+O\+P\+EN opens an existing net\+C\+DF dataset for access, with a performance tuning parameter.

\subsubsection*{Usage}


\begin{DoxyCode}
INTEGER FUNCTION NF\_OPEN(CHARACTER*(*) PATH, INTEGER OMODE, INTEGER
BUFRSIZEHINT, INTEGER ncid)
\end{DoxyCode}


{\ttfamily P\+A\+TH} \+: File name for net\+C\+DF dataset to be opened.

{\ttfamily O\+M\+O\+DE} \+: A zero value (or N\+F\+\_\+\+N\+O\+W\+R\+I\+TE) specifies\+: open the dataset with read-\/only access, buffering and caching accesses for efficiency

Otherwise, the creation mode is N\+F\+\_\+\+W\+R\+I\+TE, N\+F\+\_\+\+S\+H\+A\+RE, or O\+R(\+N\+F\+\_\+\+W\+R\+I\+T\+E,\+N\+F\+\_\+\+S\+H\+A\+R\+E). Setting the N\+F\+\_\+\+W\+R\+I\+TE flag opens the dataset with read-\/write access. (\char`\"{}\+Writing\char`\"{} means any kind of change to the dataset, including appending or changing data, adding or renaming dimensions, variables, and attributes, or deleting attributes.) The N\+F\+\_\+\+S\+H\+A\+RE flag is appropriate when one process may be writing the dataset and one or more other processes reading the dataset concurrently; it means that dataset accesses are not buffered and caching is limited. Since the buffering scheme is optimized for sequential access, programs that do not access data sequentially may see some performance improvement by setting the N\+F\+\_\+\+S\+H\+A\+RE flag.

{\ttfamily B\+U\+F\+R\+S\+I\+Z\+E\+H\+I\+NT} \+: This argument controls a space ves time tradeoff, memory allocated in the netcdf library ves number of system calls.

Because of internal requirements, the value may not be set to exactly the value requested. The actual value chosen is returned by reference.

Using the value N\+F\+\_\+\+S\+I\+Z\+E\+H\+I\+N\+T\+\_\+\+D\+E\+F\+A\+U\+LT causes the library to choose a default. How the system chooses the default depends on the system. On many systems, the \char`\"{}preferred I/\+O block size\char`\"{} is available from the stat() system call, struct stat member st\+\_\+blksize. If this is available it is used. Lacking that, twice the system pagesize is used.

Lacking a call to discover the system pagesize, we just set default bufrsize to 8192.

The bufrsize is a property of a given open netcdf descriptor ncid, it is not a persistent property of the netcdf dataset.

{\ttfamily ncid} \+: Returned net\+C\+DF ID.

\subsubsection*{Errors}

N\+F\+\_\+\+\_\+\+O\+P\+EN returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset does not exist.
\item A meaningless mode was specified.
\end{DoxyItemize}

\subsubsection*{Example}

Here is an example using N\+F\+\_\+\+\_\+\+O\+P\+EN to open an existing net\+C\+DF dataset named foo.\+nc for read-\/only, non-\/shared access\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
 ...
INTEGER NCID, STATUS, BUFRSIZEHINT
...
BUFRSIZEHINT = 1024
STATUS = NF\_OPEN('foo.nc', 0, BUFRSIZEHINT, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF_OPEN_PAR}{}\subsection{2.\+10 N\+F\+\_\+\+O\+P\+E\+N\+\_\+\+P\+A\+R  }\label{nc_f77_interface_guide_f77_NF_OPEN_PAR}
This function opens a net\+C\+D\+F-\/4 dataset for parallel access.

This function is only available if the net\+C\+DF library was built with a H\+D\+F5 library for which –enable-\/parallel was used, and which was linked (like H\+D\+F5) to M\+PI libraries.

This opens the file using either M\+P\+I-\/\+IO or M\+P\+I-\/\+P\+O\+S\+IX. The file must be a net\+C\+D\+F-\/4 file. (That is, it must have been created using N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 in the creation mode).

This function is only available if net\+C\+D\+F-\/4 was build with a version of the H\+D\+F5 library which was built with –enable-\/parallel.

Before either H\+D\+F5 or net\+C\+D\+F-\/4 can be installed withpport for parallel programming, and M\+PI layer must also be installed on the machine, and ally a parallel file system.

Net\+C\+D\+F-\/4 exposes the parallel access functionality of H\+D\+F5. For more information about what is required to install and use the parallel access functions, see the H\+D\+F5 web site.

When a net\+C\+D\+F-\/4 file is opened for parallel access, collective operations are the default. To use independent access on a variable, See section \href{#NF_005fVAR_005fPAR_005fACCESS}{\tt Change between Collective and Independent Parallel Access\+: N\+F\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+SS}.

\subsection*{Usage }


\begin{DoxyCode}
INTEGER FUNCTION NF\_OPEN\_PAR(CHARACTER*(*) PATH, INTEGER OMODE,
                             INTEGER MPI\_COMM, INTEGER MPI\_INFO,
                             INTEGER ncid)
\end{DoxyCode}


{\ttfamily P\+A\+TH} \+: File name for net\+C\+DF dataset to be opened.

{\ttfamily O\+M\+O\+DE} \+: A zero value (or N\+F\+\_\+\+N\+O\+W\+R\+I\+TE) specifies\+: open the dataset with read-\/only access.

Otherwise, the mode may be N\+F\+\_\+\+W\+R\+I\+TE. Setting the N\+F\+\_\+\+W\+R\+I\+TE flag opens the dataset with read-\/write access. (\char`\"{}\+Writing\char`\"{} means any kind of change to the dataset, including appending or changing data, adding or renaming dimensions, variables, and attributes, or deleting attributes.)

Setting N\+F\+\_\+\+N\+E\+T\+C\+D\+F4 is not necessary (or allowed). The file type is detected automatically.

{\ttfamily M\+P\+I\+\_\+\+C\+O\+MM} \+: The M\+PI communicator.

{\ttfamily M\+P\+I\+\_\+\+I\+N\+FO} \+: The M\+PI info.

{\ttfamily ncid} \+: Returned net\+C\+DF ID.

\subsection*{Errors }

N\+F\+\_\+\+O\+P\+EN returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset does not exist.
\item A meaningless mode was specified.
\item Not a net\+C\+D\+F-\/4 file.
\end{DoxyItemize}

\subsection*{Example }

This example is from the test program nf\+\_\+test/ftst\+\_\+parallel.\+F.

 


\begin{DoxyCode}
!     Reopen the file.
      retval = nf\_open\_par(FILE\_NAME, nf\_nowrite, MPI\_COMM\_WORLD,
     $     MPI\_INFO\_NULL, ncid)
      if (retval .ne. nf\_noerr) stop 2
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF-REDEF}{}\subsection{2.\+11 N\+F\+\_\+\+R\+E\+D\+E\+F }\label{nc_f77_interface_guide_f77_NF-REDEF}
The function N\+F\+\_\+\+R\+E\+D\+EF puts an open net\+C\+DF dataset into define mode, so dimensions, variables, and attributes can be added or renamed and attributes can be deleted.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+R\+E\+D\+E\+F(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors }

N\+F\+\_\+\+R\+E\+D\+EF returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset is already in define mode.
\item The specified net\+C\+DF dataset was opened for read-\/only.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+R\+E\+D\+EF to open an existing net\+C\+DF dataset named foo.\+nc and put it into define mode\+:

  
\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
INTEGER NCID, STATUS
   ...
STATUS = NF\_OPEN('foo.nc', NF\_WRITE, NCID)   ! open dataset
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
   ...
STATUS = NF\_REDEF(NCID)                      ! put in define mode
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF-ENDDEF}{}\subsection{2.\+12 N\+F\+\_\+\+E\+N\+D\+D\+E\+F }\label{nc_f77_interface_guide_f77_NF-ENDDEF}
The function N\+F\+\_\+\+E\+N\+D\+D\+EF takes an open net\+C\+DF dataset out of define mode. The changes made to the net\+C\+DF dataset while it was in define mode are checked and committed to disk if no problems occurred. Non-\/record variables may be initialized to a \char`\"{}fill value\char`\"{} as well (see \href{#NF_005fSET_005fFILL}{\tt N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL}). The net\+C\+DF dataset is then placed in data mode, so variable data can be read or written.

This call may involve copying data under some circumstances. See \href{netcdf.html#File-Structure-and-Performance}{\tt (netcdf)File Structure and Performance} ‘\+File Structure and Performance’ in Net\+C\+DF Users’ Guide.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+E\+N\+D\+D\+E\+F(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors }

N\+F\+\_\+\+E\+N\+D\+D\+EF returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset is not in define mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset. The size of one or more variables exceed the size constraints for whichever variant of the file format is in use). See \href{netcdf.html#Large-File-Support}{\tt (netcdf)Large File Support} ‘\+Large File Support’ in The Net\+C\+DF Users Guide.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+E\+N\+D\+D\+EF to finish the definitions of a new net\+C\+DF dataset named foo.\+nc and put it into data mode\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
INTEGER NCID, STATUS
   ...
STATUS = NF\_CREATE('foo.nc', NF\_NOCLOBBER, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)

   ...   ! create dimensions, variables, attributes

STATUS = NF\_ENDDEF(NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF__ENDDEF}{}\subsection{2.\+13 N\+F\+\_\+\+\_\+\+E\+N\+D\+D\+E\+F }\label{nc_f77_interface_guide_f77_NF__ENDDEF}
The function N\+F\+\_\+\+\_\+\+E\+N\+D\+D\+EF takes an open net\+C\+DF dataset out of define mode. The changes made to the net\+C\+DF dataset while it was in define mode are checked and committed to disk if no problems occurred. Non-\/record variables may be initialized to a \char`\"{}fill value\char`\"{} as well (see \href{#NF_005fSET_005fFILL}{\tt N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL}). The net\+C\+DF dataset is then placed in data mode, so variable data can be read or written.

This call may involve copying data under some circumstances. See \href{netcdf.html#File-Structure-and-Performance}{\tt (netcdf)File Structure and Performance} ‘\+File Structure and Performance’ in Net\+C\+DF Users’ Guide.

This function ames specific characteristics of the netcdf version 1 and version 2 file formats. Users should use nf\+\_\+enddef in most circumstances. Although this function will be available in future net\+C\+DF implementations, it may not continue to have any effect on performance.

The current netcdf file format has threes, the \char`\"{}header\char`\"{}, the data for fixed size variables, and the data for variables which have an unlimited dimension (record variables).

The header begins at the beginning of the file. The index (offset) of the beginning of the other twos is contained in the header. Typically, there is no space between thes. This causes copying overhead to accrue if one wishes to change the size of thes, as may happen when changing names of things, text attribute values, adding attributes or adding variables. Also, for buffered i/o, there may be advantages to alignings in certain ways.

The minfree parameters allow one to control costs of future calls to nf\+\_\+redef, nf\+\_\+enddef by requesting that minfree bytes be available at the end of the.

The align parameters allow one to set the alignment of the beginning of the correspondings. The beginning of the is rounded up to an index which is a multiple of the align parameter. The flag value A\+L\+I\+G\+N\+\_\+\+C\+H\+U\+NK tells the library to use the bufrsize (see above) as the align parameter.

The file format requires mod 4 alignment, so the align parameters are silently rounded up to multiples of 4. The al call,

 

nf\+\_\+enddef(ncid);

is equivalent to

nf\+\_\+enddef(ncid, 0, 4, 0, 4);

The file format does not contain a \char`\"{}record size\char`\"{} value, this is calculated from the sizes of the record variables. This unfortunate fact prevents us from providing minfree and alignment control of the \char`\"{}records\char`\"{} in a netcdf file. If you add a variable which has an unlimited dimension, the third will always be copied with the new variable added.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+E\+N\+D\+D\+EF(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER H\+\_\+\+M\+I\+N\+F\+R\+EE, I\+N\+T\+E\+G\+ER V\+\_\+\+A\+L\+I\+GN, I\+N\+T\+E\+G\+ER V\+\_\+\+M\+I\+N\+F\+R\+EE, I\+N\+T\+E\+G\+ER R\+\_\+\+A\+L\+I\+GN)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily H\+\_\+\+M\+I\+N\+F\+R\+EE} \+: Sets the pad at the end of the \char`\"{}header\char`\"{}.

{\ttfamily V\+\_\+\+A\+L\+I\+GN} \+: Controls the alignment of the beginning of the data for fixed size variables.

{\ttfamily V\+\_\+\+M\+I\+N\+F\+R\+EE} \+: Sets the pad at the end of the data for fixed size variables.

{\ttfamily R\+\_\+\+A\+L\+I\+GN} \+: Controls the alignment of the beginning of the data for variables which have an unlimited dimension (record variables).

\subsection*{Errors }

N\+F\+\_\+\+\_\+\+E\+N\+D\+D\+EF returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset is not in define mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The size of one or more variables exceed the size constraints for whichever variant of the file format is in use). See \href{netcdf.html#Large-File-Support}{\tt (netcdf)Large File Support} ‘\+Large File Support’ in The Net\+C\+DF Users Guide.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+\_\+\+E\+N\+D\+D\+EF to finish the definitions of a new net\+C\+DF dataset named foo.\+nc and put it into data mode\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
INTEGER NCID, STATUS, H\_MINFREE, V\_ALIGN, V\_MINFREE, R\_ALIGN
   ...
STATUS = NF\_CREATE('foo.nc', NF\_NOCLOBBER, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)

   ...   ! create dimensions, variables, attributes

H\_MINFREE = 512
V\_ALIGN = 512
V\_MINFREE = 512
R\_ALIGN = 512
STATUS = NF\_ENDDEF(NCID, H\_MINFREE, V\_ALIGN, V\_MINFREE, R\_ALIGN)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF-CLOSE}{}\subsection{2.\+14 N\+F\+\_\+\+C\+L\+O\+S\+E }\label{nc_f77_interface_guide_f77_NF-CLOSE}
The function N\+F\+\_\+\+C\+L\+O\+SE closes an open net\+C\+DF dataset. If the dataset is in define mode, N\+F\+\_\+\+E\+N\+D\+D\+EF will be called before closing. (In this case, if N\+F\+\_\+\+E\+N\+D\+D\+EF returns an error, N\+F\+\_\+\+A\+B\+O\+RT will automatically be called to restore the dataset to the consistent state before define mode was last entered.) After an open net\+C\+DF dataset is closed, its net\+C\+DF ID may be reassigned to the next net\+C\+DF dataset that is opened or created.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+C\+L\+O\+S\+E(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors }

N\+F\+\_\+\+C\+L\+O\+SE returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Define mode was entered and the automatic call made to N\+F\+\_\+\+E\+N\+D\+D\+EF failed.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+C\+L\+O\+SE to finish the definitions of a new net\+C\+DF dataset named foo.\+nc and release its net\+C\+DF ID\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER N\+C\+ID, S\+T\+A\+T\+US ... S\+T\+A\+T\+US = N\+F\+\_\+\+C\+R\+E\+A\+TE(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

... ! create dimensions, variables, attributes

S\+T\+A\+T\+US = N\+F\+\_\+\+C\+L\+O\+S\+E(\+N\+C\+I\+D) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-Family}{}\subsection{2.\+15 N\+F\+\_\+\+I\+N\+Q Family }\label{nc_f77_interface_guide_f77_NF-INQ-Family}
Members of the N\+F\+\_\+\+I\+NQ family of functions return information about an open net\+C\+DF dataset, given its net\+C\+DF ID. Dataset inquire functions may be called from either define mode or data mode. The first function, N\+F\+\_\+\+I\+NQ, returns values for the number of dimensions, the number of variables, the number of global attributes, and the dimension ID of the dimension defined with unlimited length, if any. The other functions in the family each return just one of these items of information.

For F\+O\+R\+T\+R\+AN, these functions include N\+F\+\_\+\+I\+NQ, N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+D\+I\+MS, N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+V\+A\+RS, N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+A\+T\+TS, and N\+F\+\_\+\+I\+N\+Q\+\_\+\+U\+N\+L\+I\+M\+D\+IM. An additional function, N\+F\+\_\+\+I\+N\+Q\+\_\+\+F\+O\+R\+M\+AT, returns the (rarely needed) format version.

No I/O is performed when these functions are called, since the required information is available in memory for each open net\+C\+DF dataset.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+NQ (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER ndims, I\+N\+T\+E\+G\+ER nvars,I\+N\+T\+E\+G\+ER ngatts, I\+N\+T\+E\+G\+ER unlimdimid) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+D\+I\+MS (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER ndims) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+V\+A\+RS (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER nvars) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+A\+T\+TS (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER ngatts) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+U\+N\+L\+I\+M\+D\+IM (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER unlimdimid) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+F\+O\+R\+M\+AT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER format)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily ndims} \+: Returned number of dimensions defined for this net\+C\+DF dataset.

{\ttfamily nvars} \+: Returned number of variables defined for this net\+C\+DF dataset.

{\ttfamily ngatts} \+: Returned number of global attributes defined for this net\+C\+DF dataset.

{\ttfamily unlimdimid} \+: Returned ID of the unlimited dimension, if there is one for this net\+C\+DF dataset. If no unlimited length dimension has been defined, -\/1 is returned.

{\ttfamily format} \+: Returned format version, one of N\+F\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+C\+L\+A\+S\+S\+IC, N\+F\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+64\+B\+IT, N\+F\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+N\+E\+T\+C\+D\+F4, N\+F\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+N\+E\+T\+C\+D\+F4\+\_\+\+C\+L\+A\+S\+S\+IC.

\subsection*{Errors }

All members of the N\+F\+\_\+\+I\+NQ family return the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+I\+NQ to find out about a net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
INTEGER STATUS, NCID, NDIMS, NVARS, NGATTS, UNLIMDIMID
   ...
STATUS = NF\_OPEN('foo.nc', NF\_NOWRITE, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
   ...
STATUS = NF\_INQ(NCID, NDIMS, NVARS, NGATTS, UNLIMDIMID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF-SYNC}{}\subsection{2.\+16 N\+F\+\_\+\+S\+Y\+N\+C }\label{nc_f77_interface_guide_f77_NF-SYNC}
The function N\+F\+\_\+\+S\+Y\+NC offers a way to synchronize the disk copy of a net\+C\+DF dataset with in-\/memory buffers. There are two reasons you might want to synchronize after writes\+:


\begin{DoxyItemize}
\item To minimize data loss in case of abnormal termination, or
\item To make data available to other processes for reading immediately after it is written. But note that a process that already had the dataset open for reading would not see the number of records increase when the writing process calls N\+F\+\_\+\+S\+Y\+NC; to accomplish this, the reading process must call N\+F\+\_\+\+S\+Y\+NC.
\end{DoxyItemize}

This function is backward-\/compatible with previous versions of the net\+C\+DF library. The intent was to allow sharing of a net\+C\+DF dataset among multiple readers and one writer, by having the writer call N\+F\+\_\+\+S\+Y\+NC after writing and the readers call N\+F\+\_\+\+S\+Y\+NC before each read. For a writer, this flushes buffers to disk. For a reader, it makesre that the next read will be from disk rather than from previously cached buffers, so that the reader will see changes made by the writing process (e.\+g., the number of records written) without having to close and reopen the dataset. If you are only accessing a small amount of data, it can be expensive in computer resources to always synchronize to disk after every write, since you are giving up the benefits of buffering.

An easier way to accomplish sharing (and what is now recommended) is to have the writer and readers open the dataset with the N\+F\+\_\+\+S\+H\+A\+RE flag, and then it will not be necessary to call N\+F\+\_\+\+S\+Y\+NC at all. However, the N\+F\+\_\+\+S\+Y\+NC function still provides finer granularity than the N\+F\+\_\+\+S\+H\+A\+RE flag, if only a few net\+C\+DF accesses need to be synchronized among processes.

It is important to note that changes to the ancillary data,ch as attribute values, are not propagated automatically by use of the N\+F\+\_\+\+S\+H\+A\+RE flag. Use of the N\+F\+\_\+\+S\+Y\+NC function is still required for this purpose.

Sharing datasets when the writer enters define mode to change the data schema requires extra care. In previous releases, after the writer left define mode, the readers were left looking at an old copy of the dataset, since the changes were made to a new copy. The only way readers could see the changes was by closing and reopening the dataset. Now the changes are made in place, but readers have no knowledge that their internal tables are now inconsistent with the new dataset schema. If net\+C\+DF datasets are shared across redefinition, some mechanism external to the net\+C\+DF library must be provided that prevents access by readers during redefinition and causes the readers to call N\+F\+\_\+\+S\+Y\+NC before any subsequent access.

When calling N\+F\+\_\+\+S\+Y\+NC, the net\+C\+DF dataset must be in data mode. A net\+C\+DF dataset in define mode is synchronized to disk only when N\+F\+\_\+\+E\+N\+D\+D\+EF is called. A process that is reading a net\+C\+DF dataset that another process is writing may call N\+F\+\_\+\+S\+Y\+NC to get updated with the changes made to the data by the writing process (e.\+g., the number of records written), without having to close and reopen the dataset.

Data is automatically synchronized to disk when a net\+C\+DF dataset is closed, or whenever you leave define mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+S\+Y\+N\+C(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors }

N\+F\+\_\+\+S\+Y\+NC returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The net\+C\+DF dataset is in define mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+S\+Y\+NC to synchronize the disk writes of a net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! write data or change attributes ... S\+T\+A\+T\+US = N\+F\+\_\+\+S\+Y\+N\+C(\+N\+C\+I\+D) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_NF-ABORT}{}\subsection{2.\+17 N\+F\+\_\+\+A\+B\+O\+R\+T }\label{nc_f77_interface_guide_f77_NF-ABORT}
You no longer need to call this function, since it is called automatically by N\+F\+\_\+\+C\+L\+O\+SE in case the dataset is in define mode and something goes wrong with committing the changes. The function N\+F\+\_\+\+A\+B\+O\+RT just closes the net\+C\+DF dataset, if not in define mode. If the dataset is being created and is still in define mode, the dataset is deleted. If define mode was entered by a call to N\+F\+\_\+\+R\+E\+D\+EF, the net\+C\+DF dataset is restored to its state before definition mode was entered and the dataset is closed.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+A\+B\+O\+R\+T(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors }

N\+F\+\_\+\+A\+B\+O\+RT returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item When called from define mode while creating a net\+C\+DF dataset, deletion of the dataset failed.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+A\+B\+O\+RT to back out of redefinitions of a dataset named foo.\+nc\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
INTEGER STATUS, NCID, LATID
   ...
STATUS = NF\_OPEN('foo.nc', NF\_WRITE, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
   ...
STATUS = NF\_REDEF(NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
   ...
STATUS = NF\_DEF\_DIM(NCID, 'LAT', 18, LATID)
IF (STATUS .NE. NF\_NOERR) THEN  ! dimension definition failed
   CALL HANDLE\_ERR(STATUS)
   STATUS = NF\_ABORT(NCID)  ! abort redefinitions
   IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
ENDIF
...
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF-SET-FILL}{}\subsection{2.\+18 N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+L\+L }\label{nc_f77_interface_guide_f77_NF-SET-FILL}
This function is intended for advanced usage, to optimize writes under some circumstances described below. The function N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL sets the fill mode for a net\+C\+DF dataset open for writing and returns the current fill mode in a return parameter. The fill mode can be specified as either N\+F\+\_\+\+F\+I\+LL or N\+F\+\_\+\+N\+O\+F\+I\+LL. The default behavior corresponding to N\+F\+\_\+\+F\+I\+LL is that data is pre-\/filled with fill values, that is fill values are written when you create non-\/record variables or when you write a value beyond data that has not yet been written. This makes it possible to detect attempts to read data before it was written. See section \href{#Fill-Values}{\tt Fill Values}, for more information on the use of fill values. See \href{netcdf.html#Attribute-Conventions}{\tt (netcdf)Attribute Conventions} ‘\+Attribute Conventions’ in The Net\+C\+DF Users Guide, for information about how to define your own fill values.

The behavior corresponding to N\+F\+\_\+\+N\+O\+F\+I\+LL overrides the default behavior of prefilling data with fill values. This can be used to enhance performance, because it avoids the duplicate writes that occur when the net\+C\+DF library writes fill values that are later overwritten with data.

A value indicating which mode the net\+C\+DF dataset was already in is returned. You can use this value to temporarily change the fill mode of an open net\+C\+DF dataset and then restore it to the previous mode.

After you turn on N\+F\+\_\+\+N\+O\+F\+I\+LL mode for an open net\+C\+DF dataset, you must be certain to write valid data in all the positions that will later be read. Note that nofill mode is only a transient property of a net\+C\+DF dataset open for writing\+: if you close and reopen the dataset, it will revert to the default behavior. You can also revert to the default behavior by calling N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL again to explicitly set the fill mode to N\+F\+\_\+\+F\+I\+LL.

There are three situations where it is advantageous to set nofill mode\+:


\begin{DoxyEnumerate}
\item Creating and initializing a net\+C\+DF dataset. In this case, you should set nofill mode before calling N\+F\+\_\+\+E\+N\+D\+D\+EF and then write completely all non-\/record variables and the initial records of all the record variables you want to initialize.
\item Extending an existing record-\/oriented net\+C\+DF dataset. Set nofill mode after opening the dataset for writing, then append the additional records to the dataset completely, leaving no intervening unwritten records.
\item Adding new variables that you are going to initialize to an existing net\+C\+DF dataset. Set nofill mode before calling N\+F\+\_\+\+E\+N\+D\+D\+EF then write all the new variables completely.
\end{DoxyEnumerate}

If the net\+C\+DF dataset has an unlimited dimension and the last record was written while in nofill mode, then the dataset may be shorter than if nofill mode was not set, but this will be completely transparent if you access the data only through the net\+C\+DF interfaces.

The use of this feature may not be available (or even needed) in future releases. Programmers are cautioned against heavy reliance upon this feature.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER F\+I\+L\+L\+M\+O\+DE, I\+N\+T\+E\+G\+ER old\+\_\+mode)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily F\+I\+L\+L\+M\+O\+DE} \+: Desired fill mode for the dataset, either N\+F\+\_\+\+N\+O\+F\+I\+LL or N\+F\+\_\+\+F\+I\+LL.

{\ttfamily old\+\_\+mode} \+: Returned current fill mode of the dataset before this call, either N\+F\+\_\+\+N\+O\+F\+I\+LL or N\+F\+\_\+\+F\+I\+LL.

\subsection*{Errors }

N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The specified net\+C\+DF ID refers to a dataset open for read-\/only access.
\item The fill mode argument is neither N\+F\+\_\+\+N\+O\+F\+I\+LL nor N\+F\+\_\+\+F\+I\+LL..
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL to set nofill mode forbsequent writes of a net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
INCLUDE 'netcdf.inc'
   ...
INTEGER NCID, STATUS, OMODE
   ...
STATUS = NF\_OPEN('foo.nc', NF\_WRITE, NCID)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
   ...
! write data with default prefilling behavior
   ...
STATUS = NF\_SET\_FILL(NCID, NF\_NOFILL, OMODE)
IF (STATUS .NE. NF\_NOERR) CALL HANDLE\_ERR(STATUS)
   ...
! write data with no prefilling
   ...
\end{DoxyCode}
\hypertarget{nc_f77_interface_guide_f77_NF-SET-DEFAULT-FORMAT}{}\subsection{2.\+19 N\+F\+\_\+\+S\+E\+T\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+F\+O\+R\+M\+A\+T }\label{nc_f77_interface_guide_f77_NF-SET-DEFAULT-FORMAT}
This function is intended for advanced users.

In version 3.\+6, net\+C\+DF introduced a new data format, the first change in the underlying binary data format since the net\+C\+DF interface was released. The new format, 64-\/bit offset format, was introduced to greatly relax the limitations on creating very large files.

In version 4.\+0, another new binary format was introduced\+: net\+C\+D\+F-\/4/\+H\+D\+F5.

Users are warned that creating files in the 64-\/bit offset format makes them unreadable by the net\+C\+DF library prior to version 3.\+6.\+0, and creating files in netcdf-\/4/\+H\+D\+F5 format makes them unreadable by the net\+C\+DF library prior to version 4.\+0. For reasons of compatibility, users should continue to create files in net\+C\+DF classic format.

Users who do want to use 64-\/bit offset or net\+C\+D\+F-\/4/\+H\+D\+F5 format files can create them directory from N\+F\+\_\+\+C\+R\+E\+A\+TE, using the proper cmode flag. (see section \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}).

The function N\+F\+\_\+\+S\+E\+T\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+F\+O\+R\+M\+AT allows the user to change the format of the net\+C\+DF file to be created by future calls to N\+F\+\_\+\+C\+R\+E\+A\+TE without changing the cmode flag.

This allows the user to convert a program to use the new formats without changing all calls the N\+F\+\_\+\+C\+R\+E\+A\+TE.

Once the default format is set, all future created files will be in the desired format.

Constants are provided in the netcdf.\+inc file to be used with this function\+: nf\+\_\+format\+\_\+classic, nf\+\_\+format\+\_\+64bit, nf\+\_\+format\+\_\+netcdf4 and nf\+\_\+format\+\_\+netcdf4\+\_\+classic.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+S\+E\+T\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+F\+O\+R\+M\+A\+T(\+I\+N\+T\+E\+G\+E\+R F\+O\+R\+M\+A\+T, I\+N\+T\+E\+G\+E\+R O\+L\+D\+\_\+\+F\+O\+R\+M\+T)

{\ttfamily F\+O\+R\+M\+AT} \+: Either nf\+\_\+format\+\_\+classic, nf\+\_\+format\+\_\+64bit, nf\+\_\+format\+\_\+netcdf4 or nf\+\_\+format\+\_\+netcdf4\+\_\+classic.

{\ttfamily O\+L\+D\+\_\+\+F\+O\+R\+M\+AT} \+: The default format at the time the function is called is returned here.

\subsection*{Errors }

The following error codes may be returned by this function\+:


\begin{DoxyItemize}
\item An N\+F\+\_\+\+E\+I\+N\+V\+AL error is returned if an invalid default format is specified.
\end{DoxyItemize}

\subsection*{Example }

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, O\+L\+D\+\_\+\+F\+O\+R\+M\+AT ... S\+T\+A\+T\+US = N\+F\+\_\+\+S\+E\+T\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+F\+O\+R\+M\+A\+T(nf\+\_\+format\+\_\+64bit, O\+L\+D\+\_\+\+F\+O\+R\+M\+A\+T) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ...\hypertarget{nc_f77_interface_guide_f77_Set-HDF5-Chunk}{}\subsection{2.\+20 Set H\+D\+F5 Chunk Cache for Future File Opens/\+Creates\+: N\+F\+\_\+\+S\+E\+T\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+H\+E }\label{nc_f77_interface_guide_f77_Set-HDF5-Chunk}
This function changes the chunk cache settings in the H\+D\+F5 library. The settings apply forbsequent file opens/creates. This function does not change the chunk cache settings of already open files.

This affects the per-\/file chunk cache which the H\+D\+F5 layer maintains. The chunk cache size can be tuned for better performance.

For more information, see the documentation for the H5\+Pset\+\_\+cache() function in the H\+D\+F5 library at the H\+D\+F5 website\+: \href{http://hdfgroup.org/HDF5/}{\tt http\+://hdfgroup.\+org/\+H\+D\+F5/}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER N\+F\+\_\+\+S\+E\+T\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+H\+E(\+I\+N\+T\+E\+G\+E\+R S\+I\+Z\+E, I\+N\+T\+E\+G\+E\+R N\+E\+L\+E\+M\+S, I\+N\+T\+E\+G\+E\+R P\+R\+E\+E\+M\+P\+T\+I\+O\+N);

{\ttfamily S\+I\+ZE} \+: The total size of the raw data chunk cache in Mega\+Bytes.

{\ttfamily N\+E\+L\+E\+MS} \+: The number slots in the per-\/variable chunk cache (should be a prime number larger than the number of chunks in the cache).

{\ttfamily P\+R\+E\+E\+M\+P\+T\+I\+ON} \+: The preemtion value must be between 0 and 100 inclusive and indicates how much chunks that have been fully read are favored for preemption. A value of zero means fully read chunks are treated no differently than other chunks (the preemption is strictly L\+RU) while a value of 100 means fully read chunks are always preempted before other chunks.

\subsection*{Return Codes }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: Parameters size and nelems must be non-\/zero positive integers, and preemption must be between zero and 100 (inclusive). An N\+F\+\_\+\+E\+I\+N\+V\+AL will be returned otherwise.\hypertarget{nc_f77_interface_guide_f77_NF-GET-CHUNK-CACHE}{}\subsection{2.\+21 Get the H\+D\+F5 Chunk Cache Settings for Future File Opens/\+Creates\+: N\+F\+\_\+\+G\+E\+T\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+H\+E }\label{nc_f77_interface_guide_f77_NF-GET-CHUNK-CACHE}
This function gets the chunk cache settings for the H\+D\+F5 library. The settings apply forbsequent file opens/creates.

This affects the per-\/file chunk cache which the H\+D\+F5 layer maintains. The chunk cache size can be tuned for better performance.

For more information, see the documentation for the H5\+Pget\+\_\+cache() function in the H\+D\+F5 library at the H\+D\+F5 website\+: \href{http://hdfgroup.org/HDF5/}{\tt http\+://hdfgroup.\+org/\+H\+D\+F5/}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER N\+C\+\_\+\+G\+E\+T\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+H\+E(\+I\+N\+T\+E\+G\+E\+R S\+I\+Z\+E, I\+N\+T\+E\+G\+E\+R N\+E\+L\+E\+M\+S, I\+N\+T\+E\+G\+E\+R P\+R\+E\+E\+M\+P\+T\+I\+O\+N);

{\ttfamily S\+I\+ZE} \+: The total size of the raw data chunk cache will be put here.

{\ttfamily N\+E\+L\+E\+MS} \+: The number of chunk slots in the raw data chunk cache hash table will be put here.

{\ttfamily P\+R\+E\+E\+M\+P\+T\+I\+ON} \+: The preemption will be put here. The preemtion value is between 0 and 100 inclusive and indicates how much chunks that have been fully read are favored for preemption. A value of zero means fully read chunks are treated no differently than other chunks (the preemption is strictly L\+RU) while a value of 100 means fully read chunks are always preempted before other chunks.

\subsection*{Return Codes }

{\ttfamily N\+C\+\_\+\+N\+O\+E\+RR} \+: No error.\hypertarget{nc_f77_interface_guide_f77_Groups}{}\section{3. Groups }\label{nc_f77_interface_guide_f77_Groups}
Net\+C\+D\+F-\/4 addedpport for hierarchical groups within net\+C\+DF datasets.

Groups are identified with a ncid, which identifies both the open file, and the group within that file. When a file is opened with N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE, the ncid for the root group of that file is provided. Using that as a starting point, users can add new groups, or list and navigate existing groups.

All net\+C\+DF calls take a ncid which determines where the call will take its action. For example, the N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR function takes a ncid as its first parameter. It will create a variable in whichever group its ncid refers to. Use the root ncid provided by N\+F\+\_\+\+C\+R\+E\+A\+TE or N\+F\+\_\+\+O\+P\+EN to create a variable in the root group. Or use N\+F\+\_\+\+D\+E\+F\+\_\+\+G\+RP to create a group and use its ncid to define a variable in the new group.

Variable are only visible in the group in which they are defined. The same applies to attributes. “\+Global” attributes are defined in whichever group is refered to by the ncid.

Dimensions are visible in their groups, and all child groups.

Group operations are only permitted on net\+C\+D\+F-\/4 files -\/ that is, files created with the H\+D\+F5 flag in nf\+\_\+create. (see \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}). Groups are not compatible with the net\+C\+DF classic data model, so files created with the N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL file cannot contain groups (except the root group).\hypertarget{nc_f77_interface_guide_f77_NF-INQ-NCID}{}\subsection{3.\+1 Find a Group I\+D\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+C\+I\+D }\label{nc_f77_interface_guide_f77_NF-INQ-NCID}
Given an ncid and group name (N\+U\+LL or \char`\"{}\char`\"{} gets root group), return ncid of the named group.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+N\+C\+I\+D(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+M\+E, I\+N\+T\+E\+G\+E\+R G\+R\+P\+I\+D)

{\ttfamily N\+C\+ID} \+: The group id for this operation.

{\ttfamily N\+A\+ME} \+: A character array that holds the name of the desired group. Must be less then N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily G\+R\+P\+ID} \+: The ID of the group will go here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check getting the group by name retval = nf\+\_\+inq\+\_\+ncid(ncid, group\+\_\+name, grpid\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRPS}{}\subsection{3.\+2 Get a List of Groups in a Group\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+S }\label{nc_f77_interface_guide_f77_NF-INQ-GRPS}
Given a location id, return the number of groups it contains, and an array of their ncids.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+S(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R N\+U\+M\+G\+R\+P\+S, I\+N\+T\+E\+G\+E\+R N\+C\+I\+D\+S)

{\ttfamily N\+C\+ID} \+: The group id for this operation.

{\ttfamily N\+U\+M\+G\+R\+PS} \+: An integer which will get number of groups in this group.

{\ttfamily N\+C\+I\+DS} \+: An array of ints which will receive the I\+Ds of all the groups in this group.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C What groups are there from the root group? retval = nf\+\_\+inq\+\_\+grps(ncid, ngroups\+\_\+in, grpids) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-VARIDS}{}\subsection{3.\+3 Find all the Variables in a Group\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+I\+D\+S }\label{nc_f77_interface_guide_f77_NF-INQ-VARIDS}
Find all varids for a location.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+I\+D\+S(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R\+S V\+A\+R\+I\+D\+S)

{\ttfamily N\+C\+ID} \+: The group id for this operation.

{\ttfamily V\+A\+R\+I\+DS} \+: An already allocated array to store the list of varids. Use nf\+\_\+inq\+\_\+nvars to find out how many variables there are. (see \href{#NF_005fINQ-Family}{\tt N\+F\+\_\+\+I\+NQ Family}).

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check varids inbgroup. retval = nf\+\_\+inq\+\_\+varidsbgrp\+\_\+in, nvars, varids\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-DIMIDS}{}\subsection{3.\+4 Find all Dimensions Visible in a Group\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+I\+D\+S }\label{nc_f77_interface_guide_f77_NF-INQ-DIMIDS}
Find all dimids for a location. This finds all dimensions in a group, or any of its parents.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+I\+D\+S(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R N\+D\+I\+M\+S, I\+N\+T\+E\+G\+E\+R D\+I\+M\+I\+D\+S, I\+N\+T\+E\+G\+E\+R I\+N\+C\+L\+U\+D\+E\+\_\+\+P\+A\+R\+E\+N\+T\+S)

{\ttfamily N\+C\+ID} \+: The group id for this operation.

{\ttfamily N\+D\+I\+MS} \+: Returned number of dimensions for this location. If I\+N\+C\+L\+U\+D\+E\+\_\+\+P\+A\+R\+E\+N\+TS is non-\/zero, number of dimensions visible from this group, which includes dimensions in parent groups.

{\ttfamily D\+I\+M\+I\+DS} \+: An array of ints when the dimids of the visible dimensions will be stashed. Use nf\+\_\+inq\+\_\+ndims to find out how many dims are visible from this group. (see \href{#NF_005fINQ-Family}{\tt N\+F\+\_\+\+I\+NQ Family}).

{\ttfamily I\+N\+C\+L\+U\+D\+E\+\_\+\+P\+A\+R\+E\+N\+TS} \+: If zero, only the group specified by N\+C\+ID will be searched for dimensions. Otherwise parent groups will be searched too.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check dimids inbgroup. retval = nf\+\_\+inq\+\_\+dimidsbgrp\+\_\+in, ndims, dimids\+\_\+in, 0) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (ndims .ne. 2 .or. dimids\+\_\+in(1) .ne. dimids(1) .or. \& dimids\+\_\+in(2) .ne. dimids(2)) stop 2\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRPNAME-LE}{}\subsection{3.\+5 Find the Length of a Group’s Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+L\+E }\label{nc_f77_interface_guide_f77_NF-INQ-GRPNAME-LE}
Given ncid, find length of the full name. (Root group is named \char`\"{}/\char`\"{}, with length 1.)

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+L\+E\+N(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R L\+E\+N)

{\ttfamily N\+C\+ID} \+: The group id for this operation.

{\ttfamily L\+EN} \+: An integer where the length will be placed.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check the length of the full name. retval = nf\+\_\+inq\+\_\+grpname\+\_\+len(grpids(1), full\+\_\+name\+\_\+len) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRPNAME}{}\subsection{3.\+6 Find a Group’s Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E }\label{nc_f77_interface_guide_f77_NF-INQ-GRPNAME}
Given ncid, find relative name of group. (Root group is named \char`\"{}/\char`\"{}).

The name provided by this function is relative to the parent group. For a full path name for the group is, with all parent groups included, separated with a forward slash (as in Unix directory names) See \href{#NF_005fINQ_005fGRPNAME_005fFULL}{\tt Find a Group’s Full Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+F\+U\+LL}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+M\+E)

{\ttfamily N\+C\+ID}

The group id for this operation.

{\ttfamily N\+A\+ME}

The name of the group will be copied to this character array. The name will be less than N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME in length.

``

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check the name of the root group. retval = nf\+\_\+inq\+\_\+grpname(ncid, name\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (name\+\_\+in(1\+:1) .ne. \textquotesingle{}/\textquotesingle{}) stop 2\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRPNAME-FULL}{}\subsection{3.\+7 Find a Group’s Full Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+F\+U\+L\+L }\label{nc_f77_interface_guide_f77_NF-INQ-GRPNAME-FULL}
Given ncid, find complete name of group. (Root group is named \char`\"{}/\char`\"{}).

The name provided by this function is a full path name for the group is, with all parent groups included, separated with a forward slash (as in Unix directory names). For a name relative to the parent group See section \href{#NF_005fINQ_005fGRPNAME}{\tt Find a Group’s Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+ME}.

To find the length of the full name See \href{#NF_005fINQ_005fGRPNAME_005fLEN}{\tt Find the Length of a Group’s Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+L\+EN}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+F\+U\+L\+L(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R L\+E\+N, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+M\+E)

{\ttfamily N\+C\+ID} \+: The group id for this operation.

{\ttfamily L\+EN} \+: The length of the full group name will go here.

{\ttfamily N\+A\+ME} \+: The name of the group will be copied to this character array.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check the full name. retval = nf\+\_\+inq\+\_\+grpname\+\_\+full(grpids(1), full\+\_\+name\+\_\+len, name\+\_\+in2) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRP-PARENT}{}\subsection{3.\+8 Find a Group’s Parent\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+P\+A\+R\+E\+N\+T }\label{nc_f77_interface_guide_f77_NF-INQ-GRP-PARENT}
Given ncid, find the ncid of the parent group.

When used with the root group, this function returns the N\+F\+\_\+\+E\+N\+O\+G\+RP error (since the root group has no parent.)

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+P\+A\+R\+E\+N\+T(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R P\+A\+R\+E\+N\+T\+\_\+\+N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: The group id.

{\ttfamily P\+A\+R\+E\+N\+T\+\_\+\+N\+C\+ID} \+: The ncid of the parent group will be copied here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+G\+RP} \+: No parent group found (i.\+e. this is the root group).

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check the parent ncid. retval = nf\+\_\+inq\+\_\+grp\+\_\+parent(grpids(1), grpid\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRP-NCID}{}\subsection{3.\+9 Find a Group by Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+N\+C\+I\+D }\label{nc_f77_interface_guide_f77_NF-INQ-GRP-NCID}
Given a group name an an ncid, find the ncid of the group id.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+N\+C\+I\+D(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, C\+H\+A\+R\+A\+C\+T\+E\+R G\+R\+P\+\_\+\+N\+A\+M\+E, I\+N\+T\+E\+G\+E\+R G\+R\+P\+\_\+\+N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: The group id to look in.

{\ttfamily G\+R\+P\+\_\+\+N\+A\+ME} \+: The name of the group that should be found.

{\ttfamily G\+R\+P\+\_\+\+N\+C\+ID} \+: This will get the group id, if it is found.

\subsection*{Return Codes }

The following return codes may be returned by this function.

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: No name provided or name longer than N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+G\+RP} \+: Named group not found.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+types3.\+F.

 

C Go to a child group and find the id of our type. retval = nf\+\_\+inq\+\_\+grp\+\_\+ncid(ncid, group\+\_\+name,b\+\_\+grpid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-GRP-FULL-NCID}{}\subsection{3.\+10 Find a Group by its Fully-\/qualified Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+F\+U\+L\+L\+\_\+\+N\+C\+I\+D }\label{nc_f77_interface_guide_f77_NF-INQ-GRP-FULL-NCID}
Given a fully qualified group name an an ncid, find the ncid of the group id.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+F\+U\+L\+L\+\_\+\+N\+C\+I\+D(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, C\+H\+A\+R\+A\+C\+T\+E\+R F\+U\+L\+L\+\_\+\+N\+A\+M\+E, I\+N\+T\+E\+G\+E\+R G\+R\+P\+\_\+\+N\+C\+I\+D)

{\ttfamily N\+C\+ID} \+: The group id to look in.

{\ttfamily F\+U\+L\+L\+\_\+\+N\+A\+ME} \+: The fully-\/qualified group name.

{\ttfamily G\+R\+P\+\_\+\+N\+C\+ID} \+: This will get the group id, if it is found.

\subsection*{Return Codes }

The following return codes may be returned by this function.

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: No name provided or name longer than N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+G\+RP} \+: Named group not found.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+groups.\+F.

 

C Check the full name of the root group (also \char`\"{}/\char`\"{}). retval = nf\+\_\+inq\+\_\+grpname\+\_\+full(ncid, full\+\_\+name\+\_\+len, name\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-DEF-GRP}{}\subsection{3.\+11 Create a New Group\+: N\+F\+\_\+\+D\+E\+F\+\_\+\+G\+R\+P }\label{nc_f77_interface_guide_f77_NF-DEF-GRP}
Create a group. Its location id is returned in new\+\_\+ncid.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+G\+RP(I\+N\+T\+E\+G\+ER P\+A\+R\+E\+N\+T\+\_\+\+N\+C\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER N\+E\+W\+\_\+\+N\+C\+ID)

{\ttfamily P\+A\+R\+E\+N\+T\+\_\+\+N\+C\+ID} \+: The group id of the parent group.

{\ttfamily N\+A\+ME} \+: The name of the new group, which must be different from the name of any variable within the same parent group.

{\ttfamily N\+E\+W\+\_\+\+N\+C\+ID} \+: The ncid of the new group will be placed there.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: That name is in use. Group names must be unique within a group.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: Name exceed max length N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to write to a read-\/only file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode.

\subsection*{Example }

In this exampe rom nf\+\_\+test/ftst\+\_\+groups.\+F, a groups is reated, and then ab-\/group is created in that group.

 

C Create the net\+C\+DF file. retval = nf\+\_\+create(file\+\_\+name, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, ncid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Create a group and abgroup. retval = nf\+\_\+def\+\_\+grp(ncid, group\+\_\+name, grpid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+def\+\_\+grp(grpid,b\+\_\+group\+\_\+name,b\+\_\+grpid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_Dimensions}{}\section{4. Dimensions }\label{nc_f77_interface_guide_f77_Dimensions}
\hypertarget{nc_f77_interface_guide_f77_Dimensions-Introduction}{}\subsection{4.\+1 Dimensions Introduction }\label{nc_f77_interface_guide_f77_Dimensions-Introduction}
Dimensions for a net\+C\+DF dataset are defined when it is created, while the net\+C\+DF dataset is in define mode. Additional dimensions may be added later by reentering define mode. A net\+C\+DF dimension has a name and a length. At most one dimension in a net\+C\+DF dataset can have the unlimited length, which means variables using this dimension can grow along this dimension.

There is aggested limit (100) to the number of dimensions that can be defined in a single net\+C\+DF dataset. The limit is the value of the predefined macro N\+F\+\_\+\+M\+A\+X\+\_\+\+D\+I\+MS. The purpose of the limit is to make writing generic applications simpler. They need only provide an array of N\+F\+\_\+\+M\+A\+X\+\_\+\+D\+I\+MS dimensions to handle any net\+C\+DF dataset. The implementation of the net\+C\+DF library does not enforce this advisory maximum, so it is possible to use more dimensions, if necessary, but net\+C\+DF utilities that ame the advisory maximums may not be able to handle the rlting net\+C\+DF datasets.

Ordinarily, the name and length of a dimension are fixed when the dimension is first defined. The name may be changed later, but the length of a dimension (other than the unlimited dimension) cannot be changed without copying all the data to a new net\+C\+DF dataset with a redefined dimension length.

A net\+C\+DF dimension in an open net\+C\+DF dataset is referred to by a small integer called a dimension ID. In the F\+O\+R\+T\+R\+AN interface, dimension I\+Ds are 1, 2, 3, ..., in the order in which the dimensions were defined.

Operationspported on dimensions are\+:


\begin{DoxyItemize}
\item Create a dimension, given its name and length.
\item Get a dimension ID from its name.
\item Get a dimension’s name and length from its ID.
\item Rename a dimension.
\end{DoxyItemize}\hypertarget{nc_f77_interface_guide_f77_NF-DEF-DIM}{}\subsection{4.\+2 N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+I\+M }\label{nc_f77_interface_guide_f77_NF-DEF-DIM}
The function N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM adds a new dimension to an open net\+C\+DF dataset in define mode. It returns (as an argument) a dimension ID, given the net\+C\+DF ID, the dimension name, and the dimension length. At most one unlimited length dimension, called the record dimension, may be defined for each net\+C\+DF dataset.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM (I\+N\+T\+E\+G\+ER N\+C\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER L\+EN, I\+N\+T\+E\+G\+ER dimid)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily N\+A\+ME} \+: Dimension name.

{\ttfamily L\+EN} \+: Length of dimension; that is, number of values for this dimension as an index to variables that use it. This should be either a positive integer or the predefined constant N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED.

{\ttfamily dimid} \+: Returned dimension ID.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The net\+C\+DF dataset is not in definition mode.
\item The specified dimension name is the name of another existing dimension.
\item The specified length is not greater than zero.
\item The specified length is unlimited, but there is already an unlimited length dimension defined for this net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM to create a dimension named lat of length 18 and a unlimited dimension named rec in a new net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID, L\+A\+T\+ID, R\+E\+C\+ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+C\+R\+E\+A\+TE(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM(N\+C\+ID, \textquotesingle{}lat\textquotesingle{}, 18, L\+A\+T\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM(N\+C\+ID, \textquotesingle{}rec\textquotesingle{}, N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED, R\+E\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-DIMID}{}\subsection{4.\+3 N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+I\+D }\label{nc_f77_interface_guide_f77_NF-INQ-DIMID}
The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID returns (as an argument) the ID of a net\+C\+DF dimension, given the name of the dimension. If ndims is the number of dimensions defined for a net\+C\+DF dataset, each dimension has an ID between 1 and ndims.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID (I\+N\+T\+E\+G\+ER N\+C\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER dimid)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily N\+A\+ME} \+: Dimension name.

{\ttfamily dimid} \+: Returned dimension ID.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The name that was specified is not the name of a dimension in the net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID to determine the dimension ID of a dimension named lat, amed to have been defined previously in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID, L\+A\+T\+ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID(N\+C\+ID, \textquotesingle{}lat\textquotesingle{}, L\+A\+T\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-DIM-Family}{}\subsection{4.\+4 N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M Family }\label{nc_f77_interface_guide_f77_NF-INQ-DIM-Family}
This family of functions returns information about a net\+C\+DF dimension. Information about a dimension includes its name and its length. The length for the unlimited dimension, if any, is the number of records written so far.

The functions in this family include N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+IM, N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+N\+A\+ME, and N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+L\+EN. The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+IM returns all the information about a dimension; the other functions each return just one item of information.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+IM (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER D\+I\+M\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) name, I\+N\+T\+E\+G\+ER len) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+N\+A\+ME (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER D\+I\+M\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) name) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+L\+EN (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER D\+I\+M\+ID, I\+N\+T\+E\+G\+ER len)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily D\+I\+M\+ID} \+: Dimension ID, from a previous call to N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID or N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM.

{\ttfamily N\+A\+ME} \+: Returned dimension name. The caller must allocate space for the returned name. The maximum possible length, in characters, of a dimension name is given by the predefined constant N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily len} \+: Returned length of dimension. For the unlimited dimension, this is the current maximum value used for writing any variables with this dimension, that is the maximum record number.

\subsection*{Errors }

These functions return the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The dimension ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+IM to determine the length of a dimension named lat, and the name and current maximum length of the unlimited dimension for an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID, L\+A\+T\+ID, L\+A\+T\+L\+EN, R\+E\+C\+ID, N\+R\+E\+CS C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$(N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME) L\+A\+T\+N\+AM, R\+E\+C\+N\+AM ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ! get ID of unlimited dimension S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+U\+N\+L\+I\+M\+D\+I\+M(\+N\+C\+I\+D, R\+E\+C\+I\+D) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID(N\+C\+ID, \textquotesingle{}lat\textquotesingle{}, L\+A\+T\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ! get lat length S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+L\+E\+N(\+N\+C\+I\+D, L\+A\+T\+I\+D, L\+A\+T\+L\+E\+N) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ! get unlimited dimension name and current length S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M(\+N\+C\+I\+D, R\+E\+C\+I\+D, R\+E\+C\+N\+A\+M\+E, N\+R\+E\+C\+S) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_NF-RENAME-DIM}{}\subsection{4.\+5 N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+I\+M }\label{nc_f77_interface_guide_f77_NF-RENAME-DIM}
The function N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM renames an existing dimension in a net\+C\+DF dataset open for writing. If the new name is longer than the old name, the net\+C\+DF dataset must be in define mode. You cannot rename a dimension to have the same name as another dimension.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER D\+I\+M\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily D\+I\+M\+ID} \+: Dimension ID, from a previous call to N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID or N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM.

{\ttfamily N\+A\+ME} \+: New dimension name.

\subsection*{Errors }

N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The new name is the name of another dimension.
\item The dimension ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The new name is longer than the old name and the net\+C\+DF dataset is not in define mode.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM to rename the dimension lat to latitude in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID, L\+A\+T\+ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! put in define mode to rename dimension S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+D\+E\+F(\+N\+C\+I\+D) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID(N\+C\+ID, \textquotesingle{}lat\textquotesingle{}, L\+A\+T\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM(N\+C\+ID, L\+A\+T\+ID, \textquotesingle{}latitude\textquotesingle{}) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ! leave define mode S\+T\+A\+T\+US = N\+F\+\_\+\+E\+N\+D\+D\+E\+F(\+N\+C\+I\+D) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_User-Defined-Data-Types}{}\section{5. User Defined Data Types }\label{nc_f77_interface_guide_f77_User-Defined-Data-Types}
\hypertarget{nc_f77_interface_guide_f77_User-Defined-Types-Introduction}{}\subsection{5.\+1 User Defined Types Introduction }\label{nc_f77_interface_guide_f77_User-Defined-Types-Introduction}
Net\+C\+D\+F-\/4 has added support for four different user defined data types.

{\ttfamily compound type} \+: Like a C struct, a compound type is a collection of types, including other user defined types, in one package.

{\ttfamily variable length array type} \+: The variable length array may be used to store ragged arrays.

{\ttfamily opaque type} \+: This type has only a size per element, and no other type information.

{\ttfamily enum type} \+: Like an enumeration in C, this type lets you assign text values to integer values, and store the integer values.

Users may construct user defined type with the various N\+F\+\_\+\+D\+E\+F\+\_\+$\ast$ functions described in this. They may learn about user defined types by using the N\+F\+\_\+\+I\+N\+Q\+\_\+ functions defined in this.

Once types are constructed, define variables of the new type with N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR (see \href{#NF_005fDEF_005fVAR}{\tt Create a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR}}). Write to them with N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1, N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+AR, N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RA, or N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RS (see \href{#Variables}{\tt Variables}). Read data of user-\/defined type with N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1, N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+AR, N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RA, or N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RS (see section \href{#Variables}{\tt Variables}).

Create attributes of the new type with N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+TT (see \href{#NF_005fPUT_005fATT_005f-type}{\tt N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+ type}). Read attributes of the new type with N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+TT (see \href{#NF_005fGET_005fATT_005f-type}{\tt N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+ type}).\hypertarget{nc_f77_interface_guide_f77_NF-INQ-TYPEIDS}{}\subsection{5.\+2 Learn the I\+Ds of All Types in Group\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E\+I\+D\+S }\label{nc_f77_interface_guide_f77_NF-INQ-TYPEIDS}
Learn the number of types defined in a group, and their I\+Ds.

\subsection*{Usage }

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E\+I\+DS(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER N\+T\+Y\+P\+ES, I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+I\+DS)

{\ttfamily N\+C\+ID} \+: The group id.

{\ttfamily N\+T\+Y\+P\+ES} \+: A pointer to int which will get the number of types defined in the group. If N\+U\+LL, ignored.

{\ttfamily T\+Y\+P\+E\+I\+DS} \+: A pointer to an int array which will get the typeids. If N\+U\+LL, ignored.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

\subsection*{Example }

The following example is from the test program nf\+\_\+test/ftst\+\_\+vars3.\+F.

 

\begin{DoxyVerb}  retval = nf_inq_typeids(ncid, num_types, typeids)
  if (retval .ne. nf_noerr) call handle_err(retval)
\end{DoxyVerb}
\hypertarget{nc_f77_interface_guide_f77_NF-INQ-TYPEID}{}\subsection{5.\+3 Find a Typeid from Group and Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E\+I\+D }\label{nc_f77_interface_guide_f77_NF-INQ-TYPEID}
Given a group ID and a type name, find the ID of the type. If the type is not found in the group, then the parents are searched. If still not found, the entire file is searched.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E\+I\+D(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, C\+H\+A\+R\+A\+C\+T\+E\+R N\+A\+M\+E, N\+F\+\_\+\+T\+Y\+P\+E T\+Y\+P\+E\+I\+D\+P)

{\ttfamily N\+C\+ID} \+: The group id.

{\ttfamily N\+A\+ME} \+: The name of a type.

{\ttfamily T\+Y\+P\+E\+I\+DP} \+: The typeid of the named type (if found).

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+PE} \+: Can’t find type.

\subsection*{Example }

The following example is from nf\+\_\+test/ftst\+\_\+types3.\+F\+:

 

C Go to a child group and find the id of our type. retval = nf\+\_\+inq\+\_\+grp\+\_\+ncid(ncid, group\+\_\+name,b\+\_\+grpid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+inq\+\_\+typeidb\+\_\+grpid, type\+\_\+name, typeid\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-TYPE}{}\subsection{5.\+4 Learn About a User Defined Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E }\label{nc_f77_interface_guide_f77_NF-INQ-TYPE}
Given an ncid and a typeid, get the information about a type. This function will work on any type, including atomic and any user defined type, whether compound, opaque, enumeration, or variable length array.

For even more information about a user defined type \href{#NF_005fINQ_005fUSER_005fTYPE}{\tt Learn About a User Defined Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+U\+S\+E\+R\+\_\+\+T\+Y\+PE}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+PE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER S\+I\+ZE)

{\ttfamily N\+C\+ID} \+: The ncid for the group containing the type (ignored for atomic types).

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, N\+F\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE, N\+F\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM, N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR, or as found in netcdf.\+inc in the list of atomic types (N\+F\+\_\+\+C\+H\+AR, N\+F\+\_\+\+I\+NT, etc.).

{\ttfamily N\+A\+ME} \+: The name of the user defined type will be copied here. It will be N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME bytes or less. For atomic types, the type name from C\+DL will be given.

{\ttfamily S\+I\+Z\+EP} \+: The (in-\/memory) size of the type (in bytes) will be copied here. V\+L\+EN type size is the size of one vlen sturture (i.\+e. the sice of nc\+\_\+vlen\+\_\+t). String size is returned as the size of one C character pointer.

\subsection*{Return Codes }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad typeid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Seeking a user-\/defined type in a net\+C\+D\+F-\/3 file.

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: Seeking a user-\/defined type in a net\+C\+D\+F-\/4 file for which classic model has been turned on.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID} \+: Bad group ID in ncid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Type ID not found.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from the test program nf\+\_\+test/ftst\+\_\+vars3.\+F, and it uses all the possible inquiry functions on an enum type.

 

C Check the enum type. retval = N\+F\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E\+I\+D\+S(ncid, num\+\_\+types, typeids) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (num\+\_\+types .ne. M\+A\+X\+\_\+\+T\+Y\+P\+ES) stop 2 retval = nf\+\_\+inq\+\_\+enum(ncid, typeids(1), type\+\_\+name, base\+\_\+type, \& base\+\_\+size, num\+\_\+members) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (base\+\_\+type .ne. N\+F\+\_\+\+I\+NT .or. num\+\_\+members .ne. 2) stop 2 retval = nf\+\_\+inq\+\_\+enum\+\_\+member(ncid, typeids(1), 1, member\+\_\+name, \& member\+\_\+value) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (member\+\_\+name(1\+:len(one\+\_\+name)) .ne. one\+\_\+name) stop 2\hypertarget{nc_f77_interface_guide_f77_NF-INQ-USER-TYPE}{}\subsection{5.\+5 Learn About a User Defined Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+U\+S\+E\+R\+\_\+\+T\+Y\+P\+E }\label{nc_f77_interface_guide_f77_NF-INQ-USER-TYPE}
Given an ncid and a typeid, get the information about a user defined type. This function will work on any user defined type, whether compound, opaque, enumeration, or variable length array.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+U\+S\+E\+R\+\_\+\+T\+Y\+PE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER S\+I\+ZE, I\+N\+T\+E\+G\+ER B\+A\+S\+E\+\_\+\+N\+F\+\_\+\+T\+Y\+PE, I\+N\+T\+E\+G\+ER N\+F\+I\+E\+L\+DS, I\+N\+T\+E\+G\+ER C\+L\+A\+SS)

{\ttfamily N\+C\+ID} \+: The ncid for the group containing the user defined type.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, N\+F\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE, N\+F\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM, N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME} \+: The name of the user defined type will be copied here. It will be N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME bytes or less.

{\ttfamily S\+I\+ZE} \+: The (in-\/memory) size of the user defined type will be copied here.

{\ttfamily B\+A\+S\+E\+\_\+\+N\+F\+\_\+\+T\+Y\+PE} \+: The base typeid will be copied here for vlen and enum types.

{\ttfamily N\+F\+I\+E\+L\+DS} \+: The number of fields will be copied here for enum and compound types.

{\ttfamily C\+L\+A\+SS} \+: The class of the user defined type, N\+F\+\_\+\+V\+L\+EN, N\+F\+\_\+\+O\+P\+A\+Q\+UE, N\+F\+\_\+\+E\+N\+UM, or N\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, will be copied here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad typeid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+F\+I\+E\+L\+D\+ID} \+: Bad fieldid.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+types2.\+F.

 

C Check the type. retval = nf\+\_\+inq\+\_\+user\+\_\+type(ncid, typeids(1), name\+\_\+in, size\+\_\+in, \& base\+\_\+type\+\_\+in, nfields\+\_\+in, class\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_Compound-Types-Introduction}{}\subsection{5.\+6 Compound Types Introduction }\label{nc_f77_interface_guide_f77_Compound-Types-Introduction}
Net\+C\+D\+F-\/4 addedpport for compound types, which allow users to construct a new type -\/ a combination of other types, like a C struct.

Compound types are notpported in classic or 64-\/bit offset format files.

To write data in a compound type, first use nf\+\_\+def\+\_\+compound to create the type, multiple calls to nf\+\_\+insert\+\_\+compound to add to the compound type, and then write data with the appropriate nf\+\_\+put\+\_\+var1, nf\+\_\+put\+\_\+vara, nf\+\_\+put\+\_\+vars, or nf\+\_\+put\+\_\+varm call.

To read data written in a compound type, you must know its structure. Use the N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND functions to learn about the compound type.

In Fortran a character buffer must be used for the compound data. The user must read the data from within that buffer in the same way that the C compiler which compiled net\+C\+DF would store the structure.

The use of compound types introduces challenges and portability ies for Fortran users.\hypertarget{nc_f77_interface_guide_f77_NF-DEF-COMPOUND}{}\subsubsection{5.\+6.\+1 Creating a Compound Type\+: N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{nc_f77_interface_guide_f77_NF-DEF-COMPOUND}
Create a compound type. Provide an ncid, a name, and a total size (in bytes) of one element of the completed compound type.

After calling this function, fill out the type with repeated calls to N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND (see \href{#NF_005fINSERT_005fCOMPOUND}{\tt Inserting a Field into a Compound Type\+: N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND}). Call N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND once for each field you wish to insert into the compound type.

Note that there does not seem to be a way to readch types into structures in Fortran 90 (and there are no structures in Fortran 77).

Fortran users may use character buffers to read and write compound types.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER S\+I\+ZE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+I\+DP)

{\ttfamily N\+C\+ID} \+: The groupid where this compound type will be created.

{\ttfamily S\+I\+ZE} \+: The size, in bytes, of the compound type.

{\ttfamily N\+A\+ME} \+: The name of the new compound type.

{\ttfamily T\+Y\+P\+E\+I\+DP} \+: The typeid of the new type will be placed here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: That name is in use. Compound type names must be unique in the data file.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: Name exceeds max length N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F\+\_\+\+N\+E\+T\+C\+D\+F4. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to write to a read-\/only file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+types2.\+F.

 

C Define a compound type. retval = nf\+\_\+def\+\_\+compound(ncid, cmp\+\_\+size, type\+\_\+name, \& cmp\+\_\+typeid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INSERT-COMPOUND}{}\subsubsection{5.\+6.\+2 Inserting a Field into a Compound Type\+: N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{nc_f77_interface_guide_f77_NF-INSERT-COMPOUND}
Insert a named field into a compound type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+T\+I\+ON N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND(I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER O\+F\+F\+S\+ET, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID)

{\ttfamily T\+Y\+P\+E\+ID} \+: The typeid for this compound type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME} \+: The name of the new field.

{\ttfamily O\+F\+F\+S\+ET} \+: Offset in byte from the beginning of the compound type for this field.

{\ttfamily F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID} \+: The type of the field to be inserted.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: That name is in use. Field names must be unique within a compound type.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: Name exceed max length N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F\+\_\+\+N\+E\+T\+C\+D\+F4. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+types.\+F.

 

C Define a compound type. retval = nf\+\_\+def\+\_\+compound(ncid, W\+I\+N\+D\+\_\+\+T\+\_\+\+S\+I\+ZE, type\+\_\+name, \& wind\+\_\+typeid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+insert\+\_\+compound(ncid, wind\+\_\+typeid, u\+\_\+name, 0, N\+F\+\_\+\+I\+N\+T) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+insert\+\_\+compound(ncid, wind\+\_\+typeid, v\+\_\+name, 4, N\+F\+\_\+\+I\+N\+T) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INSERT-ARRAY-COMPOUND}{}\subsubsection{5.\+6.\+3 Inserting an Array Field into a Compound Type\+: N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{nc_f77_interface_guide_f77_NF-INSERT-ARRAY-COMPOUND}
Insert a named array field into a compound type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+C\+O\+M\+P\+O\+U\+ND(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER O\+F\+F\+S\+ET, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID, I\+N\+T\+E\+G\+ER N\+D\+I\+MS, I\+N\+T\+E\+G\+ER D\+I\+M\+\_\+\+S\+I\+Z\+ES)

{\ttfamily N\+C\+ID} \+: The ID of the file that contains the array type and the compound type.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this compound type, as returned by nf\+\_\+def\+\_\+compound, or nf\+\_\+inq\+\_\+var.

{\ttfamily N\+A\+ME} \+: The name of the new field.

{\ttfamily O\+F\+F\+S\+ET} \+: Offset in byte from the beginning of the compound type for this field.

{\ttfamily F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID} \+: The base type of the array to be inserted.

{\ttfamily N\+D\+I\+MS} \+: The number of dimensions for the array to be inserted.

{\ttfamily D\+I\+M\+\_\+\+S\+I\+Z\+ES} \+: An array containing the sizes of each dimension.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: That name is in use. Field names must be unique within a compound type.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: Name exceed max length N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F\+\_\+\+N\+E\+T\+C\+D\+F4. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode.

{\ttfamily N\+F\+\_\+\+E\+T\+Y\+P\+E\+D\+E\+F\+I\+N\+ED} \+: Attempt to change type that has already been committed. The first time the file leaves define mode, all defined types are committed, and can’t be changed. If you wish to add an array to a compound type, you must do so before the compound type is committed.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+types2.\+F.

 

C Define a compound type. retval = nf\+\_\+def\+\_\+compound(ncid, cmp\+\_\+size, type\+\_\+name, \& cmp\+\_\+typeid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Include an array. dim\+\_\+sizes(1) = NX dim\+\_\+sizes(2) = NY retval = nf\+\_\+insert\+\_\+array\+\_\+compound(ncid, cmp\+\_\+typeid, ary\+\_\+name, 0, \& N\+F\+\_\+\+I\+NT, N\+D\+I\+MS, dim\+\_\+sizes) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)\hypertarget{nc_f77_interface_guide_f77_NF-INQ-COMPOUND}{}\subsubsection{5.\+6.\+4 Learn About a Compound Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{nc_f77_interface_guide_f77_NF-INQ-COMPOUND}
Get the number of fields, length in bytes, and name of a compound type.

In addtion to the N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND function, three additional functions are provided which get only the name, size, and number of fields.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER S\+I\+Z\+EP, I\+N\+T\+E\+G\+ER N\+F\+I\+E\+L\+D\+SP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+N\+A\+ME(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+S\+I\+ZE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER S\+I\+Z\+EP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+N\+F\+I\+E\+L\+DS(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER N\+F\+I\+E\+L\+D\+SP)

{\ttfamily N\+C\+ID} \+: The ID of any group in the file that contains the compound type.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this compound type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME} \+: Character array which will get the name of the compound type. It will have a maximum length of N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily S\+I\+Z\+EP} \+: The size of the compound type in bytes will be put here.

{\ttfamily N\+F\+I\+E\+L\+D\+SP} \+: The number of fields in the compound type will be placed here.

\subsection*{Return Codes }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Couldn’t find this ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4/\+H\+D\+F5 file.

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: A net\+C\+D\+F-\/4/\+H\+D\+F5 file, but with C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL. No user defined types are allowed in the classic model.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+PE} \+: This type not a compound type.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad type id.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+types.\+F.

 

C Check it differently. retval = nf\+\_\+inq\+\_\+compound(ncid, typeids(1), name\+\_\+in, size\+\_\+in, \& nfields\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (name\+\_\+in(1\+:len(type\+\_\+name)) .ne. type\+\_\+name .or. \& size\+\_\+in .ne. W\+I\+N\+D\+\_\+\+T\+\_\+\+S\+I\+ZE .or. nfields\+\_\+in .ne. 2) stop 2

C Check it one piece at a time. retval = nf\+\_\+inq\+\_\+compound\+\_\+nfields(ncid, typeids(1), nfields\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (nfields\+\_\+in .ne. 2) stop 2 retval = nf\+\_\+inq\+\_\+compound\+\_\+size(ncid, typeids(1), size\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (size\+\_\+in .ne. W\+I\+N\+D\+\_\+\+T\+\_\+\+S\+I\+ZE) stop 2 retval = nf\+\_\+inq\+\_\+compound\+\_\+name(ncid, typeids(1), name\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (name\+\_\+in(1\+:len(type\+\_\+name)) .ne. type\+\_\+name) stop 2\hypertarget{nc_f77_interface_guide_f77_NF-INQ-COMPOUND-FIELD}{}\subsubsection{5.\+6.\+5 Learn About a Field of a Compound Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+LD}\label{nc_f77_interface_guide_f77_NF-INQ-COMPOUND-FIELD}
Get information about one of the fields of a compound type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+LD(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER O\+F\+F\+S\+E\+TP, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+I\+DP, I\+N\+T\+E\+G\+ER N\+D\+I\+M\+SP, I\+N\+T\+E\+G\+ER D\+I\+M\+\_\+\+S\+I\+Z\+E\+SP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+L\+D\+N\+A\+ME(I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+ID, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+L\+D\+I\+N\+D\+EX(I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+I\+DP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+L\+D\+O\+F\+F\+S\+ET(I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+ID, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+ID, I\+N\+T\+E\+G\+ER O\+F\+F\+S\+E\+TP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+L\+D\+T\+Y\+PE(I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+ID, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+ID, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+I\+DP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+L\+D\+N\+D\+I\+MS(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+ID, I\+N\+T\+E\+G\+ER N\+D\+I\+M\+SP)

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+L\+D\+D\+I\+M\+\_\+\+S\+I\+Z\+ES(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER F\+I\+E\+L\+D\+ID, I\+N\+T\+E\+G\+ER D\+I\+M\+\_\+\+S\+I\+Z\+ES)

{\ttfamily N\+C\+ID} \+: The groupid where this compound type exists.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this compound type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily F\+I\+E\+L\+D\+ID} \+: A one-\/based index number specifying a field in the compound type.

{\ttfamily N\+A\+ME} \+: A character array which will get the name of the field. The name will be N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME characters, at most.

{\ttfamily O\+F\+F\+S\+E\+TP} \+: An integer which will get the offset of the field.

{\ttfamily F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID} \+: An integer which will get the typeid of the field.

{\ttfamily N\+D\+I\+M\+SP} \+: An integer which will get the number of dimensions of the field.

{\ttfamily D\+I\+M\+\_\+\+S\+I\+Z\+E\+SP} \+: An integer array which will get the dimension sizes of the field.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad type id.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/fst\+\_\+types.\+F.

 


\begin{DoxyCode}
C     Check the first field of the compound type.
      retval = nf\_inq\_compound\_field(ncid, typeids(1), 1, name\_in,
     &     offset\_in, field\_typeid\_in, ndims\_in, dim\_sizes\_in)
      if (retval .ne. nf\_noerr) call handle\_err(retval)
      if (name\_in(1:len(u\_name)) .ne. u\_name .or. offset\_in .ne. 0 .or.
     &     field\_typeid\_in .ne. NF\_INT .or. ndims\_in .ne. 0) stop 2
      retval = nf\_inq\_compound\_fieldname(ncid, typeids(1), 1, name\_in)
      if (retval .ne. nf\_noerr) call handle\_err(retval)
      if (name\_in(1:len(u\_name)) .ne. u\_name) stop 2
      retval = nf\_inq\_compound\_fieldoffset(ncid, typeids(1), 1,
     &     offset\_in)
      if (retval .ne. nf\_noerr) call handle\_err(retval)
      if (offset\_in .ne. 0) stop 2
      retval = nf\_inq\_compound\_fieldtype(ncid, typeids(1), 1,
     &     field\_typeid\_in)
      if (retval .ne. nf\_noerr) call handle\_err(retval)
      if (field\_typeid\_in .ne. NF\_INT) stop 2
      retval = nf\_inq\_compound\_fieldndims(ncid, typeids(1), 1,
     &     ndims\_in)
      if (retval .ne. nf\_noerr) call handle\_err(retval)
      if (ndims\_in .ne. 0) stop 2
\end{DoxyCode}


\subsection*{5.\+7 Variable Length Array Introduction }

Net\+C\+D\+F-\/4 addedpport for a variable length array type. This is not supported in classic or 64-\/bit offset files, or in net\+C\+D\+F-\/4 files which were created with the N\+F\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL flag.

A variable length array is represented in C as a structure from H\+D\+F5, the nf\+\_\+vlen\+\_\+t structure. It contains a len member, which contains the length of that array, and a pointer to the array.

So an array of V\+L\+EN in C is an array of nc\+\_\+vlen\+\_\+t structures. The only way to handle this in Fortran is with a character buffer sized correctly for the platform.

The extra access functions N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT and N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT to get and put one V\+L\+EN element. (That is, one array of variable length.) When calling the put, the data are not copied from the source. When calling the get the data are copied from V\+L\+EN allocated memory, which must still be freed (see below).

V\+L\+EN arrays are handled differently with respect to allocation of memory. Generally, when reading data, it is up to the user to malloc (andbsequently free) the memory needed to hold the data. It is up to the user to ere that enough memory is allocated.

With V\+L\+E\+Ns, this is impossible. The user cannot know the size of an array of V\+L\+EN until after reading the array. Therefore when reading V\+L\+EN arrays, the net\+C\+DF library will allocate the memory for the data within each V\+L\+EN.

It is up to the user, however, to eventually free this memory. This is not just a matter of one call to free, with the pointer to the array of V\+L\+E\+Ns; each V\+L\+EN contains a pointer which must be freed.

Compression is permitted but may not be effective for V\+L\+EN data, because the compression is applied to the nc\+\_\+vlen\+\_\+t structures, rather than the actual data.

\subsubsection*{5.\+7.\+1 Define a Variable Length Array (V\+L\+EN)\+: N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN}

Use this function to define a variable length array type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN(I\+N\+T\+E\+G\+ER N\+C\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER B\+A\+S\+E\+\_\+\+T\+Y\+P\+E\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+P\+EP)

{\ttfamily N\+C\+ID} \+: The ncid of the file to create the V\+L\+EN type in.

{\ttfamily N\+A\+ME} \+: A name for the V\+L\+EN type.

{\ttfamily B\+A\+S\+E\+\_\+\+T\+Y\+P\+E\+ID} \+: The typeid of the base type of the V\+L\+EN. For example, for a V\+L\+EN of shorts, the base type is N\+F\+\_\+\+S\+H\+O\+RT. This can be a user defined type.

{\ttfamily X\+T\+Y\+P\+EP} \+: The typeid of the new V\+L\+EN type will be set here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME exceeded.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: Name is already in use.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Attribute or variable name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: ncid invalid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID} \+: Group ID part of ncid was invalid.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: Size is invalid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+M\+EM} \+: Out of memory.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars4.\+F.

 

C Create the vlen type. retval = nf\+\_\+def\+\_\+vlen(ncid, vlen\+\_\+type\+\_\+name, nf\+\_\+int, vlen\+\_\+typeid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsubsection*{5.\+7.\+2 Learning about a Variable Length Array (V\+L\+EN) Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+L\+EN}

Use this type to learn about a vlen.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+L\+EN(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER D\+A\+T\+U\+M\+\_\+\+S\+I\+Z\+EP, I\+N\+T\+E\+G\+ER B\+A\+S\+E\+\_\+\+N\+F\+\_\+\+T\+Y\+P\+EP)

{\ttfamily N\+C\+ID} \+: The ncid of the file that contains the V\+L\+EN type.

{\ttfamily X\+T\+Y\+PE} \+: The type of the V\+L\+EN to inquire about.

{\ttfamily N\+A\+ME} \+: The name of the V\+L\+EN type. The name will be N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME characters or less.

{\ttfamily D\+A\+T\+U\+M\+\_\+\+S\+I\+Z\+EP} \+: A pointer to a size\+\_\+t, this will get the size of one element of this vlen.

{\ttfamily B\+A\+S\+E\+\_\+\+N\+F\+\_\+\+T\+Y\+P\+EP} \+: An integer that will get the type of the V\+L\+EN base type. (In other words, what type is this a V\+L\+EN of?)

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+PE} \+: Can’t find the typeid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: ncid invalid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID} \+: Group ID part of ncid was invalid.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars4.\+F.

 

C Use nf\+\_\+inq\+\_\+vlen and makere we get the same answers as we did C with nf\+\_\+inq\+\_\+user\+\_\+type. retval = nf\+\_\+inq\+\_\+vlen(ncid, typeids(1), type\+\_\+name, base\+\_\+size, \& base\+\_\+type) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsubsection*{5.\+7.\+3 Releasing Memory for a Variable Length Array (V\+L\+EN) Type\+: N\+F\+\_\+\+F\+R\+E\+E\+\_\+\+V\+L\+EN}

When a V\+L\+EN is read into user memory from the file, the H\+D\+F5 library performs memory allocations for each of the variable length arrays contained within the V\+L\+EN structure. This memory must be freed by the user to avoid memory leaks.

This violates the normal net\+C\+DF expectation that the user is responsible for all memory allocation. But, with V\+L\+EN arrays, the underlying H\+D\+F5 library allocates the memory for the user, and the user is responsible for deallocating that memory.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+F\+R\+E\+E\+\_\+\+V\+L\+E\+N(\+C\+H\+A\+R\+A\+C\+T\+E\+R V\+L);

{\ttfamily VL} \+: The variable length array structure which is to be freed.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+PE} \+: Can’t find the typeid.

\subsection*{Example }

\subsubsection*{5.\+7.\+4 Set a Variable Length Array with N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT}

Use this to set the element of the (potentially) n-\/dimensional array of V\+L\+EN. That is, this sets the data in one variable length array.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT, I\+N\+T\+E\+G\+ER L\+EN, D\+A\+TA)

{\ttfamily N\+C\+ID} \+: The ncid of the file that contains the V\+L\+EN type.

{\ttfamily X\+T\+Y\+PE} \+: The type of the V\+L\+EN.

{\ttfamily V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT} \+: The V\+L\+EN element to be set.

{\ttfamily L\+EN} \+: The number of entries in this array.

{\ttfamily D\+A\+TA} \+: The data to be stored. Must match the base type of this V\+L\+EN.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+PE} \+: Can’t find the typeid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: ncid invalid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID} \+: Group ID part of ncid was invalid.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars4.\+F.

 

C Set up the vlen with this helper function, since F77 can\textquotesingle{}t deal C with pointers. retval = nf\+\_\+put\+\_\+vlen\+\_\+element(ncid, vlen\+\_\+typeid, vlen, \& vlen\+\_\+len, data1) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsubsection*{5.\+7.\+5 Set a Variable Length Array with N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT}

Use this to set the element of the (potentially) n-\/dimensional array of V\+L\+EN. That is, this sets the data in one variable length array.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT, I\+N\+T\+E\+G\+ER L\+EN, D\+A\+TA)

{\ttfamily N\+C\+ID} \+: The ncid of the file that contains the V\+L\+EN type.

{\ttfamily X\+T\+Y\+PE} \+: The type of the V\+L\+EN.

{\ttfamily V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT} \+: The V\+L\+EN element to be set.

{\ttfamily L\+EN} \+: This will be set to the number of entries in this array.

{\ttfamily D\+A\+TA} \+: The data will be copied here. Sufficient storage must be available or bad things will happen to you.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+PE} \+: Can’t find the typeid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: ncid invalid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID} \+: Group ID part of ncid was invalid.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars4.\+F.

 

C Read the vlen attribute. retval = nf\+\_\+get\+\_\+att(ncid, N\+F\+\_\+\+G\+L\+O\+B\+AL, \textquotesingle{}att1\textquotesingle{}, vlen\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Get the data from the vlen we just read. retval = nf\+\_\+get\+\_\+vlen\+\_\+element(ncid, vlen\+\_\+typeid, vlen\+\_\+in, \& vlen\+\_\+len\+\_\+in, data1\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{5.\+8 Opaque Type Introduction }

Net\+C\+D\+F-\/4 addedpport for the opaque type. This is notpported in classic or 64-\/bit offset files.

The opaque type is a type which is a collection of objects of a known size. (And each object is the same size). Nothing is known to net\+C\+DF about the contents of these blobs of data, except their size in bytes, and the name of the type.

To use an opaque type, first define it with \href{#NF_005fDEF_005fOPAQUE}{\tt Creating Opaque Types\+: N\+F\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE}. If encountering an enum type in a new data file, use \href{#NF_005fINQ_005fOPAQUE}{\tt Learn About an Opaque Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+O\+P\+A\+Q\+UE} to learn its name and size.

\subsubsection*{5.\+8.\+1 Creating Opaque Types\+: N\+F\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE}

Create an opaque type. Provide a size and a name.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER S\+I\+ZE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+I\+DP)

{\ttfamily N\+C\+ID} \+: The groupid where the type will be created. The type may be used anywhere in the file, no matter what group it is in.

{\ttfamily S\+I\+ZE} \+: The size of each opaque object.

{\ttfamily N\+A\+ME} \+: The name for this type. Must be shorter than N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily T\+Y\+P\+E\+I\+DP} \+: Pointer where the new typeid for this type is returned. Use this typeid when defining variables of this type with \href{#NF_005fDEF_005fVAR}{\tt Create a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR}}.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad typeid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+F\+I\+E\+L\+D\+ID} \+: Bad fieldid.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars3.\+F.

 

C Create the opaque type. retval = nf\+\_\+def\+\_\+opaque(ncid, opaque\+\_\+size, opaque\+\_\+type\+\_\+name, \& opaque\+\_\+typeid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsubsection*{5.\+8.\+2 Learn About an Opaque Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+O\+P\+A\+Q\+UE}

Given a typeid, get the information about an opaque type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+O\+P\+A\+Q\+UE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER S\+I\+Z\+EP)

{\ttfamily N\+C\+ID} \+: The ncid for the group containing the opaque type.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this opaque type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME} \+: The name of the opaque type will be copied here. It will be N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME bytes or less.

{\ttfamily S\+I\+Z\+EP} \+: The size of the opaque type will be copied here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad typeid.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+F\+I\+E\+L\+D\+ID} \+: Bad fieldid.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars3.\+F.

 

C Use nf\+\_\+inq\+\_\+opaque and makere we get the same answers as we did C with nf\+\_\+inq\+\_\+user\+\_\+type. retval = nf\+\_\+inq\+\_\+opaque(ncid, typeids(2), type\+\_\+name, base\+\_\+size) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{5.\+9 Enum Type Introduction }

Net\+C\+D\+F-\/4 addedpport for the enum type. This is notpported in classic or 64-\/bit offset files.

\subsubsection*{5.\+9.\+1 Creating a Enum Type\+: N\+F\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM}

Create an enum type. Provide an ncid, a name, and a base integer type.

After calling this function, fill out the type with repeated calls to N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM (see \href{#NF_005fINSERT_005fENUM}{\tt Inserting a Field into a Enum Type\+: N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM}). Call N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM once for each value you wish to make part of the enumeration.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER B\+A\+S\+E\+\_\+\+T\+Y\+P\+E\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER T\+Y\+P\+E\+I\+DP)

{\ttfamily N\+C\+ID} \+: The groupid where this compound type will be created.

{\ttfamily B\+A\+S\+E\+\_\+\+T\+Y\+P\+E\+ID} \+: The base integer type for this enum. Must be one of\+: N\+F\+\_\+\+B\+Y\+TE, N\+F\+\_\+\+U\+B\+Y\+TE, N\+F\+\_\+\+S\+H\+O\+RT, N\+F\+\_\+\+U\+S\+H\+O\+RT, N\+F\+\_\+\+I\+NT, N\+F\+\_\+\+U\+I\+NT, N\+F\+\_\+\+I\+N\+T64, N\+F\+\_\+\+U\+I\+N\+T64.

{\ttfamily N\+A\+ME} \+: The name of the new enum type.

{\ttfamily T\+Y\+P\+E\+I\+DP} \+: The typeid of the new type will be placed here.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: That name is in use. Compound type names must be unique in the data file.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: Name exceeds max length N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F\+\_\+\+N\+E\+T\+C\+D\+F4. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to write to a read-\/only file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode.

This example is from nf\+\_\+test/ftst\+\_\+vars3.\+F.

 

C Create the enum type. retval = nf\+\_\+def\+\_\+enum(ncid, N\+F\+\_\+\+I\+N\+T, enum\+\_\+type\+\_\+name, enum\+\_\+typeid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsubsection*{5.\+9.\+2 Inserting a Field into a Enum Type\+: N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM}

Insert a named member into a enum type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+ER I\+D\+E\+N\+T\+I\+F\+I\+ER, I\+N\+T\+E\+G\+ER V\+A\+L\+UE)

{\ttfamily N\+C\+ID} \+: The ncid of the group which contains the type.

{\ttfamily T\+Y\+P\+E\+ID} \+: The typeid for this enum type, as returned by nf\+\_\+def\+\_\+enum, or nf\+\_\+inq\+\_\+var.

{\ttfamily I\+D\+E\+N\+T\+I\+F\+I\+ER} \+: The identifier of the new member.

{\ttfamily V\+A\+L\+UE} \+: The value that is to be associated with this member.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+ID} \+: Bad group id.

{\ttfamily N\+F\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE} \+: That name is in use. Field names must be unique within a enum type.

{\ttfamily N\+F\+\_\+\+E\+M\+A\+X\+N\+A\+ME} \+: Name exceed max length N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+N\+A\+ME} \+: Name contains illegal characters.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F\+\_\+\+N\+E\+T\+C\+D\+F4. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see \href{#NF_005fOPEN}{\tt N\+F\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars3.\+F.

 

\begin{DoxyVerb}  one = 1
  zero = 0
  retval = nf_insert_enum(ncid, enum_typeid, zero_name, zero)
  if (retval .ne. nf_noerr) call handle_err(retval)
  retval = nf_insert_enum(ncid, enum_typeid, one_name, one)
  if (retval .ne. nf_noerr) call handle_err(retval)
\end{DoxyVerb}


\subsubsection*{5.\+9.\+3 Learn About a Enum Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+UM}

Get information about a user-\/defined enumeration type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+UM(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER B\+A\+S\+E\+\_\+\+N\+F\+\_\+\+T\+Y\+PE, I\+N\+T\+E\+G\+ER B\+A\+S\+E\+\_\+\+S\+I\+ZE, I\+N\+T\+E\+G\+ER N\+U\+M\+\_\+\+M\+E\+M\+B\+E\+RS)

{\ttfamily N\+C\+ID} \+: The group ID of the group which holds the enum type.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this enum type, as returned by N\+F\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM, or N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME} \+: Character array which will get the name. It will have a maximum length of N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily B\+A\+S\+E\+\_\+\+N\+F\+\_\+\+T\+Y\+PE} \+: An integer which will get the base integer type of this enum.

{\ttfamily B\+A\+S\+E\+\_\+\+S\+I\+ZE} \+: An integer which will get the size (in bytes) of the base integer type of this enum.

{\ttfamily N\+U\+M\+\_\+\+M\+E\+M\+B\+E\+RS} \+: An integer which will get the number of members defined for this enumeration type.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad type id.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars3.\+F, an enum type is created and then examined\+:

 

\begin{DoxyVerb}  retval = nf_inq_enum(ncid, typeids(1), type_name, base_type,
 &     base_size, num_members)
  if (retval .ne. nf_noerr) call handle_err(retval)
  if (base_type .ne. NF_INT .or. num_members .ne. 2) stop 2
\end{DoxyVerb}


\subsubsection*{5.\+9.\+4 Learn the Name of a Enum Type\+: nf\+\_\+inq\+\_\+enum\+\_\+member}

Get information about a member of an enum type.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+U\+M\+\_\+\+M\+E\+M\+B\+ER(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER I\+DX, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER V\+A\+L\+UE)

{\ttfamily N\+C\+ID} \+: The groupid where this enum type exists.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this enum type.

{\ttfamily I\+DX} \+: The one-\/based index number for the member of interest.

{\ttfamily N\+A\+ME} \+: A character array which will get the name of the member. It will have a maximum length of N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily V\+A\+L\+UE} \+: An integer that will get the value associated with this member.

\subsection*{Errors }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad type id.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars3.\+F\+:

 

C Check the members of the enum type. retval = nf\+\_\+inq\+\_\+enum\+\_\+member(ncid, typeids(1), 1, member\+\_\+name, \& member\+\_\+value) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (member\+\_\+name(1\+:len(zero\+\_\+name)) .ne. zero\+\_\+name .or. \& member\+\_\+value .ne. 0) stop 2 retval = nf\+\_\+inq\+\_\+enum\+\_\+member(ncid, typeids(1), 2, member\+\_\+name, \& member\+\_\+value) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (member\+\_\+name(1\+:len(one\+\_\+name)) .ne. one\+\_\+name .or. \& member\+\_\+value .ne. 1) stop 2

\subsubsection*{5.\+9.\+5 Learn the Name of a Enum Type\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+U\+M\+\_\+\+I\+D\+E\+NT}

Get the name which is associated with an enum member value.

This is similar to N\+F\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+U\+M\+\_\+\+M\+E\+M\+B\+ER, but instead of using the index of the member, you use the value of the member.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+U\+M\+\_\+\+I\+D\+E\+NT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER V\+A\+L\+UE, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) I\+D\+E\+N\+T\+I\+F\+I\+ER)

{\ttfamily N\+C\+ID} \+: The groupid where this enum type exists.

{\ttfamily X\+T\+Y\+PE} \+: The typeid for this enum type.

{\ttfamily V\+A\+L\+UE} \+: The value for which an identifier is sought.

{\ttfamily I\+D\+E\+N\+T\+I\+F\+I\+ER} \+: A character array that will get the identifier. It will have a maximum length of N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

\subsection*{Return Code }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID} \+: Bad type id, or not an enum type.

{\ttfamily N\+F\+\_\+\+E\+H\+D\+F\+E\+RR} \+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: The value was not found in the enum.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars3.\+F, the values for 0 and 1 are checked in an enum.

 

\begin{DoxyVerb}  retval = nf_inq_enum_ident(ncid, typeids(1), 0, member_name)
  if (retval .ne. nf_noerr) call handle_err(retval)
  if (member_name(1:len(zero_name)) .ne. zero_name) stop 2
  retval = nf_inq_enum_ident(ncid, typeids(1), 1, member_name)
  if (retval .ne. nf_noerr) call handle_err(retval)
  if (member_name(1:len(one_name)) .ne. one_name) stop 2
\end{DoxyVerb}


\section*{6. Variables }

\subsection*{6.\+1 Variables Introduction }

Variables for a net\+C\+DF dataset are defined when the dataset is created, while the net\+C\+DF dataset is in define mode. Other variables may be added later by reentering define mode. A net\+C\+DF variable has a name, a type, and a shape, which are specified when it is defined. A variable may also have values, which are established later in data mode.

Ordinarily, the name, type, and shape are fixed when the variable is first defined. The name may be changed, but the type and shape of a variable cannot be changed. However, a variable defined in terms of the unlimited dimension can grow without bound in that dimension.

A net\+C\+DF variable in an open net\+C\+DF dataset is referred to by a small integer called a variable ID.

Variable I\+Ds reflect the order in which variables were defined within a net\+C\+DF dataset. Variable I\+Ds are 1, 2, 3,..., in the order in which the variables were defined. A function is available for getting the variable ID from the variable name and vice-\/versa.

Attributes (see \href{#Attributes}{\tt Attributes}) may be associated with a variable to specifych properties as units.

Operationspported on variables are\+:


\begin{DoxyItemize}
\item Create a variable, given its name, data type, and shape.
\item Get a variable ID from its name.
\item Get a variable’s name, data type, shape, and number of attributes from its ID.
\item Put a data value into a variable, given variable ID, indices, and value.
\item Put an array of values into a variable, given variable ID, corner indices, edge lengths, and a block of values.
\item Put absampled or mapped array of values into a variable, given variable ID, corner indices, edge lengths, stride vector, index mapping vector, and a block of values.
\item Get a data value from a variable, given variable ID and indices.
\item Get an array of values from a variable, given variable ID, corner indices, and edge lengths.
\item Get absampled or mapped array of values from a variable, given variable ID, corner indices, edge lengths, stride vector, and index mapping vector.
\item Rename a variable.
\end{DoxyItemize}

\subsection*{6.\+2 Language Types Corresponding to net\+C\+DF external data types }

The following table gives the net\+C\+DF external data types and the corresponding type constants for defining variables in the F\+O\+R\+T\+R\+AN interface\+:



 Type F\+O\+R\+T\+R\+AN A\+PI Mnemonic Bits byte N\+F\+\_\+\+B\+Y\+TE 8 char N\+F\+\_\+\+C\+H\+AR 8 short N\+F\+\_\+\+S\+H\+O\+RT 16 int N\+F\+\_\+\+I\+NT 32 float N\+F\+\_\+\+F\+L\+O\+AT 32 double N\+F\+\_\+\+D\+O\+U\+B\+LE 64 



The first column gives the net\+C\+DF external data type, which is the same as the C\+DL data type. The next column gives the corresponding F\+O\+R\+T\+R\+AN parameter for use in net\+C\+DF functions (the parameters are defined in the net\+C\+DF F\+O\+R\+T\+R\+AN include-\/file netcdf.\+inc). The last column gives the number of bits used in the external representation of values of the corresponding type.

Note that there are no net\+C\+DF types corresponding to 64-\/bit integers or to characters wider than 8 bits in the current version of the net\+C\+DF library.

\subsection*{6.\+3 Create a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR} }

The function N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR adds a new variable to an open net\+C\+DF dataset in define mode. It returns (as an argument) a variable ID, given the net\+C\+DF ID, the variable name, the variable type, the number of dimensions, and a list of the dimension I\+Ds.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR(I\+N\+T\+E\+G\+ER N\+C\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, I\+N\+T\+E\+G\+ER N\+V\+D\+I\+MS, I\+N\+T\+E\+G\+ER V\+D\+I\+M\+S($\ast$), I\+N\+T\+E\+G\+ER varid)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily N\+A\+ME} \+: Variable name.

{\ttfamily X\+T\+Y\+PE} \+: One of the set of predefined net\+C\+DF external data types. The type of this parameter, N\+F\+\_\+\+T\+Y\+PE, is defined in the net\+C\+DF header file. The valid net\+C\+DF external data types are N\+F\+\_\+\+B\+Y\+TE, N\+F\+\_\+\+C\+H\+AR, N\+F\+\_\+\+S\+H\+O\+RT, N\+F\+\_\+\+I\+NT, N\+F\+\_\+\+F\+L\+O\+AT, and N\+F\+\_\+\+D\+O\+U\+B\+LE. If the file is a Net\+C\+D\+F-\/4/\+H\+D\+F5 file, the additional types N\+F\+\_\+\+U\+B\+Y\+TE, N\+F\+\_\+\+U\+S\+H\+O\+RT, N\+F\+\_\+\+U\+I\+NT, N\+F\+\_\+\+I\+N\+T64, N\+F\+\_\+\+U\+I\+N\+T64, and N\+F\+\_\+\+S\+T\+R\+I\+NG may be used, as well as a user defined type ID.

{\ttfamily N\+V\+D\+I\+MS} \+: Number of dimensions for the variable. For example, 2 specifies a matrix, 1 specifies a vector, and 0 means the variable is a scalar with no dimensions. Must not be negative or greater than the predefined constant N\+F\+\_\+\+M\+A\+X\+\_\+\+V\+A\+R\+\_\+\+D\+I\+MS.

{\ttfamily V\+D\+I\+MS} \+: Vector of ndims dimension I\+Ds corresponding to the variable dimensions. If the ID of the unlimited dimension is included, it must be first. This argument is ignored if ndims is 0. For expanded model net\+C\+D\+F4/\+H\+D\+F5 files, there may be any number of unlimited dimensions, and they may be used in any element of the dimids array.

{\ttfamily varid} \+: Returned variable ID.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The net\+C\+DF dataset is not in define mode.
\item The specified variable name is the name of another existing variable.
\item The specified type is not a valid net\+C\+DF type.
\item The specified number of dimensions is negative or more than the constant N\+F\+\_\+\+M\+A\+X\+\_\+\+V\+A\+R\+\_\+\+D\+I\+MS, the maximum number of dimensions permitted for a net\+C\+DF variable.
\item One or more of the dimension I\+Ds in the list of dimensions is not a valid dimension ID for the net\+C\+DF dataset.
\item The number of variables would exceed the constant N\+F\+\_\+\+M\+A\+X\+\_\+\+V\+A\+RS, the maximum number of variables permitted in a net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR to create a variable named rh of type double with three dimensions, time, lat, and lon in a new net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER L\+A\+T\+D\+IM, L\+O\+N\+D\+IM, T\+I\+M\+D\+IM ! dimension I\+Ds I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER R\+H\+D\+I\+M\+S(3) ! variable shape ... S\+T\+A\+T\+US = N\+F\+\_\+\+C\+R\+E\+A\+TE (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! define dimensions S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM(N\+C\+ID, \textquotesingle{}lat\textquotesingle{}, 5, L\+A\+T\+D\+IM) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM(N\+C\+ID, \textquotesingle{}lon\textquotesingle{}, 10, L\+O\+N\+D\+IM) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM(N\+C\+ID, \textquotesingle{}time\textquotesingle{}, N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED, T\+I\+M\+D\+IM) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! define variable R\+H\+D\+I\+M\+S(1) = L\+O\+N\+D\+IM R\+H\+D\+I\+M\+S(2) = L\+A\+T\+D\+IM R\+H\+D\+I\+M\+S(3) = T\+I\+M\+D\+IM S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, N\+F\+\_\+\+D\+O\+U\+B\+LE, 3, R\+H\+D\+I\+MS, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+4 Define Chunking Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+NG} }

The function N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+NG sets the storage parameters for a variable in a net\+C\+D\+F-\/4 file. It can set the chunk sizes to get chunked storage, or it can set the contiguous flag to get contiguous storage.

Variables that make use of one or more unlimited dimensions, compression, or checms must use chunking. Such variables are created with default chunk sizes of 1 for each unlimited dimension and the dimension length for other dimensions, except that if the rlting chunks are too large, the default chunk sizes for non-\/record dimensions are reduced.

The total size of a chunk must be less than 4 GiB. That is, the product of all chunksizes and the size of the data (or the size of nc\+\_\+vlen\+\_\+t for V\+L\+EN types) must be less than 4 GiB.

This function may only be called after the variable is defined, but before nc\+\_\+enddef is called. Once the chunking parameters are set for a variable, they cannot be changed. This function can be used to change the default chunking for record, compressed, or checmmed variables before nc\+\_\+enddef is called.

Note that you cannot set chunking for scalar variables. Only non-\/scalar variables can have chunking.

\subsection*{Usage }

 

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+N\+G(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R S\+T\+O\+R\+A\+G\+E, I\+N\+T\+E\+G\+E\+R C\+H\+U\+N\+K\+S\+I\+Z\+E\+S)

{\ttfamily ncid} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid} \+: Variable ID.

{\ttfamily storage} \+: If N\+F\+\_\+\+C\+O\+N\+T\+I\+G\+U\+O\+US, then contiguous storage is used for this variable. Variables with compression, shuffle filter, checms, or one or more unlimited dimensions cannot use contiguous storage. If contiguous storage is turned on, the chunksizes parameter is ignored.

If N\+F\+\_\+\+C\+H\+U\+N\+K\+ED, then chunked storage is used for this variable. Chunk sizes may be specified with the chunksizes parameter. Default sizes will be used if chunking is required and this function is not called.

By default contiguous storage is used for fix-\/sized variables when conpression, chunking, checms, or endianness control are not used.

{\ttfamily chunksizes} \+: An array of chunk sizes. The array must have the one chunksize for each dimension in the variable. If contiguous storage is used, then the chunksizes parameter is ignored.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+NG returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: Invalid input. This can occur when the user attempts to set contiguous storage for a variable with compression or checms, or one or more unlimited dimensions.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

{\ttfamily N\+F\+\_\+\+E\+L\+A\+T\+E\+D\+EF} \+: This variable has already been thebject of a N\+F\+\_\+\+E\+N\+D\+D\+EF call. In net\+C\+D\+F-\/4 files N\+F\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write. Once enddef has been called, it is impossible to set the chunking for a variable.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag. (see \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily N\+F\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3} \+: Trying to create a var some place other than the root group in a net\+C\+DF file with N\+F\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 turned on.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+F, a file is created, two dimensions and a variable are defined, and the chunksizes of the data are set to the size of the data (that is, data will be written in one chunk).

 

C Create the net\+C\+DF file. retval = nf\+\_\+create(\+F\+I\+L\+E\+\_\+\+N\+A\+M\+E, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, ncid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the dimensions. retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}x\char`\"{}, NX, x\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}y\char`\"{}, NY, y\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the variable. dimids(1) = y\+\_\+dimid dimids(2) = x\+\_\+dimid retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR(ncid, \char`\"{}data\char`\"{}, N\+F\+\_\+\+I\+NT, N\+D\+I\+MS, dimids, varid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Turn on chunking. chunks(1) = NY chunks(2) = NX retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+chunking(ncid, varid, N\+F\+\_\+\+C\+H\+U\+N\+K\+E\+D, chunks) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{6.\+5 Learn About Chunking Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+NG} }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+NG returns the chunking settings for a variable in a net\+C\+D\+F-\/4 file.

\subsection*{Usage }

 

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+N\+G(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R S\+T\+O\+R\+A\+G\+E, I\+N\+T\+E\+G\+E\+R C\+H\+U\+N\+K\+S\+I\+Z\+E\+S);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+O\+R\+A\+GE} \+: On return, set to N\+F\+\_\+\+C\+O\+N\+T\+I\+G\+U\+O\+US if this variable uses contiguous storage, N\+F\+\_\+\+C\+H\+U\+N\+K\+ED if it uses chunked storage.

{\ttfamily C\+H\+U\+N\+K\+S\+I\+Z\+ES} \+: An array of chunk sizes. The length of C\+H\+U\+N\+K\+S\+I\+Z\+ES must be the same as the number of dimensions of the variable.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+NG returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+F, a variable with chunked storage is checked to ere that the chunksizes are set to expected values.

 

C Is everything set that ispposed to be? retval = nf\+\_\+inq\+\_\+var\+\_\+chunking(ncid, varid, storage, chunks\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (storage .ne. N\+F\+\_\+\+C\+H\+U\+N\+K\+ED) stop 2 if (chunks(1) .ne. chunks\+\_\+in(1)) stop 2 if (chunks(2) .ne. chunks\+\_\+in(2)) stop 2

\subsection*{6.\+6 Set H\+D\+F5 Chunk Cache for a Variable\+: N\+F\+\_\+\+S\+E\+T\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+HE }

This function changes the chunk cache settings for a variable. The change in cache size happens immediately. This is a property of the open file -\/ it does not persist the next time you open the file.

For more information, see the documentation for the H5\+Pset\+\_\+cache() function in the H\+D\+F5 library at the H\+D\+F5 website\+: \href{http://hdfgroup.org/HDF5/}{\tt http\+://hdfgroup.\+org/\+H\+D\+F5/}.

\subsection*{Usage }

 

N\+F\+\_\+\+S\+E\+T\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+HE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+I\+ZE, I\+N\+T\+E\+G\+ER N\+E\+L\+E\+MS, I\+N\+T\+E\+G\+ER P\+R\+E\+E\+M\+P\+T\+I\+ON);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to nc\+\_\+open or nc\+\_\+create.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+I\+ZE} \+: The total size of the raw data chunk cache, in megabytes. This should be big enough to hold multiple chunks of data. (Note that the C A\+PI uses bytes, but the Fortran A\+P\+Is uses megabytes to avoid numbers that can’t fit in 4-\/byte integers.)

{\ttfamily N\+E\+L\+E\+MS} \+: The number of chunk slots in the raw data chunk cache hash table. This should be a prime number larger than the number of chunks that will be in the cache.

{\ttfamily P\+R\+E\+E\+M\+P\+T\+I\+ON} \+: The preemption value must be between 0 and 100 inclusive and indicates the degreee to which chunks that have been fully read are favored for kicking out of the chunk cache, when needed. A value of zero means fully read chunks are treated no differently than other chunks (the preemption is strictly Least Recently Used) while a value of 100 means fully read chunks are always preempted before other chunks. (The C A\+PI uses a float between 0 and 1 for this value).

\subsection*{Return Codes }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: Preemption must be between zero and 100 (inclusive).

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars2.\+F\+:

 

\begin{DoxyVerb}  include 'netcdf.inc'
\end{DoxyVerb}
 ... C These will be used to set the per-\/variable chunk cache. integer C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE, C\+A\+C\+H\+E\+\_\+\+N\+E\+L\+E\+MS, C\+A\+C\+H\+E\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON parameter (C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE = 8, C\+A\+C\+H\+E\+\_\+\+N\+E\+L\+E\+MS = 571) parameter (C\+A\+C\+H\+E\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON = 42) ... C Set variable caches. retval = nf\+\_\+set\+\_\+var\+\_\+chunk\+\_\+cache(ncid, varid(i), C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE, \& C\+A\+C\+H\+E\+\_\+\+N\+E\+L\+E\+MS, C\+A\+C\+H\+E\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{6.\+7 Get the H\+D\+F5 Chunk Cache Settings for a variable\+: N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+HE }

This function gets the current chunk cache settings for a variable in a net\+C\+D\+F-\/4/\+H\+D\+F5 file.

For more information, see the documentation for the H5\+Pget\+\_\+cache() function in the H\+D\+F5 library at the H\+D\+F5 website\+: \href{http://hdfgroup.org/HDF5/}{\tt http\+://hdfgroup.\+org/\+H\+D\+F5/}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+\_\+\+C\+A\+C\+HE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+I\+ZE, I\+N\+T\+E\+G\+ER N\+E\+L\+E\+MS, I\+N\+T\+E\+G\+ER P\+R\+E\+E\+M\+P\+T\+I\+ON);

{\ttfamily ncid} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid} \+: Variable ID.

{\ttfamily sizep} \+: The total size of the raw data chunk cache, in megabytes, will be put here.

{\ttfamily nelemsp} \+: The number of chunk slots in the raw data chunk cache hash table will be put here.

{\ttfamily preemptionp} \+: The preemption will be put here. The preemtion value is between 0 and 100 inclusive and indicates how much chunks that have been fully read are favored for preemption. A value of zero means fully read chunks are treated no differently than other chunks (the preemption is strictly L\+RU) while a value of 100 means fully read chunks are always preempted before other chunks.

\subsection*{Return Codes }

{\ttfamily N\+C\+\_\+\+N\+O\+E\+RR} \+: No error.

\subsection*{Example }

This example is from nf\+\_\+test/ftst\+\_\+vars2.\+c\+:

 

\begin{DoxyVerb}  include 'netcdf.inc'
\end{DoxyVerb}
 ... C These will be used to set the per-\/variable chunk cache. integer C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE, C\+A\+C\+H\+E\+\_\+\+N\+E\+L\+E\+MS, C\+A\+C\+H\+E\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON parameter (C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE = 8, C\+A\+C\+H\+E\+\_\+\+N\+E\+L\+E\+MS = 571) parameter (C\+A\+C\+H\+E\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON = 42)

C These will be used to check the setting of the per-\/variable chunk C cache. integer cache\+\_\+size\+\_\+in, cache\+\_\+nelems\+\_\+in, cache\+\_\+preemption\+\_\+in

... retval = nf\+\_\+get\+\_\+var\+\_\+chunk\+\_\+cache(ncid, varid(i), cache\+\_\+size\+\_\+in, \& cache\+\_\+nelems\+\_\+in, cache\+\_\+preemption\+\_\+in) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (cache\+\_\+size\+\_\+in .ne. C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE .or. cache\+\_\+nelems\+\_\+in .ne. \& C\+A\+C\+H\+E\+\_\+\+N\+E\+L\+E\+MS .or. cache\+\_\+preemption .ne. C\+A\+C\+H\+E\+\_\+\+P\+R\+E\+E\+M\+P\+T\+I\+ON) \& stop 8

\subsection*{6.\+8 Define Fill Parameters for a Variable\+: {\ttfamily nf\+\_\+def\+\_\+var\+\_\+fill} }

The function N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+I\+LL sets the fill parameters for a variable in a net\+C\+D\+F-\/4 file.

This function must be called after the variable is defined, but before N\+F\+\_\+\+E\+N\+D\+D\+EF is called.

\subsection*{Usage }

 

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+I\+L\+L(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R N\+O\+\_\+\+F\+I\+L\+L, F\+I\+L\+L\+\_\+\+V\+A\+L\+U\+E);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily N\+O\+\_\+\+F\+I\+LL} \+: Set to non-\/zero value to set no\+\_\+fill mode on a variable. When this mode is on, fill values will not be written for the variable. This is helpful in high performance applications. For net\+C\+D\+F-\/4/\+H\+D\+F5 files (whether classic model or not), this may only be changed after the variable is defined, but before it is committed to disk (i.\+e. before the first N\+F\+\_\+\+E\+N\+D\+D\+EF after the N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR.) For classic and 64-\/bit offset file, the no\+\_\+fill mode may be turned on and off at any time.

{\ttfamily F\+I\+L\+L\+\_\+\+V\+A\+L\+UE} \+: A value which will be used as the fill value for the variable. Must be the same type as the variable. This will be written to a \+\_\+\+Fill\+Value attribute, created for this purpose. If N\+U\+LL, this argument will be ignored.

\subsection*{Return Codes }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

{\ttfamily N\+F\+\_\+\+E\+L\+A\+T\+E\+D\+EF} \+: This variable has already been thebject of a N\+F\+\_\+\+E\+N\+D\+D\+EF call. In net\+C\+D\+F-\/4 files N\+F\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write. Once enddef has been called, it is impossible to set the fill for a variable.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag. (see \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to create object in read-\/only file.

\subsection*{Example }

\subsection*{6.\+9 Learn About Fill Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+I\+LL} }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+I\+LL returns the fill settings for a variable in a net\+C\+D\+F-\/4 file.

\subsection*{Usage }

 

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+I\+L\+L(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R N\+O\+\_\+\+F\+I\+L\+L, F\+I\+L\+L\+\_\+\+V\+A\+L\+U\+E)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily N\+O\+\_\+\+F\+I\+LL} \+: An integer which will get a 1 if no\+\_\+fill mode is set for this variable, and a zero if it is not set

{\ttfamily F\+I\+L\+L\+\_\+\+V\+A\+L\+UE} \+: This will get the fill value for this variable. This parameter will be ignored if it is N\+U\+LL.

\subsection*{Return Codes }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

\subsection*{Example }

\subsection*{6.\+10 Define Compression Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE} }

The function N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE sets the deflate parameters for a variable in a net\+C\+D\+F-\/4 file.

When using parallel I/O for writing data, deflate cannot be used. This is because the compression makes it impossible for the H\+D\+F5 library to exactly map the data to disk location.

(Deflated data can be read with parallel I/O).

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE must be called after the variable is defined, but before N\+F\+\_\+\+E\+N\+D\+D\+EF is called.

\subsection*{Usage }

 

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+H\+U\+F\+F\+LE, I\+N\+T\+E\+G\+ER D\+E\+F\+L\+A\+TE, I\+N\+T\+E\+G\+ER D\+E\+F\+L\+A\+T\+E\+\_\+\+L\+E\+V\+EL);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+H\+U\+F\+F\+LE} \+: If non-\/zero, turn on the shuffle filter.

{\ttfamily D\+E\+F\+L\+A\+TE} \+: If non-\/zero, turn on the deflate filter at the level specified by the deflate\+\_\+level parameter.

{\ttfamily D\+E\+F\+L\+A\+T\+E\+\_\+\+L\+E\+V\+EL} \+: Must be between 0 (no deflate, the default) and 9 (slowest, but “best” deflate).

If set to zero, no deflation takes place and the def\+\_\+var\+\_\+deflate call is ignored. This is slightly different from H\+D\+F5 handing of 0 deflate, which turns on the filter but makes only trivial changes to the data.

Informal testing at Net\+C\+DF World Headquartersggests that there is little to be gained (with the limited set of test data used here), in setting the deflate level above 2 or 3.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

{\ttfamily N\+F\+\_\+\+E\+L\+A\+T\+E\+D\+EF} \+: This variable has already been thebject of a N\+F\+\_\+\+E\+N\+D\+D\+EF call. In net\+C\+D\+F-\/4 files N\+F\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write. Once enddef has been called, it is impossible to set the deflate for a variable.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag. (see \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to create object in read-\/only file.

{\ttfamily N\+F\+\_\+\+E\+I\+N\+V\+AL} \+: Invalid deflate\+\_\+level. The deflate level must be between 0 and 9, inclusive.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+F, a file is created with two dimensions and one variable. Chunking, deflate, and the fletcher32 filter are turned on. The deflate level is set to 4 below.

 

C Create the net\+C\+DF file. retval = nf\+\_\+create(\+F\+I\+L\+E\+\_\+\+N\+A\+M\+E, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, ncid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the dimensions. retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}x\char`\"{}, NX, x\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}y\char`\"{}, NY, y\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the variable. dimids(1) = y\+\_\+dimid dimids(2) = x\+\_\+dimid retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR(ncid, \char`\"{}data\char`\"{}, N\+F\+\_\+\+I\+NT, N\+D\+I\+MS, dimids, varid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Turn on chunking. chunks(1) = NY chunks(2) = NX retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+N\+G(ncid, varid, N\+F\+\_\+\+C\+H\+U\+N\+K\+E\+D, chunks) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Turn on deflate compression, fletcher32 checm. retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+deflate(ncid, varid, 0, 1, 4) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32(ncid, varid, N\+F\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{6.\+11 Learn About Deflate Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE} }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE returns the deflate settings for a variable in a net\+C\+D\+F-\/4 file.

It is not necessary to know the deflate settings to read the variable. (Deflate is completely transparent to readers of the data).

\subsection*{Usage }

 

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+H\+U\+F\+F\+LE, I\+N\+T\+E\+G\+ER D\+E\+F\+L\+A\+TE, I\+N\+T\+E\+G\+ER D\+E\+F\+L\+A\+T\+E\+\_\+\+L\+E\+V\+EL);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+H\+U\+F\+F\+LE} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE will set this to a 1 if the shuffle filter is turned on for this variable, and a 0 otherwise.

{\ttfamily D\+E\+F\+L\+A\+TE} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE will set this to a 1 if the deflate filter is turned on for this variable, and a 0 otherwise.

{\ttfamily D\+E\+F\+L\+A\+T\+E\+\_\+\+L\+E\+V\+EL} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE function will write the deflate\+\_\+level here, if deflate is in use.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+TE returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

\subsection*{Example }

In this example code from nf\+\_\+test/ftst\+\_\+vars.\+F, a file with a variable using deflate is opened, and the deflate level checked.

 

C Is everything set that ispposed to be? retval = nf\+\_\+inq\+\_\+var\+\_\+deflate(ncid, varid, shuffle, deflate,
\begin{DoxyItemize}
\item deflate\+\_\+level) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) if (shuffle .ne. 0 .or. deflate .ne. 1 .or.
\item deflate\+\_\+level .ne. 4) stop 2
\end{DoxyItemize}

\subsection*{6.\+12 Learn About Szip Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+S\+Z\+IP} }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+S\+Z\+IP returns the szip settings for a variable in a net\+C\+D\+F-\/4 file.

It is not necessary to know the szip settings to read the variable. (Szip is completely transparent to readers of the data).

\subsection*{Usage }

 

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+S\+Z\+IP(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER O\+P\+T\+I\+O\+N\+\_\+\+M\+A\+SK, P\+I\+X\+E\+L\+S\+\_\+\+P\+E\+R\+\_\+\+B\+L\+O\+CK);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily O\+P\+T\+I\+O\+N\+\_\+\+M\+A\+SK} \+: This will be set to the option\+\_\+mask value.

{\ttfamily P\+I\+X\+E\+L\+S\+\_\+\+P\+E\+R\+\_\+\+B\+L\+O\+CK} \+: The number of bits per pixel will be put here.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+S\+Z\+IP returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

\subsection*{6.\+13 Define Checm Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32} }

The function N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32 sets the checm property for a variable in a net\+C\+D\+F-\/4 file.

This function may only be called after the variable is defined, but before N\+F\+\_\+\+E\+N\+D\+D\+EF is called.

\subsection*{Usage }

 

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R C\+H\+E\+C\+K\+S\+U\+M);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily C\+H\+E\+C\+K\+S\+UM} \+: If this is N\+F\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32, fletcher32 checms will be turned on for this variable.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32 returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

{\ttfamily N\+F\+\_\+\+E\+L\+A\+T\+E\+D\+EF} \+: This variable has already been thebject of a N\+F\+\_\+\+E\+N\+D\+D\+EF call. In net\+C\+D\+F-\/4 files N\+F\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write. Once enddef has been called, it is impossible to set the checm property for a variable.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag. (see \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to create object in read-\/only file.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+F, the variable in a file has the Fletcher32 checm filter turned on.

 

C Create the net\+C\+DF file. retval = nf\+\_\+create(\+F\+I\+L\+E\+\_\+\+N\+A\+M\+E, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, ncid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the dimensions. retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}x\char`\"{}, NX, x\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}y\char`\"{}, NY, y\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the variable. dimids(1) = y\+\_\+dimid dimids(2) = x\+\_\+dimid retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR(ncid, \char`\"{}data\char`\"{}, N\+F\+\_\+\+I\+NT, N\+D\+I\+MS, dimids, varid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Turn on chunking. chunks(1) = NY chunks(2) = NX retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+C\+H\+U\+N\+K\+I\+N\+G(ncid, varid, N\+F\+\_\+\+C\+H\+U\+N\+K\+E\+D, chunks) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Turn on deflate compression, fletcher32 checms. retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+D\+E\+F\+L\+A\+T\+E(ncid, varid, 0, 1, 4) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32(ncid, varid, N\+F\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{6.\+14 Learn About Checm Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32} }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32 returns the checm settings for a variable in a net\+C\+D\+F-\/4 file.

\subsection*{Usage }

 

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R C\+H\+E\+C\+K\+S\+U\+M);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily C\+H\+E\+C\+K\+S\+UM} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32 will set this to N\+F\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32 if the fletcher32 filter is turned on for this variable, and N\+F\+\_\+\+N\+O\+C\+H\+E\+C\+K\+S\+UM if it is not.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32 returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+F the checm filter is checked for a file. Since it was turned on for this variable, the checm variable is set to N\+F\+\_\+\+F\+L\+E\+T\+C\+H\+E\+R32.

 

\begin{DoxyVerb}  retval = nf_inq_var_fletcher32(ncid, varid, checm)
  if (retval .ne. nf_noerr) call handle_err(retval)
  if (checm .ne. NF_FLETCHER32) stop 2
\end{DoxyVerb}


\subsection*{6.\+15 Define Endianness of a Variable\+: {\ttfamily N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN} }

The function N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN sets the endianness for a variable in a net\+C\+D\+F-\/4 file.

This function must be called after the variable is defined, but before N\+F\+\_\+\+E\+N\+D\+D\+EF is called.

By default, net\+C\+D\+F-\/4 variables are in native endianness. That is, they are big-\/endian on a big-\/endian machine, and little-\/endian on a little endian machine.

In some cases a user might wish to change from native endianness to either big or little-\/endianness. This function allows them to do that.

\subsection*{Usage }

 

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+A\+N(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R E\+N\+D\+I\+A\+N)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily E\+N\+D\+I\+AN} \+: Set to N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+N\+A\+T\+I\+VE for native endianness. (This is the default). Set to N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+L\+I\+T\+T\+LE for little endian, or N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+IG for big endian.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

{\ttfamily N\+F\+\_\+\+E\+L\+A\+T\+E\+D\+EF} \+: This variable has already been thebject of a N\+F\+\_\+\+E\+N\+D\+D\+EF call. In net\+C\+D\+F-\/4 files N\+F\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write. Once enddef has been called, it is impossible to set the endianness of a variable.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE} \+: Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag, and the file is not in define mode. (see \href{#NF_005fCREATE}{\tt N\+F\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily N\+F\+\_\+\+E\+P\+E\+RM} \+: Attempt to create object in read-\/only file.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+c, a file is created with one variable, and its endianness is set to N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+IG.

 

C Create the net\+C\+DF file. retval = nf\+\_\+create(\+F\+I\+L\+E\+\_\+\+N\+A\+M\+E, N\+F\+\_\+\+N\+E\+T\+C\+D\+F4, ncid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the dimensions. retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}x\char`\"{}, NX, x\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval) retval = nf\+\_\+def\+\_\+dim(ncid, \char`\"{}y\char`\"{}, NY, y\+\_\+dimid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Define the variable. dimids(1) = y\+\_\+dimid dimids(2) = x\+\_\+dimid retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR(ncid, \char`\"{}data\char`\"{}, N\+F\+\_\+\+I\+NT, N\+D\+I\+MS, dimids, varid) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Turn on chunking. chunks(1) = NY chunks(2) = NX retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+chunking(ncid, varid, 0, chunks) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

C Set variable to big-\/endian (default is whatever is native to C writing machine). retval = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+endian(ncid, varid, N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+I\+G) if (retval .ne. nf\+\_\+noerr) call handle\+\_\+err(retval)

\subsection*{6.\+16 Learn About Endian Parameters for a Variable\+: {\ttfamily N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN} }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN returns the endianness settings for a variable in a net\+C\+D\+F-\/4 file.

\subsection*{Usage }

 

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+A\+N(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R E\+N\+D\+I\+A\+N)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily E\+N\+D\+I\+AN} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN will set this to N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+L\+I\+T\+T\+LE if this variable is stored in little-\/endian format, N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+IG if it is stored in big-\/endian format, and N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+N\+A\+T\+I\+VE if the endianness is not set, and the variable is not created yet.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+E\+N\+D\+I\+AN returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.

Possible return codes include\+:

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+B\+A\+D\+ID} \+: Bad ncid.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: Can’t find this variable.

\subsection*{Example }

In this example from nf\+\_\+test/ftst\+\_\+vars.\+F, the endianness of a variable is checked to makere it is N\+F\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+IG.

 

\begin{DoxyVerb}  retval = nf_inq_var_endian(ncid, varid, endianness)
  if (retval .ne. nf_noerr) call handle_err(retval)
  if (endianness .ne. NF_ENDIAN_BIG) stop 2
\end{DoxyVerb}


\subsection*{6.\+17 Get a Variable ID from Its Name\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID }

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID returns the ID of a net\+C\+DF variable, given its name.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID(I\+N\+T\+E\+G\+ER N\+C\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER varid)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily N\+A\+ME} \+: Variable name for which ID is desired.

{\ttfamily varid} \+: Returned variable ID.

\subsection*{Errors }

N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified variable name is not a valid name for a variable in the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID to find out the ID of a variable named rh in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID, R\+H\+ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+18 Get Information about a Variable from Its ID\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR family }

A family of functions that returns information about a net\+C\+DF variable, given its ID. Information about a variable includes its name, type, number of dimensions, a list of dimension I\+Ds describing the shape of the variable, and the number of variable attributes that have been assigned to the variable.

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR returns all the information about a net\+C\+DF variable, given its ID. The other functions each return just one item of information about a variable.

These other functions include N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+A\+ME, N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+T\+Y\+PE, N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+D\+I\+MS, N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+D\+I\+M\+ID, and N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+A\+T\+TS.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) name, I\+N\+T\+E\+G\+ER xtype, I\+N\+T\+E\+G\+ER ndims, I\+N\+T\+E\+G\+ER dimids($\ast$), I\+N\+T\+E\+G\+ER natts) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+A\+ME (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) name) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+T\+Y\+PE (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER xtype) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+D\+I\+MS (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER ndims) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+D\+I\+M\+ID (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER dimids($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+A\+T\+TS (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER natts)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily N\+A\+ME} \+: Returned variable name. The caller must allocate space for the returned name. The maximum possible length, in characters, of a variable name is given by the predefined constant N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily xtype} \+: Returned variable type, one of the set of predefined net\+C\+DF external data types. The type of this parameter, N\+F\+\_\+\+T\+Y\+PE, is defined in the net\+C\+DF header file. The valid net\+C\+DF external data types are N\+F\+\_\+\+B\+Y\+TE, N\+F\+\_\+\+C\+H\+AR, N\+F\+\_\+\+S\+H\+O\+RT, N\+F\+\_\+\+I\+NT, N\+F\+\_\+\+F\+L\+O\+AT, A\+ND N\+F\+\_\+\+D\+O\+U\+B\+LE.

{\ttfamily ndims} \+: Returned number of dimensions the variable was defined as using. For example, 2 indicates a matrix, 1 indicates a vector, and 0 means the variable is a scalar with no dimensions.

{\ttfamily dimids} \+: Returned vector of $\ast$ndimsp dimension I\+Ds corresponding to the variable dimensions. The caller must allocate enough space for a vector of at least $\ast$ndimsp integers to be returned. The maximum possible number of dimensions for a variable is given by the predefined constant N\+F\+\_\+\+M\+A\+X\+\_\+\+V\+A\+R\+\_\+\+D\+I\+MS.

{\ttfamily natts} \+: Returned number of variable attributes assigned to this variable.

These functions return the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR to find out about a variable named rh in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$31 R\+H\+N\+A\+ME ! variable name I\+N\+T\+E\+G\+ER R\+H\+T\+Y\+PE ! variable type I\+N\+T\+E\+G\+ER R\+HN ! number of dimensions I\+N\+T\+E\+G\+ER R\+H\+D\+I\+M\+S(\+N\+F\+\_\+\+M\+A\+X\+\_\+\+V\+A\+R\+\_\+\+D\+I\+M\+S) ! variable shape I\+N\+T\+E\+G\+ER R\+H\+N\+A\+TT ! number of attributes ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) ! get ID IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+AR (N\+C\+ID, R\+H\+ID, R\+H\+N\+A\+ME, R\+H\+T\+Y\+PE, R\+HN, R\+H\+D\+I\+MS, R\+H\+N\+A\+TT) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+19 Write a Single Data Value\+: N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+ type }

The functions N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+type (for various types) put a single data value of the specified type into a variable of an open net\+C\+DF dataset that is in data mode. Inputs are the net\+C\+DF ID, the variable ID, an index that specifies which value to add or alter, and the data value. The value is converted to the external data type of the variable, if necessary.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+T\+E\+XT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), C\+H\+A\+R\+A\+C\+T\+ER C\+H\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+I\+N\+T1(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+I\+N\+T2(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), I\+N\+T\+E\+G\+ER I\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+R\+E\+AL(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), R\+E\+AL R\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), D\+O\+U\+B\+LE D\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), $\ast$)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily I\+N\+D\+EX} \+: The index of the data value to be written. The indices are relative to 1, so for example, the first data value of a two-\/dimensional variable would have index (1,1). The elements of index must correspond to the variable’s dimensions. Hence, if the variable uses the unlimited dimension, the last index would correspond to the record number.

{\ttfamily C\+H\+V\+AL}\textbackslash{} {\ttfamily I1\+V\+AL}\textbackslash{} {\ttfamily I2\+V\+AL}\textbackslash{} {\ttfamily I\+V\+AL}\textbackslash{} {\ttfamily R\+V\+AL}\textbackslash{} {\ttfamily D\+V\+AL} \+: Pointer to the data value to be written. If the type of data values differs from the net\+C\+DF variable type, type conversion will occur. See \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide.

\subsection*{Errors }

N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified indices were out of range for the rank of the specified variable. For example, a negative index or an index that is larger than the corresponding dimension length will cause an error.
\item The specified value is out of the range of values representable by the external data type of the variable.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+D\+O\+U\+B\+LE to set the (4,3,2) element of the variable named rh to 0.\+5 in an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we ame that we know that rh is dimensioned with lon, lat, and time, so we want to set the value of rh that corresponds to the fourth lon value, the third lat value, and the second time value\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! error status I\+N\+T\+E\+G\+ER N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER R\+H\+I\+N\+D\+X(3) ! where to put value D\+A\+TA R\+H\+I\+N\+DX /4, 3, 2/ ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) ! get ID IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, R\+H\+I\+N\+DX, 0.\+5) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+20 Write an Entire Variable\+: N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+ type }

The N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+ type family of functions write all the values of a variable into a net\+C\+DF variable of an open net\+C\+DF dataset. This is the simplest interface to use for writing a value in a scalar variable or whenever all the values of a multidimensional variable can all be written at once. The values to be written are associated with the net\+C\+DF variable by aming that the last dimension of the net\+C\+DF variable varies fastest in the C interface. The values are converted to the external data type of the variable, if necessary.

Take care when using the simplest forms of this interface with record variables (variables that use the N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension) when you don’t specify how many records are to be written. If you try to write all the values of a record variable into a net\+C\+DF file that has no record data yet (hence has 0 records), nothing will be written. Similarly, if you try to write all the values of a record variable from an array but there are more records in the file than you ame, more in-\/memory data will be accessed than you expect, which may cause a segmentation violation. To avoidch problems, it is better to use the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+type interfaces for variables that use the N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension. See \href{#NF_005fPUT_005fVARA_005f-type}{\tt Write an Array of Values\+: N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+ type}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) T\+E\+XT) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, R\+E\+AL R\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, D\+O\+U\+B\+LE D\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+AR (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, V\+A\+L\+S($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS}\textbackslash{} {\ttfamily V\+A\+LS} \+: The block of data values to be written. The data should be of the type appropriate for the function called. You cannot put C\+H\+A\+R\+A\+C\+T\+ER data into a numeric variable or numeric data into a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide). The order in which the data will be written into the specified variable is with the first dimension varying fastest (like the ordinary F\+O\+R\+T\+R\+AN convention).

\subsection*{Errors }

Members of the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+ type family return the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item One or more of the specified values are out of the range of values representable by the external data type of the variable.
\item One or more of the specified values are out of the range of values representable by the external data type of the variable.
\item The specified net\+C\+DF dataset is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+D\+O\+U\+B\+LE to add or change all the values of the variable named rh to 0.\+5 in an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we ame that we know that rh is dimensioned with lon and lat, and that there are ten lon values and five lat values.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (L\+A\+TS=5, L\+O\+NS=10) ! dimension lengths I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID D\+O\+U\+B\+LE R\+H\+V\+A\+L\+S(\+L\+O\+N\+S, L\+A\+T\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) DO 10 I\+L\+ON = 1, L\+O\+NS DO 10 I\+L\+AT = 1, L\+A\+TS R\+H\+V\+A\+L\+S(\+I\+L\+O\+N, I\+L\+A\+T) = 0.\+5 10 C\+O\+N\+T\+I\+N\+UE S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+var\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, R\+H\+V\+A\+LS) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+21 Write an Array of Values\+: N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+ type }

The function N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+ type writes values into a net\+C\+DF variable of an open net\+C\+DF dataset. The part of the net\+C\+DF variable to write is specified by giving a corner and a vector of edge lengths that refer to an array of the net\+C\+DF variable. The values to be written are associated with the net\+C\+DF variable by aming that the first dimension of the net\+C\+DF variable varies fastest in the F\+O\+R\+T\+R\+AN interface. The net\+C\+DF dataset must be in data mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+T\+E\+XT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) T\+E\+XT) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+I\+N\+T1(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+I\+N\+T2(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER I\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+R\+E\+AL(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), R\+E\+AL R\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), D\+O\+U\+B\+LE D\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RA (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), V\+A\+L\+S($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+A\+RT} \+: A vector of integers specifying the index in the variable where the first of the data values will be written. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The length of S\+T\+A\+RT must be the same as the number of dimensions of the specified variable. The elements of S\+T\+A\+RT must correspond to the variable’s dimensions in order. Hence, if the variable is a record variable, the last index would correspond to the starting record number for writing the data values.

{\ttfamily C\+O\+U\+NT} \+: A vector of integers specifying the edge lengths along each dimension of the block of data values to written. To write a single value, for example, specify C\+O\+U\+NT as (1, 1, ..., 1). The length of C\+O\+U\+NT is the number of dimensions of the specified variable. The elements of C\+O\+U\+NT correspond to the variable’s dimensions. Hence, if the variable is a record variable, the last element of C\+O\+U\+NT corresponds to a count of the number of records to write.

Note\+: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS}\textbackslash{} {\ttfamily V\+A\+LS} \+: The block of data values to be written. The data should be of the type appropriate for the function called. You cannot put C\+H\+A\+R\+A\+C\+T\+ER data into a numeric variable or numeric data into a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
\item The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
\item One or more of the specified values are out of the range of values representable by the external data type of the variable.
\item The specified net\+C\+DF dataset is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+LE to add or change all the values of the variable named rh to 0.\+5 in an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we ame that we know that rh is dimensioned with time, lat, and lon, and that there are three time values, five lat values, and ten lon values.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+I\+MS=3) ! number of dimensions P\+A\+R\+A\+M\+E\+T\+ER (T\+I\+M\+ES=3, L\+A\+TS=5, L\+O\+NS=10) ! dimension lengths I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID, T\+I\+M\+ES I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M\+S), C\+O\+U\+N\+T(\+N\+D\+I\+M\+S) D\+O\+U\+B\+LE R\+H\+V\+A\+L\+S(\+L\+O\+N\+S, L\+A\+T\+S, T\+I\+M\+E\+S) D\+A\+TA S\+T\+A\+RT /1, 1, 1/ ! start at first value D\+A\+TA C\+O\+U\+NT /\+L\+O\+NS, L\+A\+TS, T\+I\+M\+E\+S/ ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) DO 10 I\+L\+ON = 1, L\+O\+NS DO 10 I\+L\+AT = 1, L\+A\+TS DO 10 I\+T\+I\+ME = 1, T\+I\+M\+ES R\+H\+V\+A\+L\+S(\+I\+L\+O\+N, I\+L\+A\+T, I\+T\+I\+M\+E) = 0.\+5 10 C\+O\+N\+T\+I\+N\+UE S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, S\+T\+A\+RT, C\+O\+U\+NT, R\+H\+V\+A\+LS) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+22 N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+ type }

Each member of the family of functions N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+ type writes a subsampled (strided) array of values into a net\+C\+DF variable of an open net\+C\+DF dataset. Thebsampled array is specified by giving a corner, a vector of counts, and a stride vector. The net\+C\+DF dataset must be in data mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$),C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) T\+E\+XT) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$),I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$),I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), R\+E\+AL R\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), D\+O\+U\+B\+LE D\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RS (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), V\+A\+L\+S($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+A\+RT} \+: A vector of integers specifying the index in the variable where the first of the data values will be written. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The elements of S\+T\+A\+RT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for writing the data values.

{\ttfamily C\+O\+U\+NT} \+: A vector of integers specifying the number of indices selected along each dimension. To write a single value, for example, specify C\+O\+U\+NT as (1, 1, ..., 1). The elements of C\+O\+U\+NT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of C\+O\+U\+NT corresponds to a count of the number of records to write.

Note\+: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

{\ttfamily S\+T\+R\+I\+DE} \+: A vector of integers that specifies the sampling interval along each dimension of the net\+C\+DF variable. The elements of the stride vector correspond, in order, to the net\+C\+DF variable’s dimensions (S\+T\+R\+I\+D\+E(1) gives the sampling interval along the most rapidly varying dimension of the net\+C\+DF variable). Sampling intervals are specified in type-\/independent units of elements (a value of 1 selects consecutive elements of the net\+C\+DF variable along the corresponding dimension, a value of 2 selects every other element, etc.).

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS}\textbackslash{} {\ttfamily V\+A\+LS} \+: The block of data values to be written. The data should be of the type appropriate for the function called. You cannot put C\+H\+A\+R\+A\+C\+T\+ER data into a numeric variable or numeric data into a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified start, count and stride generate an index which is out of range.
\item One or more of the specified values are out of the range of values representable by the external data type of the variable.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example of using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+R\+E\+AL to write – from an internal array – every other point of a net\+C\+DF variable named rh which is described by the F\+O\+R\+T\+R\+AN declaration R\+E\+AL R\+H(6,4) (note the size of the dimensions)\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+IM=2) ! rank of net\+C\+DF variable I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF dataset ID I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! return code I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M) ! net\+C\+DF variable start point I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T(\+N\+D\+I\+M) ! size of internal array I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E(\+N\+D\+I\+M) ! net\+C\+DF variablebsampling intervals R\+E\+AL R\+H(3,2) ! notebsampled sizes for net\+C\+DF variable ! dimensions D\+A\+TA S\+T\+A\+RT /1, 1/ ! start at first net\+C\+DF variable value D\+A\+TA C\+O\+U\+NT /3, 2/ ! size of internal array\+: entire bsampled) ! net\+C\+DF variable D\+A\+TA S\+T\+R\+I\+DE /2, 2/ ! access every other net\+C\+DF element ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID(N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+S\+\_\+\+R\+E\+A\+L(\+N\+C\+I\+D, R\+H\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, S\+T\+R\+I\+D\+E, R\+H) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+23 N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+ type }

The N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+ type family of functions writes a mapped array section of values into a net\+C\+DF variable of an open net\+C\+DF dataset. The mapped array is specified by giving a corner, a vector of counts, a stride vector, and an index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a net\+C\+DF variable and the in-\/memory structure of the internal data array. No amptions are made about the ordering or length of the dimensions of the data array. The net\+C\+DF dataset must be in data mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) T\+E\+XT) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), I\+N\+T\+E\+G\+ER I\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), R\+E\+AL R\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), D\+O\+U\+B\+LE D\+V\+A\+L\+S($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+A\+RT} \+: A vector of integers specifying the index in the variable where the first of the data values will be written. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The elements of S\+T\+A\+RT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for writing the data values.

{\ttfamily C\+O\+U\+NT} \+: A vector of integers specifying the number of indices selected along each dimension. To write a single value, for example, specify C\+O\+U\+NT as (1, 1, ..., 1). The elements of C\+O\+U\+NT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of C\+O\+U\+NT corresponds to a count of the number of records to write.

Note\+: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

{\ttfamily S\+T\+R\+I\+DE} \+: A vector of integers that specifies the sampling interval along each dimension of the net\+C\+DF variable. The elements of the stride vector correspond, in order, to the net\+C\+DF variable’s dimensions (S\+T\+R\+I\+D\+E(1) gives the sampling interval along the most rapidly varying dimension of the net\+C\+DF variable). Sampling intervals are specified in type-\/independent units of elements (a value of 1 selects consecutive elements of the net\+C\+DF variable along the corresponding dimension, a value of 2 selects every other element, etc.).

{\ttfamily I\+M\+AP} \+: A vector of integers that specifies the mapping between the dimensions of a net\+C\+DF variable and the in-\/memory structure of the internal data array. The elements of the index mapping vector correspond, in order, to the net\+C\+DF variable’s dimensions (I\+M\+A\+P(1) gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the net\+C\+DF variable). Distances between elements are specified in units of elements (the distance between internal elements that occupy adjacent memory locations is 1 and not the element’s byte-\/length as in net\+C\+DF 2).

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS} \+: The data values to be written. The data should be of the type appropriate for the function called. You cannot put C\+H\+A\+R\+A\+C\+T\+ER data into a numeric variable or numeric data into a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified S\+T\+A\+RT, C\+O\+U\+NT, and S\+T\+R\+I\+DE generate an index which is out of range. Note that no error checking is possible on the imap vector.
\item One or more of the specified values are out of the range of values representable by the external data type of the variable.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

The following I\+M\+AP vector maps in the trivial way a 2x3x4 net\+C\+DF variable and an internal array of the same shape\+:

 

R\+E\+AL A(2,3,4) ! same shape as net\+C\+DF variable I\+N\+T\+E\+G\+ER I\+M\+A\+P(3) D\+A\+TA I\+M\+AP /1, 2, 6/ ! net\+C\+DF dimension inter-\/element distance ! -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- ! most rapidly varying 1 ! intermediate 2 (=I\+M\+A\+P(1)$\ast$2) ! most slowly varying 6 (=I\+M\+A\+P(2)$\ast$3)

Using the I\+M\+AP vector above with N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL obtains the same rlt as simply using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+\_\+\+R\+E\+AL.

Here is an example of using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL to write – from a transposed, internal array – a net\+C\+DF variable named rh which is described by the F\+O\+R\+T\+R\+AN declaration R\+E\+AL R\+H(4,6) (note the size and order of the dimensions)\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+IM=2) ! rank of net\+C\+DF variable I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF ID I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! return code I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M) ! net\+C\+DF variable start point I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T(\+N\+D\+I\+M) ! size of internal array I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E(\+N\+D\+I\+M) ! net\+C\+DF variablebsampling intervals I\+N\+T\+E\+G\+ER I\+M\+A\+P(\+N\+D\+I\+M) ! internal array inter-\/element distances R\+E\+AL R\+H(6,4) ! note transposition of net\+C\+DF variable dimensions D\+A\+TA S\+T\+A\+RT /1, 1/ ! start at first net\+C\+DF variable element D\+A\+TA C\+O\+U\+NT /4, 6/ ! entire net\+C\+DF variable; order corresponds ! to net\+C\+DF variable -- not internal array D\+A\+TA S\+T\+R\+I\+DE /1, 1/ ! sample every net\+C\+DF element D\+A\+TA I\+M\+AP /6, 1/ ! would be /1, 4/ if not transposing

S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID(N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+A\+L(\+N\+C\+I\+D, R\+H\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, S\+T\+R\+I\+D\+E, I\+M\+A\+P, R\+H) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

Here is another example of using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL to write – from a transposed, internal array – absample of the same net\+C\+DF variable, by writing every other point of the net\+C\+DF variable\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+IM=2) ! rank of net\+C\+DF variable I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF dataset ID I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! return code I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M) ! net\+C\+DF variable start point I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T(\+N\+D\+I\+M) ! size of internal array I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E(\+N\+D\+I\+M) ! net\+C\+DF variablebsampling intervals I\+N\+T\+E\+G\+ER I\+M\+A\+P(\+N\+D\+I\+M) ! internal array inter-\/element distances R\+E\+AL R\+H(3,2) ! note transposition of bsampled) dimensions D\+A\+TA S\+T\+A\+RT /1, 1/ ! start at first net\+C\+DF variable value D\+A\+TA C\+O\+U\+NT /2, 3/ ! order of bsampled) dimensions corresponds ! to net\+C\+DF variable -- not internal array D\+A\+TA S\+T\+R\+I\+DE /2, 2/ ! sample every other net\+C\+DF element D\+A\+TA I\+M\+AP /3, 1/ ! would be `1, 2\textquotesingle{} if not transposing ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID(N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+A\+L(\+N\+C\+I\+D, R\+H\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, S\+T\+R\+I\+D\+E, I\+M\+A\+P, R\+H) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+24 N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+ type }

The functions N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+ type get a single data value from a variable of an open net\+C\+DF dataset that is in data mode. Inputs are the net\+C\+DF ID, the variable ID, a multidimensional index that specifies which value to get, and the address of a location into which the data value will be read. The value is converted from the external data type of the variable, if necessary.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+T\+E\+XT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), C\+H\+A\+R\+A\+C\+T\+ER C\+H\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+I\+N\+T1(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+I\+N\+T2(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), I\+N\+T\+E\+G\+ER I\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+R\+E\+AL(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), R\+E\+AL R\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), D\+O\+U\+B\+LE D\+V\+AL) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER I\+N\+D\+E\+X($\ast$), V\+AL)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily I\+N\+D\+EX} \+: The index of the data value to be read. The indices are relative to 1, so for example, the first data value of a two-\/dimensional variable has index (1,1). The elements of index correspond to the variable’s dimensions. Hence, if the variable is a record variable, the last index is the record number.

{\ttfamily C\+H\+V\+AL}\textbackslash{} {\ttfamily I1\+V\+AL}\textbackslash{} {\ttfamily I2\+V\+AL}\textbackslash{} {\ttfamily I\+V\+AL}\textbackslash{} {\ttfamily R\+V\+AL}\textbackslash{} {\ttfamily D\+V\+AL}\textbackslash{} {\ttfamily V\+AL} \+: The location into which the data value will be read. You cannot get C\+H\+A\+R\+A\+C\+T\+ER data from a numeric variable or numeric data from a character variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur. (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified indices were out of range for the rank of the specified variable. For example, a negative index or an index that is larger than the corresponding dimension length will cause an error.
\item The value is out of the range of values representable by the desired data type.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+D\+O\+U\+B\+LE to get the (4,3,2) element of the variable named rh in an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we ame that we know that rh is dimensioned with lon, lat, and time, so we want to get the value of rh that corresponds to the fourth lon value, the third lat value, and the second time value\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER R\+H\+I\+N\+D\+X(3) ! where to get value D\+O\+U\+B\+LE P\+R\+E\+C\+I\+S\+I\+ON R\+H\+V\+AL ! put it here D\+A\+TA R\+H\+I\+N\+DX /4, 3, 2/ ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R1\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, R\+H\+I\+N\+DX, R\+H\+V\+AL) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+25 N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+ type }

The members of the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+ type family of functions read all the values from a net\+C\+DF variable of an open net\+C\+DF dataset. This is the simplest interface to use for reading the value of a scalar variable or when all the values of a multidimensional variable can be read at once. The values are read into consecutive locations with the first dimension varying fastest. The net\+C\+DF dataset must be in data mode.

Take care when using the simplest forms of this interface with record variables (variables that use the N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension) when you don’t specify how many records are to be read. If you try to read all the values of a record variable into an array but there are more records in the file than you ame, more data will be read than you expect, which may cause a segmentation violation. To avoidch problems, it is better to use the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+type interfaces for variables that use the N\+F\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension. See \href{#NF_005fGET_005fVARA_005f-type}{\tt N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+ type}.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) text) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+E\+R$\ast$1 i1vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+E\+R$\ast$2 i2vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER ivals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, R\+E\+AL rvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, D\+O\+U\+B\+LE dvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+AR (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, vals($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS}\textbackslash{} {\ttfamily V\+A\+LS} \+: The block of data values to be read. The data should be of the type appropriate for the function called. You cannot read C\+H\+A\+R\+A\+C\+T\+ER data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item One or more of the values are out of the range of values representable by the desired type.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+D\+O\+U\+B\+LE to read all the values of the variable named rh from an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we ame that we know that rh is dimensioned with lon and lat, and that there are ten lon values and five lat values.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (L\+A\+TS=5, L\+O\+NS=10) ! dimension lengths I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID D\+O\+U\+B\+LE R\+H\+V\+A\+L\+S(\+L\+O\+N\+S, L\+A\+T\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, R\+H\+V\+A\+LS) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+26 N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+ type }

The members of the N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+ type family of functions read an array of values from a net\+C\+DF variable of an open net\+C\+DF dataset. The array is specified by giving a corner and a vector of edge lengths. The values are read into consecutive locations with the first dimension varying fastest. The net\+C\+DF dataset must be in data mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+T\+E\+XT(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) text) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+I\+N\+T1(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$1 i1vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+I\+N\+T2(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$2 i2vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER ivals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+R\+E\+AL(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), R\+E\+AL rvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), D\+O\+U\+B\+LE dvals($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+A\+RT} \+: A vector of integers specifying the index in the variable where the first of the data values will be read. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The length of S\+T\+A\+RT must be the same as the number of dimensions of the specified variable. The elements of S\+T\+A\+RT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for reading the data values.

{\ttfamily C\+O\+U\+NT} \+: A vector of integers specifying the edge lengths along each dimension of the block of data values to be read. To read a single value, for example, specify C\+O\+U\+NT as (1, 1, ..., 1). The length of C\+O\+U\+NT is the number of dimensions of the specified variable. The elements of C\+O\+U\+NT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of C\+O\+U\+NT corresponds to a count of the number of records to read.

Note\+: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

{\ttfamily text}\textbackslash{} {\ttfamily i1vals}\textbackslash{} {\ttfamily i2vals}\textbackslash{} {\ttfamily ivals}\textbackslash{} {\ttfamily rvals}\textbackslash{} {\ttfamily dvals} \+: The block of data values to be read. The data should be of the type appropriate for the function called. You cannot read C\+H\+A\+R\+A\+C\+T\+ER data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified corner indices were out of range for the rank of the specified variable. For example, a negative index or an index that is larger than the corresponding dimension length will cause an error.
\item The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
\item One or more of the values are out of the range of values representable by the desired type.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+LE to read all the values of the variable named rh from an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we ame that we know that rh is dimensioned with lon, lat, and time, and that there are ten lon values, five lat values, and three time values.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+I\+MS=3) ! number of dimensions P\+A\+R\+A\+M\+E\+T\+ER (T\+I\+M\+ES=3, L\+A\+TS=5, L\+O\+NS=10) ! dimension lengths I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M\+S), C\+O\+U\+N\+T(\+N\+D\+I\+M\+S) D\+O\+U\+B\+LE R\+H\+V\+A\+L\+S(\+L\+O\+N\+S, L\+A\+T\+S, T\+I\+M\+E\+S) D\+A\+TA S\+T\+A\+RT /1, 1, 1/ ! start at first value D\+A\+TA C\+O\+U\+NT /\+L\+O\+NS, L\+A\+TS, T\+I\+M\+E\+S/ ! get all the values ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, S\+T\+A\+RT, C\+O\+U\+NT, R\+H\+V\+A\+LS) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+27 N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+ type }

The N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+ type family of functions read absampled (strided) array of values from a net\+C\+DF variable of an open net\+C\+DF dataset. Thebsampled array is specified by giving a corner, a vector of edge lengths, and a stride vector. The values are read with the first dimension of the net\+C\+DF variable varying fastest. The net\+C\+DF dataset must be in data mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$),C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) text) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$),I\+N\+T\+E\+G\+E\+R$\ast$1 i1vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$),I\+N\+T\+E\+G\+E\+R$\ast$2 i2vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER ivals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), R\+E\+AL rvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), D\+O\+U\+B\+LE dvals($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+A\+RT} \+: A vector of integers specifying the index in the variable from which the first of the data values will be read. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The elements of S\+T\+A\+RT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for reading the data values.

{\ttfamily C\+O\+U\+NT} \+: A vector of integers specifying the number of indices selected along each dimension. To read a single value, for example, specify C\+O\+U\+NT as (1, 1, ..., 1). The elements of C\+O\+U\+NT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of C\+O\+U\+NT corresponds to a count of the number of records to read.

Note\+: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

{\ttfamily S\+T\+R\+I\+DE} \+: A vector of integers specifying, for each dimension, the interval between selected indices or the value 0. The elements of the vector correspond, in order, to the variable’s dimensions. A value of 1 accesses adjacent values of the net\+C\+DF variable in the corresponding dimension; a value of 2 accesses every other value of the net\+C\+DF variable in the corresponding dimension; and so on. A 0 argument is treated as (1, 1, ..., 1).

{\ttfamily text}\textbackslash{} {\ttfamily i1vals}\textbackslash{} {\ttfamily i2vals}\textbackslash{} {\ttfamily ivals}\textbackslash{} {\ttfamily rvals}\textbackslash{} {\ttfamily dvals} \+: The block of data values to be read. The data should be of the type appropriate for the function called. You cannot read C\+H\+A\+R\+A\+C\+T\+ER data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified start, count and stride generate an index which is out of range.
\item One or more of the values are out of the range of values representable by the desired type.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+D\+O\+U\+B\+LE to read every other value in each dimension of the variable named rh from an existing net\+C\+DF dataset named foo.\+nc. Values are assigned, using the same dimensional strides, to a 2-\/parameter array. For simplicity in this example, we ame that we know that rh is dimensioned with lon, lat, and time, and that there are ten lon values, five lat values, and three time values.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+I\+MS=3) ! number of dimensions P\+A\+R\+A\+M\+E\+T\+ER (T\+I\+M\+ES=3, L\+A\+TS=5, L\+O\+NS=10) ! dimension lengths I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M\+S), C\+O\+U\+N\+T(\+N\+D\+I\+M\+S), S\+T\+R\+I\+D\+E(\+N\+D\+I\+M\+S) D\+O\+U\+B\+LE D\+A\+T\+A(\+L\+O\+N\+S, L\+A\+T\+S, T\+I\+M\+E\+S) D\+A\+TA S\+T\+A\+RT /1, 1, 1/ ! start at first value D\+A\+TA C\+O\+U\+NT /\+L\+O\+NS, L\+A\+TS, T\+I\+M\+E\+S/ D\+A\+TA S\+T\+R\+I\+DE /2, 2, 2/ ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+S\+\_\+\+D\+O\+U\+B\+L\+E(\+N\+C\+I\+D,\+R\+H\+I\+D,\+S\+T\+A\+R\+T,\+C\+O\+U\+N\+T,\+S\+T\+R\+I\+D\+E,\+D\+A\+T\+A(1,1,1)) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+28 N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+ type }

The N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+ type family of functions reads a mapped array section of values from a net\+C\+DF variable of an open net\+C\+DF dataset. The mapped array is specified by giving a corner, a vector of edge lengths, a stride vector, and an index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a net\+C\+DF variable and the in-\/memory structure of the internal data array. No amptions are made about the ordering or length of the dimensions of the data array. The net\+C\+DF dataset must be in data mode.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) text) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$1 i1vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), I\+N\+T\+E\+G\+E\+R$\ast$2 i2vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), I\+N\+T\+E\+G\+ER ivals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), R\+E\+AL rvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T($\ast$), I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T($\ast$), I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E($\ast$), I\+N\+T\+E\+G\+ER I\+M\+A\+P($\ast$), D\+O\+U\+B\+LE dvals($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily S\+T\+A\+RT} \+: A vector of integers specifying the index in the variable from which the first of the data values will be read. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The elements of S\+T\+A\+RT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for reading the data values.

{\ttfamily C\+O\+U\+NT} \+: A vector of integers specifying the number of indices selected along each dimension. To read a single value, for example, specify C\+O\+U\+NT as (1, 1, ..., 1). The elements of C\+O\+U\+NT correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of C\+O\+U\+NT corresponds to a count of the number of records to read.

Note\+: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

{\ttfamily S\+T\+R\+I\+DE} \+: A vector of integers specifying, for each dimension, the interval between selected indices or the value 0. The elements of the vector correspond, in order, to the variable’s dimensions. A value of 1 accesses adjacent values of the net\+C\+DF variable in the corresponding dimension; a value of 2 accesses every other value of the net\+C\+DF variable in the corresponding dimension; and so on. A 0 argument is treated as (1, 1, ..., 1).

{\ttfamily I\+M\+AP} \+: A vector of integers that specifies the mapping between the dimensions of a net\+C\+DF variable and the in-\/memory structure of the internal data array. I\+M\+A\+P(1) gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the net\+C\+DF variable. I\+M\+A\+P(\+N) (where N is the rank of the net\+C\+DF variable) gives the distance between elements of the internal array corresponding to the most slowly varying dimension of the net\+C\+DF variable. Intervening I\+M\+AP elements correspond to other dimensions of the net\+C\+DF variable in the obvious way. Distances between elements are specified in units of elements (the distance between internal elements that occupy adjacent memory locations is 1 and not the element’s byte-\/length as in net\+C\+DF 2).

{\ttfamily text}\textbackslash{} {\ttfamily i1vals}\textbackslash{} {\ttfamily i2vals}\textbackslash{} {\ttfamily ivals}\textbackslash{} {\ttfamily rvals}\textbackslash{} {\ttfamily dvals} \+: The block of data values to be read. The data should be of the type appropriate for the function called. You cannot read C\+H\+A\+R\+A\+C\+T\+ER data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur (see \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide).

\subsection*{Errors }

N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified S\+T\+A\+RT, C\+O\+U\+NT, and S\+T\+R\+I\+DE generate an index which is out of range. Note that no error checking is possible on the imap vector.
\item One or more of the values are out of the range of values representable by the desired type.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

The following I\+M\+AP vector maps in the trivial way a 2x3x4 net\+C\+DF variable and an internal array of the same shape\+:

 

R\+E\+AL A(2,3,4) ! same shape as net\+C\+DF variable I\+N\+T\+E\+G\+ER I\+M\+A\+P(3) D\+A\+TA I\+M\+AP /1, 2, 6/ ! net\+C\+DF dimension inter-\/element distance ! -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- ! most rapidly varying 1 ! intermediate 2 (=I\+M\+A\+P(1)$\ast$2) ! most slowly varying 6 (=I\+M\+A\+P(2)$\ast$3)

Using the I\+M\+AP vector above with N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL obtains the same rlt as simply using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+\_\+\+R\+E\+AL.

Here is an example of using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL to transpose a net\+C\+DF variable named rh which is described by the F\+O\+R\+T\+R\+AN declaration R\+E\+AL R\+H(4,6) (note the size and order of the dimensions)\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+IM=2) ! rank of net\+C\+DF variable I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF dataset ID I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! return code I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M) ! net\+C\+DF variable start point I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T(\+N\+D\+I\+M) ! size of internal array I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E(\+N\+D\+I\+M) ! net\+C\+DF variablebsampling intervals I\+N\+T\+E\+G\+ER I\+M\+A\+P(\+N\+D\+I\+M) ! internal array inter-\/element distances R\+E\+AL R\+H(6,4) ! note transposition of net\+C\+DF variable dimensions D\+A\+TA S\+T\+A\+RT /1, 1/ ! start at first net\+C\+DF variable element D\+A\+TA C\+O\+U\+NT /4, 6/ ! entire net\+C\+DF variable; order corresponds ! to net\+C\+DF variable -- not internal array D\+A\+TA S\+T\+R\+I\+DE /1, 1/ ! sample every net\+C\+DF element D\+A\+TA I\+M\+AP /6, 1/ ! would be /1, 4/ if not transposing ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID(N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+A\+L(\+N\+C\+I\+D, R\+H\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, S\+T\+R\+I\+D\+E, I\+M\+A\+P, R\+H) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

Here is another example of using N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+AL to simultaneously transpose andbsample the same net\+C\+DF variable, by accessing every other point of the net\+C\+DF variable\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (N\+D\+IM=2) ! rank of net\+C\+DF variable I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF dataset ID I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! return code I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER S\+T\+A\+R\+T(\+N\+D\+I\+M) ! net\+C\+DF variable start point I\+N\+T\+E\+G\+ER C\+O\+U\+N\+T(\+N\+D\+I\+M) ! size of internal array I\+N\+T\+E\+G\+ER S\+T\+R\+I\+D\+E(\+N\+D\+I\+M) ! net\+C\+DF variablebsampling intervals I\+N\+T\+E\+G\+ER I\+M\+A\+P(\+N\+D\+I\+M) ! internal array inter-\/element distances R\+E\+AL R\+H(3,2) ! note transposition of bsampled) dimensions D\+A\+TA S\+T\+A\+RT /1, 1/ ! start at first net\+C\+DF variable value D\+A\+TA C\+O\+U\+NT /2, 3/ ! order of bsampled) dimensions corresponds ! to net\+C\+DF variable -- not internal array D\+A\+TA S\+T\+R\+I\+DE /2, 2/ ! sample every other net\+C\+DF element D\+A\+TA I\+M\+AP /3, 1/ ! would be `1, 2\textquotesingle{} if not transposing ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID(N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+M\+\_\+\+R\+E\+A\+L(\+N\+C\+I\+D, R\+H\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, S\+T\+R\+I\+D\+E, I\+M\+A\+P, R\+H) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+29 Reading and Writing Character String Values }

Character strings are not a primitive net\+C\+DF external data type, in part because F\+O\+R\+T\+R\+AN does notpport the abstraction of variable-\/length character strings (the F\+O\+R\+T\+R\+AN L\+EN function returns the static length of a character string, not its dynamic length). As a rlt, a character string cannot be written or read as a single object in the net\+C\+DF interface. Instead, a character string must be treated as an array of characters, and array access must be used to read and write character strings as variable data in net\+C\+DF datasets. Furthermore, variable-\/length strings are notpported by the net\+C\+DF interface except by convention; for example, you may treat a zero byte as terminating a character string, but you must explicitly specify the length of strings to be read from and written to net\+C\+DF variables.

Character strings as attribute values are easier to use, since the strings are treated as a single unit for access. However, the value of a character-\/string attribute is still an array of characters with an explicit length that must be specified when the attribute is defined.

When you define a variable that will have character-\/string values, use a character-\/position dimension as the most quickly varying dimension for the variable (the first dimension for the variable in F\+O\+R\+T\+R\+AN). The length of the character-\/position dimension will be the maximum string length of any value to be stored in the character-\/string variable. Space for maximum-\/length strings will be allocated in the disk representation of character-\/string variables whether you use the space or not. If two or more variables have the same maximum length, the same character-\/position dimension may be used in defining the variable shapes.

To write a character-\/string value into a character-\/string variable, use either entire variable access or array access. The latter requires that you specify both a corner and a vector of edge lengths. The character-\/position dimension at the corner should be one for F\+O\+R\+T\+R\+AN. If the length of the string to be written is n, then the vector of edge lengths will specify n in the character-\/position dimension, and one for all the other dimensions\+:(n, 1, 1, ..., 1).

In F\+O\+R\+T\+R\+AN, fixed-\/length strings may be written to a net\+C\+DF dataset without a terminating character, to save space. Variable-\/length strings should follow the C convention of writing strings with a terminating zero byte so that the intended length of the string can be determined when it is later read by either C or F\+O\+R\+T\+R\+AN programs.

The F\+O\+R\+T\+R\+AN interface for reading and writing strings requires the use of different functions for accessing string values and numeric values, because standard F\+O\+R\+T\+R\+AN does not permit the same formal parameter to be used for both character values and numeric values. An additional argument, specifying the declared length of the character string passed as a value, is required for N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+T\+E\+XT and N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+T\+E\+XT. The actual length of the string is specified as the value of the edge-\/length vector corresponding to the character-\/position dimension.

Here is an example that defines a record variable, tx, for character strings and stores a character-\/string value into the third record using N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+T\+E\+XT. In this example, we ame the string variable and data are to be added to an existing net\+C\+DF dataset named foo.\+nc that already has an unlimited record dimension time.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER T\+D\+I\+MS, T\+X\+L\+EN P\+A\+R\+A\+M\+E\+T\+ER (T\+D\+I\+MS=2) ! number of TX dimensions P\+A\+R\+A\+M\+E\+T\+ER (T\+X\+L\+EN = 15) ! length of example string I\+N\+T\+E\+G\+ER N\+C\+ID I\+N\+T\+E\+G\+ER C\+H\+ID ! char position dimension id I\+N\+T\+E\+G\+ER T\+I\+M\+E\+ID ! record dimension id I\+N\+T\+E\+G\+ER T\+X\+ID ! variable ID I\+N\+T\+E\+G\+ER T\+X\+D\+I\+M\+S(\+T\+D\+I\+M\+S) ! variable shape I\+N\+T\+E\+G\+ER T\+S\+T\+A\+R\+T(\+T\+D\+I\+M\+S), T\+C\+O\+U\+N\+T(\+T\+D\+I\+M\+S) C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$40 T\+X\+V\+AL ! max length 40 D\+A\+TA T\+X\+V\+AL /\textquotesingle{}example string\textquotesingle{}/ ... T\+X\+V\+A\+L(\+T\+X\+L\+E\+N\+:\+T\+X\+L\+E\+N) = C\+H\+A\+R(0) ! null terminate ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN(\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+D\+E\+F(\+N\+C\+I\+D) ! enter define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! define character-\/position dimension for strings of max length 40 S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+D\+IM(N\+C\+ID, \char`\"{}chid\char`\"{}, 40, C\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! define a character-\/string variable T\+X\+D\+I\+M\+S(1) = C\+H\+ID ! character-\/position dimension first T\+X\+D\+I\+M\+S(2) = T\+I\+M\+E\+ID S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+F\+\_\+\+V\+AR(N\+C\+ID, \char`\"{}tx\char`\"{}, N\+F\+\_\+\+C\+H\+AR, T\+D\+I\+MS, T\+X\+D\+I\+MS, T\+X\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+E\+N\+D\+D\+E\+F(\+N\+C\+I\+D) ! leave define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! write txval into tx net\+C\+DF variable in record 3 T\+S\+T\+A\+R\+T(1) = 1 ! start at beginning of variable T\+S\+T\+A\+R\+T(2) = 3 ! record number to write T\+C\+O\+U\+N\+T(1) = T\+X\+L\+EN ! number of chars to write T\+C\+O\+U\+N\+T(2) = 1 ! only write one record S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R\+A\+\_\+\+T\+E\+XT (N\+C\+ID, T\+X\+ID, T\+S\+T\+A\+RT, T\+C\+O\+U\+NT, T\+X\+V\+AL) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+30 Fill Values }

What happens when you try to read a value that was never written in an open net\+C\+DF dataset? You might expect that this should always be an error, and that you should get an error message or an error status returned. You do get an error if you try to read data from a net\+C\+DF dataset that is not open for reading, if the variable ID is invalid for the specified net\+C\+DF dataset, or if the specified indices are not properly within the range defined by the dimension lengths of the specified variable. Otherwise, reading a value that was not written returns a special fill value used to fill in any undefined values when a net\+C\+DF variable is first written.

You may ignore fill values and use the entire range of a net\+C\+DF external data type, but in this case you should makere you write all data values before reading them. If you know you will be writing all the data before reading it, you can specify that no prefilling of variables with fill values will occur by calling N\+F\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL before writing. This may provide a significant performance gain for net\+C\+DF writes.

The variable attribute \+\_\+\+Fill\+Value may be used to specify the fill value for a variable. Their are default fill values for each type, defined in the include file netcdf.\+inc\+: N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+C\+H\+AR, N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+I\+N\+T1 (same as N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+B\+Y\+TE), N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+I\+N\+T2 (same as N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+S\+H\+O\+RT), N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+I\+NT, N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+R\+E\+AL (same as N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+F\+L\+O\+AT), and N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+D\+O\+U\+B\+LE.

The net\+C\+DF byte and character types have different default fill values. The default fill value for characters is the zero byte, a useful value for detecting the end of variable-\/length C character strings. If you need a fill value for a byte variable, it is recommended that you explicitly define an appropriate \+\_\+\+Fill\+Value attribute, as generic utilitiesch as ncdump will not ame a default fill value for byte variables.

Type conversion for fill values is identical to type conversion for other values\+: attempting to convert a value from one type to another type that can’t represent the value rlts in a range error. Such errors may occur on writing or reading values from a larger type ch as double) to a smaller type ch as float), if the fill value for the larger type cannot be represented in the smaller type.

\subsection*{6.\+31 N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR }

The function N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR changes the name of a net\+C\+DF variable in an open net\+C\+DF dataset. If the new name is longer than the old name, the net\+C\+DF dataset must be in define mode. You cannot rename a variable to have the name of any existing variable.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+E\+W\+N\+AM)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID.

{\ttfamily N\+A\+ME} \+: New name for the specified variable.

\subsection*{Errors }

N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The new name is in use as the name of another variable.
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR to rename the variable rh to rel\+\_\+hum in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+D\+EF (N\+C\+ID) ! enter definition mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR (N\+C\+ID, R\+H\+ID, \textquotesingle{}rel\+\_\+hum\textquotesingle{}) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+E\+N\+D\+D\+EF (N\+C\+ID) ! leave definition mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{6.\+32 Change between Collective and Independent Parallel Access\+: N\+F\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+SS }

The function N\+F\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+SS changes whether read/write operations on a parallel file system are performed collectively or independently (the default) on the variable. This function can only be called if the file was created with N\+F\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+P\+AR (see \href{#NF_005fCREATE_005fPAR}{\tt N\+F\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+P\+AR}) or opened with N\+F\+\_\+\+O\+P\+E\+N\+\_\+\+P\+AR (see \href{#NF_005fOPEN_005fPAR}{\tt N\+F\+\_\+\+O\+P\+E\+N\+\_\+\+P\+AR}).

This function is only available if the net\+C\+DF library was built with a H\+D\+F5 library for which –enable-\/parallel was used, and which was linked (like H\+D\+F5) to M\+PI libraries.

Calling this function affects only the open file -\/ information about whether a variable is to be accessed collectively or independently is not written to the data file. Every time you open a file on a parallel file system, all variables default to independent operations. The change a variable to collective lasts only as long as that file is open.

The variable can be changed from collective to independent, and back, as often as desired.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER N\+F\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+S\+S(\+I\+N\+T\+E\+G\+E\+R N\+C\+I\+D, I\+N\+T\+E\+G\+E\+R V\+A\+R\+I\+D, I\+N\+T\+E\+G\+E\+R A\+C\+C\+E\+S\+S);

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+E\+N\+\_\+\+P\+AR (see \href{#NF_005fOPEN_005fPAR}{\tt N\+F\+\_\+\+O\+P\+E\+N\+\_\+\+P\+AR}) or N\+F\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+P\+AR (see \href{#NF_005fCREATE_005fPAR}{\tt N\+F\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+P\+AR}).

{\ttfamily varid} \+: Variable ID.

{\ttfamily access} \+: N\+F\+\_\+\+I\+N\+D\+E\+P\+E\+N\+D\+E\+NT to set this variable to independent operations. N\+F\+\_\+\+C\+O\+L\+L\+E\+C\+T\+I\+VE to set it to collective operations.

\subsection*{Return Values }

{\ttfamily N\+F\+\_\+\+N\+O\+E\+RR} \+: No error.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+V\+AR} \+: No variable found.

{\ttfamily N\+F\+\_\+\+E\+N\+O\+T\+N\+C4} \+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F\+\_\+\+N\+O\+P\+AR} \+: File not opened for parallel access.

\subsection*{Example }

This example comes from test program nf\+\_\+test/ftst\+\_\+parallel.\+F. For this test to be run, net\+C\+DF must have been built with a parallel-\/enabled H\+D\+F5, and –enable-\/parallel-\/tests must have been used when configuring netcdf.

 

\begin{DoxyVerb}  retval = nf_var_par_access(ncid, varid, nf_collective)
  if (retval .ne. nf_noerr) stop 2
\end{DoxyVerb}


\section*{7. Attributes }

\subsection*{7.\+1 Attributes Introduction }

Attributes may be associated with each net\+C\+DF variable to specifych properties as units, special values, maximum and minimum valid values, scaling factors, and offsets. Attributes for a net\+C\+DF dataset are defined when the dataset is first created, while the net\+C\+DF dataset is in define mode. Additional attributes may be added later by reentering define mode. A net\+C\+DF attribute has a net\+C\+DF variable to which it is assigned, a name, a type, a length, and a sequence of one or more values. An attribute is designated by its variable ID and name. When an attribute name is not known, it may be designated by its variable ID and number in order to determine its name, using the function N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME.

The attributes associated with a variable are typically defined immediately after the variable is created, while still in define mode. The data type, length, and value of an attribute may be changed even when in data mode, as long as the changed attribute requires no more space than the attribute as originally defined.

It is also possible to have attributes that are not associated with any variable. These are called global attributes and are identified by using N\+F\+\_\+\+G\+L\+O\+B\+AL as a variable pseudo-\/\+ID. Global attributes are ally related to the net\+C\+DF dataset as a whole and may be used for purposes such as providing a title or processing history for a net\+C\+DF dataset.

Attributes are much more useful when they follow established community conventions. See \href{netcdf.html#Attribute-Conventions}{\tt (netcdf)Attribute Conventions} ‘\+Attribute Conventions’ in The Net\+C\+DF Users Guide.

Operationspported on attributes are\+:


\begin{DoxyItemize}
\item Create an attribute, given its variable ID, name, data type, length, and value.
\item Get attribute’s data type and length from its variable ID and name.
\item Get attribute’s value from its variable ID and name.
\item Copy attribute from one net\+C\+DF variable to another.
\item Get name of attribute from its number.
\item Rename an attribute.
\item Delete an attribute.
\end{DoxyItemize}

\subsection*{7.\+2 N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+ type }

The function N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+ type adds or changes a variable attribute or global attribute of an open net\+C\+DF dataset. If this attribute is new, or if the space required to store the attribute is greater than before, the net\+C\+DF dataset must be in define mode.

\subsection*{Usage }

Although it’s possible to create attributes of all types, text and double attributes are adequate for most purposes.

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER L\+EN, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) T\+E\+XT) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, L\+EN, I\+N\+T\+E\+G\+E\+R$\ast$1 I1\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, L\+EN, I\+N\+T\+E\+G\+E\+R$\ast$2 I2\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, L\+EN, I\+N\+T\+E\+G\+ER I\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, L\+EN, R\+E\+AL R\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, L\+EN, D\+O\+U\+B\+LE D\+V\+A\+L\+S($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+TT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER X\+T\+Y\+PE, L\+EN, $\ast$ V\+A\+L\+S($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID of the variable to which the attribute will be assigned or N\+F\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily N\+A\+ME} \+: Attribute name. Attribute name conventions are amed by some net\+C\+DF generic applications, e.\+g., ‘units’ as the name for a string attribute that gives the units for a net\+C\+DF variable. See \href{netcdf.html#Attribute-Conventions}{\tt (netcdf)Attribute Conventions} ‘\+Attribute Conventions’ in The Net\+C\+DF Users Guide.

{\ttfamily X\+T\+Y\+PE} \+: One of the set of predefined net\+C\+DF external data types. The type of this parameter, N\+F\+\_\+\+T\+Y\+PE, is defined in the net\+C\+DF header file. The valid net\+C\+DF external data types are N\+F\+\_\+\+B\+Y\+TE, N\+F\+\_\+\+C\+H\+AR, N\+F\+\_\+\+S\+H\+O\+RT, N\+F\+\_\+\+I\+NT, N\+F\+\_\+\+F\+L\+O\+AT, and N\+F\+\_\+\+D\+O\+U\+B\+LE. Although it’s possible to create attributes of all types, N\+F\+\_\+\+C\+H\+AR and N\+F\+\_\+\+D\+O\+U\+B\+LE attributes are adequate for most purposes.

{\ttfamily L\+EN} \+: Number of values provided for the attribute.

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS}\textbackslash{} {\ttfamily V\+A\+LS} \+: An array of L\+EN attribute values. The data should be of a type appropriate for the function called. You cannot write C\+H\+A\+R\+A\+C\+T\+ER data into a numeric attribute or numeric data into a text attribute. For numeric data, if the type of data differs from the attribute type, type conversion will occur See \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The Net\+C\+DF Users Guide.

\subsection*{Errors }

N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF type is invalid.
\item The specified length is negative.
\item The specified open net\+C\+DF dataset is in data mode and the specified attribute would expand.
\item The specified open net\+C\+DF dataset is in data mode and the specified attribute does not already exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The number of attributes for this variable exceeds N\+F\+\_\+\+M\+A\+X\+\_\+\+A\+T\+T\+RS.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE to add a variable attribute named valid\+\_\+range for a net\+C\+DF variable named rh and a global attribute named title to an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID D\+O\+U\+B\+LE R\+H\+R\+N\+G\+E(2) D\+A\+TA R\+H\+R\+N\+GE /0.0\+D0, 100.\+0\+D0/ ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+D\+EF (N\+C\+ID) ! enter define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, \textquotesingle{}valid\+\_\+range\textquotesingle{}, N\+F\+\_\+\+D\+O\+U\+B\+LE, \& 2, R\+H\+R\+N\+GE) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+T\+E\+XT (N\+C\+ID, N\+F\+\_\+\+G\+L\+O\+B\+AL, \textquotesingle{}title\textquotesingle{}, 19, \textquotesingle{}example net\+C\+DF dataset\textquotesingle{}) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+E\+N\+D\+D\+EF (N\+C\+ID) ! leave define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{7.\+3 N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+TT Family }

This family of functions returns information about a net\+C\+DF attribute. All but one of these functions require the variable ID and attribute name; the exception is N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME. Information about an attribute includes its type, length, name, and number. See the N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+TT family for getting attribute values.

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME gets the name of an attribute, given its variable ID and number. This function is useful in generic applications that need to get the names of all the attributes associated with a variable, since attributes are accessed by name rather than number in all other attribute functions. The number of an attribute is more volatile than the name, since it can change when other attributes of the same variable are deleted. This is why an attribute number is not called an attribute ID.

The function N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+TT returns the attribute’s type and length. The other functions each return just one item of information about an attribute.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+TT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER xtype, I\+N\+T\+E\+G\+ER len) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+T\+Y\+PE(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER xtype) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER len) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME(I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, I\+N\+T\+E\+G\+ER A\+T\+T\+N\+UM, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) name) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+ID (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER attnum)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID of the attribute’s variable, or N\+F\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily N\+A\+ME} \+: Attribute name. For N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME, this is a pointer to the location for the returned attribute name.

{\ttfamily xtype} \+: Returned attribute type, one of the set of predefined net\+C\+DF external data types. The valid net\+C\+DF external data types are N\+F\+\_\+\+B\+Y\+TE, N\+F\+\_\+\+C\+H\+AR, N\+F\+\_\+\+S\+H\+O\+RT, N\+F\+\_\+\+I\+NT, N\+F\+\_\+\+F\+L\+O\+AT, and N\+F\+\_\+\+D\+O\+U\+B\+LE.

{\ttfamily len} \+: Returned number of values currently stored in the attribute. For a string-\/valued attribute, this is the number of characters in the string.

{\ttfamily attnum} \+: For N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME, the input attribute number; for N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+ID, the returned attribute number. The attributes for each variable are numbered from 1 (the first attribute) to N\+A\+T\+TS, where N\+A\+T\+TS is the number of attributes for the variable, as returned from a call to N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+A\+T\+TS.

(If you already know an attribute name, knowing its number is not very useful, because accessing information about an attribute requires its name.)

\subsection*{Errors }

Each function returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item For N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME, the specified attribute number is negative or more than the number of attributes defined for the specified variable.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+TT to find out the type and length of a variable attribute named valid\+\_\+range for a net\+C\+DF variable named rh and a global attribute named title in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER V\+R\+L\+EN, T\+L\+EN ! attribute lengths ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN (N\+C\+ID, R\+H\+ID, \textquotesingle{}valid\+\_\+range\textquotesingle{}, V\+R\+L\+EN) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN (N\+C\+ID, N\+F\+\_\+\+G\+L\+O\+B\+AL, \textquotesingle{}title\textquotesingle{}, T\+L\+EN) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{7.\+4 N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+ type }

Members of the N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+ type family of functions get the value(s) of a net\+C\+DF attribute, given its variable ID and name.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+T\+E\+XT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) text) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T1 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+E\+R$\ast$1 i1vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T2 (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+E\+R$\ast$2 i2vals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+I\+NT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER ivals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+R\+E\+AL (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, R\+E\+AL rvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, D\+O\+U\+B\+LE dvals($\ast$)) I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+TT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, $\ast$ vals($\ast$))

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: Variable ID of the attribute’s variable, or N\+F\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily N\+A\+ME} \+: Attribute name.

{\ttfamily T\+E\+XT}\textbackslash{} {\ttfamily I1\+V\+A\+LS}\textbackslash{} {\ttfamily I2\+V\+A\+LS}\textbackslash{} {\ttfamily I\+V\+A\+LS}\textbackslash{} {\ttfamily R\+V\+A\+LS}\textbackslash{} {\ttfamily D\+V\+A\+LS}\textbackslash{} {\ttfamily V\+A\+LS} \+: Returned attribute values. All elements of the vector of attribute values are returned, so you must provide enough space to hold them. If you don’t know how much space to reserve, call N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN first to find out the length of the attribute. You cannot read character data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur. See \href{netcdf.html#Type-Conversion}{\tt (netcdf)Type Conversion} ‘\+Type Conversion’ in The The Net\+C\+DF Users Guide.

\subsection*{Errors }

N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+ type returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item One or more of the attribute values are out of the range of values representable by the desired type.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE to determine the values of a variable attribute named valid\+\_\+range for a net\+C\+DF variable named rh and a global attribute named title in an existing net\+C\+DF dataset named foo.\+nc. In this example, it is amed that we don’t know how many values will be returned, but that we do know the types of the attributes. Hence, to allocate enough space to store them, we must first inquire about the length of the attributes.

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... P\+A\+R\+A\+M\+E\+T\+ER (M\+V\+R\+L\+EN=3) ! max number of \char`\"{}valid\+\_\+range\char`\"{} values P\+A\+R\+A\+M\+E\+T\+ER (M\+T\+L\+EN=80) ! max length of \char`\"{}title\char`\"{} attribute I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US, N\+C\+ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID I\+N\+T\+E\+G\+ER V\+R\+L\+EN, T\+L\+EN ! attribute lengths D\+O\+U\+B\+LE P\+R\+E\+C\+I\+S\+I\+ON V\+R\+V\+A\+L(\+M\+V\+R\+L\+E\+N) ! vr attribute values C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$80 T\+I\+T\+LE ! title attribute values ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! find out attribute lengths, to makere we have enough space S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN (N\+C\+ID, R\+H\+ID, \textquotesingle{}valid\+\_\+range\textquotesingle{}, V\+R\+L\+EN) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN (N\+C\+ID, N\+F\+\_\+\+G\+L\+O\+B\+AL, \textquotesingle{}title\textquotesingle{}, T\+L\+EN) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ! get attribute values, if not too big IF (V\+R\+L\+EN .GT. M\+V\+R\+L\+EN) T\+H\+EN W\+R\+I\+TE ($\ast$,$\ast$) \textquotesingle{}valid\+\_\+range attribute too big!\textquotesingle{} C\+A\+LL E\+X\+IT E\+L\+SE S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE (N\+C\+ID, R\+H\+ID, \textquotesingle{}valid\+\_\+range\textquotesingle{}, V\+R\+V\+AL) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) E\+N\+D\+IF IF (T\+L\+EN .GT. M\+T\+L\+EN) T\+H\+EN W\+R\+I\+TE ($\ast$,$\ast$) \textquotesingle{}title attribute too big!\textquotesingle{} C\+A\+LL E\+X\+IT E\+L\+SE S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+T\+E\+XT (N\+C\+ID, N\+F\+\_\+\+G\+L\+O\+B\+AL, \textquotesingle{}title\textquotesingle{}, T\+I\+T\+LE) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) E\+N\+D\+IF

\subsection*{7.\+5 N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT }

The function N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT copies an attribute from one open net\+C\+DF dataset to another. It can also be used to copy an attribute from one variable to another within the same net\+C\+DF.

If used to copy an attribute of user-\/defined type, then that user-\/defined type must already be defined in the target file. In the case of user-\/defined attributes, enddef/redef is called for ncid\+\_\+in and ncid\+\_\+out if they are in define mode. (This is the ere that all user-\/defined types are committed to the file(s) before the copy is attempted.)

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT (I\+N\+T\+E\+G\+ER N\+C\+I\+D\+\_\+\+IN, I\+N\+T\+E\+G\+ER V\+A\+R\+I\+D\+\_\+\+IN, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, I\+N\+T\+E\+G\+ER N\+C\+I\+D\+\_\+\+O\+UT, I\+N\+T\+E\+G\+ER V\+A\+R\+I\+D\+\_\+\+O\+UT)

{\ttfamily N\+C\+I\+D\+\_\+\+IN} \+: The net\+C\+DF ID of an input net\+C\+DF dataset from which the attribute will be copied, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+I\+D\+\_\+\+IN} \+: ID of the variable in the input net\+C\+DF dataset from which the attribute will be copied, or N\+F\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily N\+A\+ME} \+: Name of the attribute in the input net\+C\+DF dataset to be copied.

{\ttfamily N\+C\+I\+D\+\_\+\+O\+UT} \+: The net\+C\+DF ID of the output net\+C\+DF dataset to which the attribute will be copied, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE. It is permissible for the input and output net\+C\+DF I\+Ds to be the same. The output net\+C\+DF dataset should be in define mode if the attribute to be copied does not already exist for the target variable, or if it would cause an existing target attribute to grow.

{\ttfamily V\+A\+R\+I\+D\+\_\+\+O\+UT} \+: ID of the variable in the output net\+C\+DF dataset to which the attribute will be copied, or N\+F\+\_\+\+G\+L\+O\+B\+AL to copy to a global attribute.

\subsection*{Errors }

N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The input or output variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified attribute does not exist.
\item The output net\+C\+DF is not in define mode and the attribute is new for the output dataset is larger than the existing attribute.
\item The input or output net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT to copy the variable attribute units from the variable rh in an existing net\+C\+DF dataset named foo.\+nc to the variable avgrh in another existing net\+C\+DF dataset named bar.\+nc, aming that the variable avgrh already exists, but does not yet have a units attribute\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! error status I\+N\+T\+E\+G\+ER N\+C\+I\+D1, N\+C\+I\+D2 ! net\+C\+DF I\+Ds I\+N\+T\+E\+G\+ER R\+H\+ID, A\+V\+R\+H\+ID ! variable I\+Ds ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+I\+D1) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}bar.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+I\+D2) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+I\+D1, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+I\+D2, \textquotesingle{}avgrh\textquotesingle{}, A\+V\+R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+D\+EF (N\+C\+I\+D2) ! enter define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ! copy variable attribute from \char`\"{}rh\char`\"{} to \char`\"{}avgrh\char`\"{} S\+T\+A\+T\+US = N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT (N\+C\+I\+D1, R\+H\+ID, \textquotesingle{}units\textquotesingle{}, N\+C\+I\+D2, A\+V\+R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+E\+N\+D\+D\+EF (N\+C\+I\+D2) ! leave define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{7.\+6 N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT }

The function N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT changes the name of an attribute. If the new name is longer than the original name, the net\+C\+DF dataset must be in define mode. You cannot rename an attribute to have the same name as another attribute of the same variable.

\subsection*{Usage }

 

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+E\+W\+N\+A\+ME)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE

{\ttfamily V\+A\+R\+ID} \+: ID of the attribute’s variable, or N\+F\+\_\+\+G\+L\+O\+B\+AL for a global attribute

{\ttfamily N\+A\+ME} \+: The current attribute name.

{\ttfamily N\+E\+W\+N\+A\+ME} \+: The new name to be assigned to the specified attribute. If the new name is longer than the current name, the net\+C\+DF dataset must be in define mode.

\subsection*{Errors }

N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified variable ID is not valid.
\item The new attribute name is already in use for another attribute of the specified variable.
\item The specified net\+C\+DF dataset is in data mode and the new name is longer than the old name.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT to rename the variable attribute units to Units for a variable rh in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \char`\"{}netcdf.\+inc\char`\"{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! error status I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\char`\"{}foo.\+nc\char`\"{}, N\+F\+\_\+\+N\+O\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \char`\"{}rh\char`\"{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! rename attribute S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT (N\+C\+ID, R\+H\+ID, \char`\"{}units\char`\"{}, \char`\"{}\+Units\char`\"{}) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)

\subsection*{7.\+7 N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT }

The function N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT deletes a net\+C\+DF attribute from an open net\+C\+DF dataset. The net\+C\+DF dataset must be in define mode.

\subsection*{Usage }

I\+N\+T\+E\+G\+ER F\+U\+N\+C\+T\+I\+ON N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT (I\+N\+T\+E\+G\+ER N\+C\+ID, I\+N\+T\+E\+G\+ER V\+A\+R\+ID, C\+H\+A\+R\+A\+C\+T\+E\+R$\ast$($\ast$) N\+A\+ME)

{\ttfamily N\+C\+ID} \+: Net\+C\+DF ID, from a previous call to N\+F\+\_\+\+O\+P\+EN or N\+F\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID} \+: ID of the attribute’s variable, or N\+F\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily N\+A\+ME} \+: The name of the attribute to be deleted.

\subsection*{Errors }

N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT returns the value N\+F\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified variable ID is not valid.
\item The specified net\+C\+DF dataset is in data mode.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example }

Here is an example using N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT to delete the variable attribute Units for a variable rh in an existing net\+C\+DF dataset named foo.\+nc\+:

 

I\+N\+C\+L\+U\+DE \textquotesingle{}netcdf.\+inc\textquotesingle{} ... I\+N\+T\+E\+G\+ER S\+T\+A\+T\+US ! error status I\+N\+T\+E\+G\+ER N\+C\+ID ! net\+C\+DF ID I\+N\+T\+E\+G\+ER R\+H\+ID ! variable ID ... S\+T\+A\+T\+US = N\+F\+\_\+\+O\+P\+EN (\textquotesingle{}foo.\+nc\textquotesingle{}, N\+F\+\_\+\+W\+R\+I\+TE, N\+C\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... S\+T\+A\+T\+US = N\+F\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID (N\+C\+ID, \textquotesingle{}rh\textquotesingle{}, R\+H\+ID) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) ... ! delete attribute S\+T\+A\+T\+US = N\+F\+\_\+\+R\+E\+D\+EF (N\+C\+ID) ! enter define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT (N\+C\+ID, R\+H\+ID, \textquotesingle{}Units\textquotesingle{}) IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S) S\+T\+A\+T\+US = N\+F\+\_\+\+E\+N\+D\+D\+EF (N\+C\+ID) ! leave define mode IF (S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) C\+A\+LL H\+A\+N\+D\+L\+E\+\_\+\+E\+R\+R(\+S\+T\+A\+T\+U\+S)\hypertarget{nc_f77_interface_guide_f77_nc2_to_nc3_transition_guide}{}\section{A. Net\+C\+D\+F 2 to Net\+C\+D\+F 3 Fortran 77 Transition Guide }\label{nc_f77_interface_guide_f77_nc2_to_nc3_transition_guide}
\hypertarget{nc_f77_interface_guide_f77_overview_of_interface_changes}{}\subsection{A.\+1 Overview of F\+O\+R\+T\+R\+A\+N interface changes }\label{nc_f77_interface_guide_f77_overview_of_interface_changes}
Net\+C\+DF version 3 includes a complete rewrite of the net\+C\+DF library. It is about twice as fast as the previous version. The net\+C\+DF file format is unchanged, so files written with version 3 can be read with version 2 code and vice versa.

The core library is now written in A\+N\+SI C. You must have an A\+N\+SI C compiler to compile this version. The F\+O\+R\+T\+R\+AN interface is layered on top of the C interface using a different technique than was used in net\+C\+D\+F-\/2.

Rewriting the library offered an opportunity to implement improved C and F\+O\+R\+T\+R\+AN interfaces that provide some significant benefits\+:


\begin{DoxyItemize}
\item type safety, by eliminating the need to use type punning in arguments;
\item automatic type conversions, by eliminating the undesirable coupling between the language-\/independent external net\+C\+DF types (N\+F\+\_\+\+B\+Y\+TE, ..., N\+F\+\_\+\+D\+O\+U\+B\+LE) and language-\/dependent internal data types (I\+N\+T$\ast$1, ..., D\+O\+U\+B\+LE P\+R\+E\+C\+I\+S\+I\+ON);
\item pport for future enhancements, by eliminating obstacles to the clean addition ofpport for packed data and multithreading;
\item more standard error behavior, by uniformly communicating an error status back to the calling program in the return value of each function.
\end{DoxyItemize}

It is not necessary to rewrite programs that use the version 2 F\+O\+R\+T\+R\+AN interface, because the net\+C\+D\+F-\/3 library includes a backward compatibility interface thatpports all the old functions, globals, and behavior. We are hoping that the benefits of the new interface will be an incentive to use it in new net\+C\+DF applications. It is possible to convert old applications to the new interface incrementally, replacing net\+C\+D\+F-\/2 calls with the corresponding net\+C\+D\+F-\/3 calls one at a time.

Other changes in the implementation of net\+C\+DF rlt in improved portability, maintainability, and performance on most platforms. A clean separation between I/O and type layers facilitates platform-\/specific optimizations. The new library no longer uses a vendor-\/provided X\+DR library, which simplifies linking programs that use net\+C\+DF and speeds up data access significantly in most cases.\hypertarget{nc_f77_interface_guide_f77_new_fortran_interface}{}\subsection{A.\+2 The New F\+O\+R\+T\+R\+A\+N Interface }\label{nc_f77_interface_guide_f77_new_fortran_interface}
First, here’s an example of F\+O\+R\+T\+R\+AN code that uses the net\+C\+D\+F-\/2 interface\+:

 

! Use a buffer big enough for values of any type D\+O\+U\+B\+LE P\+R\+E\+C\+I\+S\+I\+ON D\+B\+U\+F(\+N\+D\+A\+T\+A) R\+E\+AL R\+B\+U\+F(\+N\+D\+A\+T\+A) ... E\+Q\+U\+I\+V\+A\+L\+E\+N\+CE (R\+B\+UF, D\+B\+UF), ... I\+NT X\+T\+Y\+PE ! to hold the actual type of the data I\+NT S\+T\+A\+T\+US ! for error status ! Get the actual data type C\+A\+LL N\+C\+V\+I\+NQ(N\+C\+ID, V\+A\+R\+ID, ...,X\+T\+Y\+PE, ...) ... ! Get the data C\+A\+LL N\+C\+V\+G\+T(\+N\+C\+I\+D, V\+A\+R\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, D\+B\+U\+F, S\+T\+A\+T\+U\+S) IF(S\+T\+A\+T\+US .NE. N\+C\+N\+O\+E\+RR) T\+H\+EN P\+R\+I\+NT $\ast$, \textquotesingle{}Cannot get data, error code =\textquotesingle{}, S\+T\+A\+T\+US ! Deal with error ... E\+N\+D\+IF IF (X\+T\+Y\+PE .EQ. N\+C\+D\+O\+U\+B\+LE) T\+H\+EN C\+A\+LL D\+A\+N\+A\+L\+Y\+Z\+E(\+D\+B\+U\+F) E\+L\+S\+E\+IF (X\+T\+Y\+PE .EQ. N\+C\+F\+L\+O\+AT) T\+H\+EN C\+A\+LL R\+A\+N\+A\+L\+Y\+Z\+E(\+R\+B\+U\+F) ... E\+N\+D\+IF

Here’s how you might handle this with the new net\+C\+D\+F-\/3 F\+O\+R\+T\+R\+AN interface\+:

 

! I want to use doubles for my analysis D\+O\+U\+B\+LE P\+R\+E\+C\+I\+S\+I\+ON D\+B\+U\+F(\+N\+D\+A\+T\+A) I\+NT S\+T\+A\+T\+US ! So I use a function that gets the data as doubles. S\+T\+A\+T\+US = N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R\+A\+\_\+\+D\+O\+U\+B\+L\+E(\+N\+C\+I\+D, V\+A\+R\+I\+D, S\+T\+A\+R\+T, C\+O\+U\+N\+T, D\+B\+U\+F) IF(S\+T\+A\+T\+US .NE. N\+F\+\_\+\+N\+O\+E\+RR) T\+H\+EN P\+R\+I\+NT $\ast$, \textquotesingle{}Cannot get data, \textquotesingle{}, N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+O\+R(\+S\+T\+A\+T\+U\+S) ! Deal with error ... E\+N\+D\+IF C\+A\+LL D\+A\+N\+A\+L\+Y\+Z\+E(\+D\+B\+U\+F)

The example above illustrates changes in function names, data type conversion, and error handling, discussed in detail in thes below.\hypertarget{nc_f77_interface_guide_f77_function_naming_conventions}{}\subsection{A.\+3 Function Naming Conventions }\label{nc_f77_interface_guide_f77_function_naming_conventions}
The net\+C\+D\+F-\/3 Fortran 77 library employs a naming convention intended to make net\+C\+DF programs more readable. For example, the name of the function to rename a variable is now N\+F\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR instead of the previous N\+C\+V\+R\+EN.

All net\+C\+D\+F-\/3 F\+O\+R\+T\+R\+AN function names begin with the N\+F\+\_\+ prefix. The second part of the name is a verb, like G\+ET, P\+UT, I\+NQ (for inquire), or O\+P\+EN. The third part of the name is typically the object of the verb\+: for example D\+IM, V\+AR, or A\+TT for functions dealing with dimensions, variables, or attributes. To distinguish the various I/O operations for variables, a single character modifier is appended to V\+AR\+:


\begin{DoxyItemize}
\item V\+AR entire variable access
\item V\+A\+R1 single value access
\item V\+A\+RA array or array access
\item V\+A\+RS strided access to absample of values
\item V\+A\+RM mapped access to values not contiguous in memory
\end{DoxyItemize}

At the end of the name for variable and attribute functions, there is a component indicating the type of the final argument\+: T\+E\+XT, I\+N\+T1, I\+N\+T2, I\+NT, R\+E\+AL, or D\+O\+U\+B\+LE. This part of the function name indicates the type of the data container you are using in your program\+: character string, 1-\/byte integer, and so on.

Also, all P\+A\+R\+A\+M\+E\+T\+ER names in the public F\+O\+R\+T\+R\+AN interface begin with the prefix N\+F\+\_\+. For example, the P\+A\+R\+A\+M\+E\+T\+ER which was formerly M\+A\+X\+N\+C\+N\+AM is now N\+F\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME, and the former F\+I\+L\+F\+L\+O\+AT is now N\+F\+\_\+\+F\+I\+L\+L\+\_\+\+F\+L\+O\+AT.

As previously mentioned, all the old names are stillpported for backward compatibility.\hypertarget{nc_f77_interface_guide_f77_type_conversion}{}\subsection{A.\+4 Type Conversion }\label{nc_f77_interface_guide_f77_type_conversion}
With the new interface, users need not be aware of the external type of numeric variables, since automatic conversion to or from any desired numeric type is now available. You can use this feature to simplify code, by making it independent of external types. The elimination of type punning prevents some kinds of type errors that could occur with the previous interface. Programs may be made more robust with the new interface, because they need not be changed to accommodate a change to the external type of a variable.

If conversion to or from an external numeric type is necessary, it is handled by the library. This automatic conversion and separation of external data representation from internal data types will become even more important in net\+C\+DF version 4, when new external types will be added for packed data for which there is no natural corresponding internal type, for example, arrays of 11-\/bit values.

Converting from one numeric type to another may rlt in an error if the target type is not capable of representing the converted value. (In net\+C\+D\+F-\/2,ch overflows can only happen in the X\+DR layer.) For example, a R\+E\+AL may not be able to hold data stored externally as an N\+F\+\_\+\+D\+O\+U\+B\+LE (an I\+E\+EE floating-\/point number). When accessing an array of values, an N\+F\+\_\+\+E\+R\+A\+N\+GE error is returned if one or more values are out of the range of representable values, but other values are converted properly.

Note that mere loss of precision in type conversion does not return an error. Thus, if you read double precision values into an I\+N\+T\+E\+G\+ER, for example, no error rlts unless the magnitude of the double precision value exceeds the representable range of I\+N\+T\+E\+G\+E\+Rs on your platform. Similarly, if you read a large integer into a R\+E\+AL incapable of representing all the bits of the integer in its mantissa, this loss There are two new functions in net\+C\+D\+F-\/3 that don’t correspond to any net\+C\+D\+F-\/2 functions\+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+L\+I\+B\+V\+E\+RS and N\+F\+\_\+\+S\+T\+R\+E\+R\+R\+OR. The version ation The previous implementation returned an error when the same dimension was used more than once in specifying the shape of a variable in ncvardef. This restriction is relaxed in the net\+C\+D\+F-\/3 implementation, because an autocorrelation matrix is a good example where using the same dimension twice makes sense.

In the new interface, units for the I\+M\+AP argument to the N\+F\+\_\+\+P\+U\+T\+\_\+\+V\+A\+RM and N\+F\+\_\+\+G\+E\+T\+\_\+\+V\+A\+RM families of functions are now in terms of the number of data elements of the desired internal type, not in terms of bytes as in the net\+C\+DF version-\/2 mapped access interfaces.

Following is a table of net\+C\+D\+F-\/2 function names and names of the corresponding net\+C\+D\+F-\/3 functions. For parameter lists of net\+C\+D\+F-\/2 functions, see the net\+C\+D\+F-\/2 User’s Guide.

{\ttfamily N\+C\+A\+B\+OR} \+: N\+F\+\_\+\+A\+B\+O\+RT

{\ttfamily N\+C\+A\+C\+PY} \+: N\+F\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT

{\ttfamily N\+C\+A\+D\+EL} \+: N\+F\+\_\+\+D\+E\+L\+\_\+\+A\+TT

{\ttfamily N\+C\+A\+GT} \+: N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE, N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+R\+E\+AL, N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+I\+NT, N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T1, N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T2

{\ttfamily N\+C\+A\+G\+TC} \+: N\+F\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T\+\_\+\+T\+E\+XT

{\ttfamily N\+C\+A\+I\+NQ} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+TT, N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+ID, N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+L\+EN, N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+T\+Y\+PE

{\ttfamily N\+C\+A\+N\+AM} \+: N\+F\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME

{\ttfamily N\+C\+A\+PT} \+: N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+D\+O\+U\+B\+LE, N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+R\+E\+AL, N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+I\+NT, N\+F\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T\+\_\+\+I\+N\+T1\+N\+F\+\_\+\+P\+UT\hypertarget{nc_f77_interface_guide_f77_interface_summary}{}\section{B. Summary of F\+O\+R\+T\+R\+A\+N 77 Interface }\label{nc_f77_interface_guide_f77_interface_summary}
Input parameters are in upper case, output parameters are in lower case. The F\+O\+R\+T\+R\+AN types of all the parameters are listed alphabetically by parameter name below the function declarations.

 


\begin{DoxyCode}
CHARACTER*80 FUNCTION  NF\_INQ\_LIBVERS()
CHARACTER*80 FUNCTION  NF\_STRERROR  (NCERR)
INTEGER FUNCTION  NF\_CREATE         (PATH, CMODE, ncid)
INTEGER FUNCTION  NF\_OPEN           (PATH, MODE, ncid)
INTEGER FUNCTION  NF\_SET\_FILL       (NCID, FILLMODE, old\_mode)
INTEGER FUNCTION  NF\_REDEF          (NCID)
INTEGER FUNCTION  NF\_ENDDEF         (NCID)
INTEGER FUNCTION  NF\_SYNC           (NCID)
INTEGER FUNCTION  NF\_ABORT          (NCID)
INTEGER FUNCTION  NF\_CLOSE          (NCID)
INTEGER FUNCTION  NF\_INQ            (NCID, ndims, nvars, ngatts,
                                     unlimdimid)
INTEGER FUNCTION  NF\_INQ\_NDIMS      (NCID, ndims)
INTEGER FUNCTION  NF\_INQ\_NVARS      (NCID, nvars)
INTEGER FUNCTION  NF\_INQ\_NATTS      (NCID, ngatts)
INTEGER FUNCTION  NF\_INQ\_UNLIMDIM   (NCID, unlimdimid)
INTEGER FUNCTION  NF\_DEF\_DIM        (NCID, NAME, LEN, dimid)
INTEGER FUNCTION  NF\_INQ\_DIMID      (NCID, NAME, dimid)
INTEGER FUNCTION  NF\_INQ\_DIM        (NCID, DIMID, name, len)
INTEGER FUNCTION  NF\_INQ\_DIMNAME    (NCID, DIMID, name)
INTEGER FUNCTION  NF\_INQ\_DIMLEN     (NCID, DIMID, len)
INTEGER FUNCTION  NF\_RENAME\_DIM     (NCID, DIMID, NAME)

INTEGER FUNCTION  NF\_DEF\_VAR        (NCID, NAME, XTYPE, NDIMS, DIMIDS,
                                     varid)
INTEGER FUNCTION  NF\_INQ\_VAR        (NCID, VARID, name, xtype, ndims,
                                     dimids, natts)
INTEGER FUNCTION  NF\_INQ\_VARID      (NCID, NAME, varid)
INTEGER FUNCTION  NF\_INQ\_VARNAME    (NCID, VARID, name)
INTEGER FUNCTION  NF\_INQ\_VARTYPE    (NCID, VARID, xtype)
INTEGER FUNCTION  NF\_INQ\_VARNDIMS   (NCID, VARID, ndims)
INTEGER FUNCTION  NF\_INQ\_VARDIMID   (NCID, VARID, DIMIDS)
INTEGER FUNCTION  NF\_INQ\_VARNATTS   (NCID, VARID, natts)
INTEGER FUNCTION  NF\_RENAME\_VAR     (NCID, VARID, NAME)
INTEGER FUNCTION  NF\_PUT\_VAR\_TEXT   (NCID, VARID, TEXT)
INTEGER FUNCTION  NF\_GET\_VAR\_TEXT   (NCID, VARID, text)
INTEGER FUNCTION  NF\_PUT\_VAR\_INT1   (NCID, VARID, I1VAL)
INTEGER FUNCTION  NF\_GET\_VAR\_INT1   (NCID, VARID, i1val)
INTEGER FUNCTION  NF\_PUT\_VAR\_INT2   (NCID, VARID, I2VAL)
INTEGER FUNCTION  NF\_GET\_VAR\_INT2   (NCID, VARID, i2val)
INTEGER FUNCTION  NF\_PUT\_VAR\_INT    (NCID, VARID, IVAL)
INTEGER FUNCTION  NF\_GET\_VAR\_INT    (NCID, VARID, ival)
INTEGER FUNCTION  NF\_PUT\_VAR\_REAL   (NCID, VARID, RVAL)
INTEGER FUNCTION  NF\_GET\_VAR\_REAL   (NCID, VARID, rval)
INTEGER FUNCTION  NF\_PUT\_VAR\_DOUBLE (NCID, VARID, DVAL)
INTEGER FUNCTION  NF\_GET\_VAR\_DOUBLE (NCID, VARID, dval)
INTEGER FUNCTION  NF\_PUT\_VAR1\_TEXT  (NCID, VARID, INDEX, TEXT)
INTEGER FUNCTION  NF\_GET\_VAR1\_TEXT  (NCID, VARID, INDEX, text)
INTEGER FUNCTION  NF\_PUT\_VAR1\_INT1  (NCID, VARID, INDEX, I1VAL)
INTEGER FUNCTION  NF\_GET\_VAR1\_INT1  (NCID, VARID, INDEX, i1val)
INTEGER FUNCTION  NF\_PUT\_VAR1\_INT2  (NCID, VARID, INDEX, I2VAL)
INTEGER FUNCTION  NF\_GET\_VAR1\_INT2  (NCID, VARID, INDEX, i2val)
INTEGER FUNCTION  NF\_PUT\_VAR1\_INT   (NCID, VARID, INDEX, IVAL)
INTEGER FUNCTION  NF\_GET\_VAR1\_INT   (NCID, VARID, INDEX, ival)
INTEGER FUNCTION  NF\_PUT\_VAR1\_REAL  (NCID, VARID, INDEX, RVAL)
INTEGER FUNCTION  NF\_GET\_VAR1\_REAL  (NCID, VARID, INDEX, rval)
INTEGER FUNCTION  NF\_PUT\_VAR1\_DOUBLE(NCID, VARID, INDEX, DVAL)
INTEGER FUNCTION  NF\_GET\_VAR1\_DOUBLE(NCID, VARID, INDEX, dval)
INTEGER FUNCTION  NF\_PUT\_VARA\_TEXT  (NCID, VARID, START, COUNT, TEXT)
INTEGER FUNCTION  NF\_GET\_VARA\_TEXT  (NCID, VARID, START, COUNT, text)
INTEGER FUNCTION  NF\_PUT\_VARA\_INT1  (NCID, VARID, START, COUNT, I1VALS)
INTEGER FUNCTION  NF\_GET\_VARA\_INT1  (NCID, VARID, START, COUNT, i1vals)
INTEGER FUNCTION  NF\_PUT\_VARA\_INT2  (NCID, VARID, START, COUNT, I2VALS)
INTEGER FUNCTION  NF\_GET\_VARA\_INT2  (NCID, VARID, START, COUNT, i2vals)
INTEGER FUNCTION  NF\_PUT\_VARA\_INT   (NCID, VARID, START, COUNT, IVALS)
INTEGER FUNCTION  NF\_GET\_VARA\_INT   (NCID, VARID, START, COUNT, ivals)
INTEGER FUNCTION  NF\_PUT\_VARA\_REAL  (NCID, VARID, START, COUNT, RVALS)
INTEGER FUNCTION  NF\_GET\_VARA\_REAL  (NCID, VARID, START, COUNT, rvals)
INTEGER FUNCTION  NF\_PUT\_VARA\_DOUBLE(NCID, VARID, START, COUNT, DVALS)
INTEGER FUNCTION  NF\_GET\_VARA\_DOUBLE(NCID, VARID, START, COUNT, dvals)
INTEGER FUNCTION  NF\_PUT\_VARS\_TEXT  (NCID, VARID, START, COUNT, STRIDE,
                                     TEXT)
INTEGER FUNCTION  NF\_GET\_VARS\_TEXT  (NCID, VARID, START, COUNT, STRIDE,
                                     text)
INTEGER FUNCTION  NF\_PUT\_VARS\_INT1  (NCID, VARID, START, COUNT, STRIDE,
                                     I1VALS)
INTEGER FUNCTION  NF\_GET\_VARS\_INT1  (NCID, VARID, START, COUNT, STRIDE,
                                     i1vals)
INTEGER FUNCTION  NF\_PUT\_VARS\_INT2  (NCID, VARID, START, COUNT, STRIDE,
                                     I2VALS)
INTEGER FUNCTION  NF\_GET\_VARS\_INT2  (NCID, VARID, START, COUNT, STRIDE,
                                     i2vals)
INTEGER FUNCTION  NF\_PUT\_VARS\_INT   (NCID, VARID, START, COUNT, STRIDE,
                                     IVALS)
INTEGER FUNCTION  NF\_GET\_VARS\_INT   (NCID, VARID, START, COUNT, STRIDE,
                                     ivals)
INTEGER FUNCTION  NF\_PUT\_VARS\_REAL  (NCID, VARID, START, COUNT, STRIDE,
                                     RVALS)
INTEGER FUNCTION  NF\_GET\_VARS\_REAL  (NCID, VARID, START, COUNT, STRIDE,
                                     rvals)
INTEGER FUNCTION  NF\_PUT\_VARS\_DOUBLE(NCID, VARID, START, COUNT, STRIDE,
                                     DVALS)
INTEGER FUNCTION  NF\_GET\_VARS\_DOUBLE(NCID, VARID, START, COUNT, STRIDE,
                                     dvals)
INTEGER FUNCTION  NF\_PUT\_VARM\_TEXT  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, TEXT)
INTEGER FUNCTION  NF\_GET\_VARM\_TEXT  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, text)
INTEGER FUNCTION  NF\_PUT\_VARM\_INT1  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, I1VALS)
INTEGER FUNCTION  NF\_GET\_VARM\_INT1  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, i1vals)
INTEGER FUNCTION  NF\_PUT\_VARM\_INT2  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, I2VALS)
INTEGER FUNCTION  NF\_GET\_VARM\_INT2  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, i2vals)
INTEGER FUNCTION  NF\_PUT\_VARM\_INT   (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, IVALS)
INTEGER FUNCTION  NF\_GET\_VARM\_INT   (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, ivals)
INTEGER FUNCTION  NF\_PUT\_VARM\_REAL  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, RVALS)
INTEGER FUNCTION  NF\_GET\_VARM\_REAL  (NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, rvals)
INTEGER FUNCTION  NF\_PUT\_VARM\_DOUBLE(NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, DVALS)
INTEGER FUNCTION  NF\_GET\_VARM\_DOUBLE(NCID, VARID, START, COUNT, STRIDE,
                                     IMAP, dvals)

INTEGER FUNCTION  NF\_INQ\_ATT        (NCID, VARID, NAME, xtype, len)
INTEGER FUNCTION  NF\_INQ\_ATTID      (NCID, VARID, NAME, attnum)
INTEGER FUNCTION  NF\_INQ\_ATTTYPE    (NCID, VARID, NAME, xtype)
INTEGER FUNCTION  NF\_INQ\_ATTLEN     (NCID, VARID, NAME, len)
INTEGER FUNCTION  NF\_INQ\_ATTNAME    (NCID, VARID, ATTNUM, name)
INTEGER FUNCTION  NF\_COPY\_ATT       (NCID\_IN, VARID\_IN, NAME,
                                     NCID\_OUT, VARID\_OUT)
INTEGER FUNCTION  NF\_RENAME\_ATT     (NCID, VARID, CURNAME, NEWNAME)
INTEGER FUNCTION  NF\_DEL\_ATT        (NCID, VARID, NAME)
INTEGER FUNCTION  NF\_PUT\_ATT\_TEXT   (NCID, VARID, NAME, LEN, TEXT)
INTEGER FUNCTION  NF\_GET\_ATT\_TEXT   (NCID, VARID, NAME, text)
INTEGER FUNCTION  NF\_PUT\_ATT\_INT1   (NCID, VARID, NAME, XTYPE, LEN,
                                     I1VALS)
INTEGER FUNCTION  NF\_GET\_ATT\_INT1   (NCID, VARID, NAME, i1vals)
INTEGER FUNCTION  NF\_PUT\_ATT\_INT2   (NCID, VARID, NAME, XTYPE, LEN,
                                     I2VALS)
INTEGER FUNCTION  NF\_GET\_ATT\_INT2   (NCID, VARID, NAME, i2vals)
INTEGER FUNCTION  NF\_PUT\_ATT\_INT    (NCID, VARID, NAME, XTYPE, LEN,
                                     IVALS)
INTEGER FUNCTION  NF\_GET\_ATT\_INT    (NCID, VARID, NAME, ivals)
INTEGER FUNCTION  NF\_PUT\_ATT\_REAL   (NCID, VARID, NAME, XTYPE, LEN,
                                     RVALS)
INTEGER FUNCTION  NF\_GET\_ATT\_REAL   (NCID, VARID, NAME, rvals)
INTEGER FUNCTION  NF\_PUT\_ATT\_DOUBLE (NCID, VARID, NAME, XTYPE, LEN,
                                     DVALS)
INTEGER FUNCTION  NF\_GET\_ATT\_DOUBLE (NCID, VARID, NAME, dvals)

INTEGER       ATTNUM       ! attribute number
INTEGER       attnum       ! returned attribute number
INTEGER       CMODE        ! NF\_NOCLOBBER, NF\_SHARE flags expression
INTEGER       COUNT        ! array of edge lengths of block of values
CHARACTER(*)  CURNAME      ! current name (before renaming)
INTEGER       DIMID        ! dimension ID
INTEGER       dimid        ! returned dimension ID
INTEGER       DIMIDS       ! list of dimension IDs
INTEGER       dimids       ! list of returned dimension IDs
DOUBLEPRECISION  DVAL      ! single data value
DOUBLEPRECISION  dval      ! returned single data value
DOUBLEPRECISION  DVALS     ! array of data values
DOUBLEPRECISION  dvals     ! array of returned data values
INTEGER       FILLMODE     ! NF\_NOFILL or NF\_FILL, for setting fill mode
INTEGER*1     I1VAL        ! single data value
INTEGER*1     I1val        ! returned single data value
INTEGER*1     I1VALS       ! array of data values
INTEGER*1     i1vals       ! array of returned data values
INTEGER*2     I2VAL        ! single data value
INTEGER*2     i2val        ! returned single data value
INTEGER*2     I2VALS       ! array of data values
INTEGER*2     i2vals       ! array of returned data values
INTEGER       IMAP         ! index mapping vector
INTEGER       INDEX        ! variable array index vector
INTEGER       IVAL         ! single data value
INTEGER       ival         ! returned single data value
INTEGER       IVALS        ! array of data values
INTEGER       ivals        ! array of returned data values
INTEGER       LEN          ! dimension or attribute length
INTEGER       len          ! returned dimension or attribute length
INTEGER       MODE         ! open mode, one of NF\_WRITE or NF\_NOWRITE
CHARACTER(*)  NAME         ! dimension, variable, or attribute name
CHARACTER(*)  name         ! returned dim, var, or att name
INTEGER       natts        ! returned number of attributes
INTEGER       NCERR        ! error returned from NF\_xxx function call
INTEGER       NCID         ! netCDF ID of an open netCDF dataset
INTEGER       ncid         ! returned netCDF ID
INTEGER       NCID\_IN      ! netCDF ID of open source netCDF dataset
INTEGER       NCID\_OUT     ! netCDF ID of open destination netCDF dataset
INTEGER       NDIMS        ! number of dimensions
INTEGER       ndims        ! returned number of dimensions
CHARACTER(*)  NEWNAME      ! new name for dim, var, or att
INTEGER       ngatts       ! returned number of global attributes
INTEGER       nvars        ! returned number of variables
INTEGER       old\_mode     ! previous fill mode, NF\_NOFILL or NF\_FILL,
CHARACTER(*)  PATH         ! name of netCDF dataset
REAL          RVAL         ! single data value
REAL          rval         ! returned single data value
REAL          RVALS        ! array of data values
REAL          rvals        ! array of returned data values
INTEGER       START        ! variable array indices of first value
INTEGER       STRIDE       ! variable array dimensional strides
CHARACTER(*)  TEXT         ! input text value
CHARACTER(*)  text         ! returned text value
INTEGER       unlimdimid   ! returned ID of unlimited dimension
INTEGER       VARID        ! variable ID
INTEGER       varid        ! returned variable ID
INTEGER       VARID\_IN     ! variable ID
INTEGER       VARID\_OUT    ! variable ID
INTEGER       XTYPE        ! external type: NF\_BYTE, NF\_CHAR, ... ,
INTEGER       xtype        ! returned external type
\end{DoxyCode}
 