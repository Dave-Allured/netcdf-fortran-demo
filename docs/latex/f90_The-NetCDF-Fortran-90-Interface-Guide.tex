This document describes the Fortran 90 interface to the net\+C\+DF library.

You can use the net\+C\+DF library without knowing about all of the net\+C\+DF interface. If you are creating a net\+C\+DF dataset, only a handful of routines are required to define the necessary dimensions, variables, and attributes, and to write the data to the net\+C\+DF dataset. Similarly, if you are writing software to access data stored in a particular net\+C\+DF object, only a small subset of the net\+C\+DF library is required to open the net\+C\+DF dataset and access the data. Authors of generic applications that access arbitrary net\+C\+DF datasets need to be familiar with more of the net\+C\+DF library.


\begin{DoxyItemize}
\item \hyperlink{f90-use-of-the-netcdf-library}{1 Use of the Net\+C\+DF Library}
\item \hyperlink{f90_datasets}{2 Datasets}
\item \hyperlink{f90_groups}{3 Groups}
\item \hyperlink{f90_dimensions}{4 Dimensions}
\item \hyperlink{f90-user-defined-data-types}{5 User Defined Data Types}
\item \hyperlink{f90-variables}{6 Variables}
\item \hyperlink{f90-attributes}{7 Attributes} 
\end{DoxyItemize}\hypertarget{f90-use-of-the-netcdf-library}{}\section{1 Use of the Net\+C\+DF Library}\label{f90-use-of-the-netcdf-library}
In this chapter we provide templates of common sequences of net\+C\+DF calls needed for common uses. For clarity we present only the names of routines; omit declarations and error checking; omit the type-\/specific suffixes of routine names for variables and attributes; indent statements that are typically invoked multiple times; and use ... to represent arbitrary sequences of other statements. Full parameter lists are described in later chapters.\hypertarget{f90-use-of-the-netcdf-library_f90-creating-a-netcdf-dataset}{}\subsection{1.\+1 Creating a Net\+C\+D\+F Dataset }\label{f90-use-of-the-netcdf-library_f90-creating-a-netcdf-dataset}
Here is a typical sequence of net\+C\+DF calls used to create a new net\+C\+DF dataset\+:


\begin{DoxyCode}
nf90\_create           \textcolor{comment}{! create netCDF dataset: enter define mode}
     ...
   nf90\_def\_dim       \textcolor{comment}{! define dimensions: from name and length}
     ...
   nf90\_def\_var       \textcolor{comment}{! define variables: from name, type, dims}
     ...
   nf90\_put\_att       \textcolor{comment}{! assign attribute values}
     ...
nf90\_enddef           \textcolor{comment}{! end definitions: leave define mode}
     ...
   nf90\_put\_var       \textcolor{comment}{! provide values for variable}
     ...
nf90\_close            ! close: \textcolor{keywordtype}{save} new netcdf dataset
\end{DoxyCode}


Only one call is needed to create a net\+C\+DF dataset, at which point you will be in the first of two net\+C\+DF modes. When accessing an open net\+C\+DF dataset, it is either in define mode or data mode. In define mode, you can create dimensions, variables, and new attributes, but you cannot read or write variable data. In data mode, you can access data and change existing attributes, but you are not permitted to create new dimensions, variables, or attributes.

One call to N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM is needed for each dimension created. Similarly, one call to N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR is needed for each variable creation, and one call to a member of the N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT family is needed for each attribute defined and assigned a value. To leave define mode and enter data mode, call N\+F90\+\_\+\+E\+N\+D\+D\+EF.

Once in data mode, you can add new data to variables, change old values, and change values of existing attributes (so long as the attribute changes do not require more storage space). Data of all types is written to a net\+C\+DF variable using the N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR subroutine. Single values, arrays, or array sections may be supplied to N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR; optional arguments allow the writing of subsampled or mapped portions of the variable. (Subsampled and mapped access are general forms of data access that are explained later.)

Finally, you should explicitly close all net\+C\+DF datasets that have been opened for writing by calling N\+F90\+\_\+\+C\+L\+O\+SE. By default, access to the file system is buffered by the net\+C\+DF library. If a program terminates abnormally with net\+C\+DF datasets open for writing, your most recent modifications may be lost. This default buffering of data is disabled by setting the N\+F90\+\_\+\+S\+H\+A\+RE flag when opening the dataset. But even if this flag is set, changes to attribute values or changes made in define mode are not written out until N\+F90\+\_\+\+S\+Y\+NC or N\+F90\+\_\+\+C\+L\+O\+SE is called.\hypertarget{f90-use-of-the-netcdf-library_f90-reading-a-netcdf-dataset-with-known-names}{}\subsection{1.\+2 Reading a Net\+C\+D\+F Dataset with Known Names }\label{f90-use-of-the-netcdf-library_f90-reading-a-netcdf-dataset-with-known-names}
Here we consider the case where you know the names of not only the net\+C\+DF datasets, but also the names of their dimensions, variables, and attributes. (Otherwise you would have to do \char`\"{}inquire\char`\"{} calls.) The order of typical C calls to read data from those variables in a net\+C\+DF dataset is\+:


\begin{DoxyCode}
nf90\_open               \textcolor{comment}{! open existing netCDF dataset}
     ...
   nf90\_inq\_dimid       \textcolor{comment}{! get dimension IDs}
     ...
   nf90\_inq\_varid       \textcolor{comment}{! get variable IDs}
     ...
   nf90\_get\_att         \textcolor{comment}{! get attribute values}
     ...
   nf90\_get\_var         \textcolor{comment}{! get values of variables}
     ...
nf90\_close              ! \textcolor{keyword}{close} netcdf dataset
\end{DoxyCode}


First, a single call opens the net\+C\+DF dataset, given the dataset name, and returns a net\+C\+DF ID that is used to refer to the open net\+C\+DF dataset in all subsequent calls.

Next, a call to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID for each dimension of interest gets the dimension ID from the dimension name. Similarly, each required variable ID is determined from its name by a call to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID. Once variable I\+Ds are known, variable attribute values can be retrieved using the net\+C\+DF ID, the variable ID, and the desired attribute name as input to N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+TT for each desired attribute. Variable data values can be directly accessed from the net\+C\+DF dataset with calls to N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR.

Finally, the net\+C\+DF dataset is closed with N\+F90\+\_\+\+C\+L\+O\+SE. There is no need to close a dataset open only for reading.\hypertarget{f90-use-of-the-netcdf-library_f90-reading-a-netcdf-dataset-with-unknown-names}{}\subsection{1.\+3 Reading a net\+C\+D\+F Dataset with Unknown Names }\label{f90-use-of-the-netcdf-library_f90-reading-a-netcdf-dataset-with-unknown-names}
It is possible to write programs (e.\+g., generic software) which do such things as processing every variable, without needing to know in advance the names of these variables. Similarly, the names of dimensions and attributes may be unknown.

Names and other information about net\+C\+DF objects may be obtained from net\+C\+DF datasets by calling inquire functions. These return information about a whole net\+C\+DF dataset, a dimension, a variable, or an attribute. The following template illustrates how they are used\+:


\begin{DoxyCode}
nf90\_open                 \textcolor{comment}{! open existing netCDF dataset}
  ...
nf90\_inquire              \textcolor{comment}{! find out what is in it}
     ...
   nf90\_inquire\_dimension \textcolor{comment}{! get dimension names, lengths}
     ...
   nf90\_inquire\_variable  \textcolor{comment}{! get variable names, types, shapes}
        ...
      nf90\_inq\_attname    \textcolor{comment}{! get attribute names}
        ...
      nf90\_inquire\_attribute \textcolor{comment}{! get other attribute information}
        ...
      nf90\_get\_att        \textcolor{comment}{! get attribute values}
        ...
   nf90\_get\_var           \textcolor{comment}{! get values of variables}
     ...
nf90\_close                ! \textcolor{keyword}{close} netcdf dataset
\end{DoxyCode}


As in the previous example, a single call opens the existing net\+C\+DF dataset, returning a net\+C\+DF ID. This net\+C\+DF ID is given to the N\+F90\+\_\+\+I\+N\+Q\+U\+I\+RE routine, which returns the number of dimensions, the number of variables, the number of global attributes, and the ID of the unlimited dimension, if there is one.

All the inquire functions are inexpensive to use and require no I/O, since the information they provide is stored in memory when a net\+C\+DF dataset is first opened.

Dimension I\+Ds use consecutive integers, beginning at 1. Also dimensions, once created, cannot be deleted. Therefore, knowing the number of dimension I\+Ds in a net\+C\+DF dataset means knowing all the dimension I\+Ds\+: they are the integers 1, 2, 3, ...up to the number of dimensions. For each dimension ID, a call to the inquire function N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+D\+I\+M\+E\+N\+S\+I\+ON returns the dimension name and length.

Variable I\+Ds are also assigned from consecutive integers 1, 2, 3, ... up to the number of variables. These can be used in N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+V\+A\+R\+I\+A\+B\+LE calls to find out the names, types, shapes, and the number of attributes assigned to each variable.

Once the number of attributes for a variable is known, successive calls to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME return the name for each attribute given the net\+C\+DF ID, variable ID, and attribute number. Armed with the attribute name, a call to N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE returns its type and length. Given the type and length, you can allocate enough space to hold the attribute values. Then a call to N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+TT returns the attribute values.

Once the I\+Ds and shapes of net\+C\+DF variables are known, data values can be accessed by calling N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR.\hypertarget{f90-use-of-the-netcdf-library_f90-writing-data-in-an-existing-netcdf-dataset}{}\subsection{1.\+4 Writing Data in an Existing Net\+C\+D\+F Dataset }\label{f90-use-of-the-netcdf-library_f90-writing-data-in-an-existing-netcdf-dataset}
With write access to an existing net\+C\+DF dataset, you can overwrite data values in existing variables or append more data to record variables along the unlimited (record) dimension. To append more data to non-\/record variables requires changing the shape of such variables, which means creating a new net\+C\+DF dataset, defining new variables with the desired shape, and copying data. The net\+C\+DF data model was not designed to make such \char`\"{}schema changes\char`\"{} efficient or easy, so it is best to specify the shapes of variables correctly when you create a net\+C\+DF dataset, and to anticipate which variables will later grow by using the unlimited dimension in their definition.

The following code template lists a typical sequence of calls to overwrite some existing values and add some new records to record variables in an existing net\+C\+DF dataset with known variable names\+:


\begin{DoxyCode}
nf90\_open             \textcolor{comment}{! open existing netCDF dataset}
  ...
  nf90\_inq\_varid      \textcolor{comment}{! get variable IDs}
  ...
  nf90\_put\_var        \textcolor{comment}{! provide new values for variables, if any}
  ...
  nf90\_put\_att        \textcolor{comment}{! provide new values for attributes, if any}
    ...
nf90\_close            ! \textcolor{keyword}{close} netcdf dataset
\end{DoxyCode}


A net\+C\+DF dataset is first opened by the N\+F90\+\_\+\+O\+P\+EN call. This call puts the open dataset in data mode, which means existing data values can be accessed and changed, existing attributes can be changed, but no new dimensions, variables, or attributes can be added.

Next, calls to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID get the variable ID from the name, for each variable you want to write. Then each call to N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR writes data into a specified variable, either a single value at a time, or a whole set of values at a time, depending on which variant of the interface is used. The calls used to overwrite values of non-\/record variables are the same as are used to overwrite values of record variables or append new data to record variables. The difference is that, with record variables, the record dimension is extended by writing values that don’t yet exist in the dataset. This extends all record variables at once, writing \char`\"{}fill values\char`\"{} for record variables for which the data has not yet been written (but see section \href{#Fill-Values}{\tt Fill Values} to specify different behavior).

Calls to N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT may be used to change the values of existing attributes, although data that changes after a file is created is typically stored in variables rather than attributes.

Finally, you should explicitly close any net\+C\+DF datasets into which data has been written by calling N\+F90\+\_\+\+C\+L\+O\+SE before program termination. Otherwise, modifications to the dataset may be lost.\hypertarget{f90-use-of-the-netcdf-library_f90-adding-new-dimensions-variables-attributes}{}\subsection{1.\+5 Adding New Dimensions, Variables, Attributes }\label{f90-use-of-the-netcdf-library_f90-adding-new-dimensions-variables-attributes}
An existing net\+C\+DF dataset can be extensively altered. New dimensions, variables, and attributes can be added or existing ones renamed, and existing attributes can be deleted. Existing dimensions, variables, and attributes can be renamed. The following code template lists a typical sequence of calls to add new net\+C\+DF components to an existing dataset\+:


\begin{DoxyCode}
nf90\_open             \textcolor{comment}{! open existing netCDF dataset}
  ...
nf90\_redef            \textcolor{comment}{! put it into define mode}
    ...
  nf90\_def\_dim        \textcolor{comment}{! define additional dimensions (if any)}
    ...
  nf90\_def\_var        \textcolor{comment}{! define additional variables (if any)}
    ...
  nf90\_put\_att        \textcolor{comment}{! define other attributes (if any)}
    ...
nf90\_enddef           \textcolor{comment}{! check definitions, leave define mode}
    ...
  nf90\_put\_var        \textcolor{comment}{! provide new variable values}
    ...
nf90\_close            ! \textcolor{keyword}{close} netcdf dataset
\end{DoxyCode}


A net\+C\+DF dataset is first opened by the N\+F90\+\_\+\+O\+P\+EN call. This call puts the open dataset in data mode, which means existing data values can be accessed and changed, existing attributes can be changed (so long as they do not grow), but nothing can be added. To add new net\+C\+DF dimensions, variables, or attributes you must enter define mode, by calling N\+F90\+\_\+\+R\+E\+D\+EF. In define mode, call N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM to define new dimensions, N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR to define new variables, and N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT to assign new attributes to variables or enlarge old attributes.

You can leave define mode and reenter data mode, checking all the new definitions for consistency and committing the changes to disk, by calling N\+F90\+\_\+\+E\+N\+D\+D\+EF. If you do not wish to reenter data mode, just call N\+F90\+\_\+\+C\+L\+O\+SE, which will have the effect of first calling N\+F90\+\_\+\+E\+N\+D\+D\+EF.

Until the N\+F90\+\_\+\+E\+N\+D\+D\+EF call, you may back out of all the redefinitions made in define mode and restore the previous state of the net\+C\+DF dataset by calling N\+F90\+\_\+\+A\+B\+O\+RT. You may also use the N\+F90\+\_\+\+A\+B\+O\+RT call to restore the net\+C\+DF dataset to a consistent state if the call to N\+F90\+\_\+\+E\+N\+D\+D\+EF fails. If you have called N\+F90\+\_\+\+C\+L\+O\+SE from definition mode and the implied call to N\+F90\+\_\+\+E\+N\+D\+D\+EF fails, N\+F90\+\_\+\+A\+B\+O\+RT will automatically be called to close the net\+C\+DF dataset and leave it in its previous consistent state (before you entered define mode).

At most one process should have a net\+C\+DF dataset open for writing at one time. The library is designed to provide limited support for multiple concurrent readers with one writer, via disciplined use of the N\+F90\+\_\+\+S\+Y\+NC function and the N\+F90\+\_\+\+S\+H\+A\+RE flag. If a writer makes changes in define mode, such as the addition of new variables, dimensions, or attributes, some means external to the library is necessary to prevent readers from making concurrent accesses and to inform readers to call N\+F90\+\_\+\+S\+Y\+NC before the next access.\hypertarget{f90-use-of-the-netcdf-library_f90-error-handling}{}\subsection{1.\+6 Error Handling }\label{f90-use-of-the-netcdf-library_f90-error-handling}
The net\+C\+DF library provides the facilities needed to handle errors in a flexible way. Each net\+C\+DF function returns an integer status value. If the returned status value indicates an error, you may handle it in any way desired, from printing an associated error message and exiting to ignoring the error indication and proceeding (not recommended!). For simplicity, the examples in this guide check the error status and call a separate function to handle any errors.

The N\+F90\+\_\+\+S\+T\+R\+E\+R\+R\+OR function is available to convert a returned integer error status into an error message string.

Occasionally, low-\/level I/O errors may occur in a layer below the net\+C\+DF library. For example, if a write operation causes you to exceed disk quotas or to attempt to write to a device that is no longer available, you may get an error from a layer below the net\+C\+DF library, but the resulting write error will still be reflected in the returned status value.\hypertarget{f90-use-of-the-netcdf-library_f90-compiling-and-linking-with-the-netcdf-library}{}\subsection{1.\+7 Compiling and Linking with the Net\+C\+D\+F Library }\label{f90-use-of-the-netcdf-library_f90-compiling-and-linking-with-the-netcdf-library}
Details of how to compile and link a program that uses the net\+C\+DF C or Fortran interfaces differ, depending on the operating system, the available compilers, and where the net\+C\+DF library and include files are installed. Nevertheless, we provide here examples of how to compile and link a program that uses the net\+C\+DF library on a Unix platform, so that you can adjust these examples to fit your installation.

Every Fortran 90 procedure or module which references net\+C\+DF constants or procedures must have access to the module information created when the net\+C\+DF module was compiled. The suffix for this file is “\+M\+O\+D” (or sometimes “mod”).

Most F90 compilers allow the user to specify the location of .M\+OD files, usually with the -\/I flag.

\begin{DoxyVerb}$ f90 -c -I/usr/local/include mymodule.f90
\end{DoxyVerb}


Starting with version 3.\+6.\+2, another method of building the net\+C\+DF fortran libraries became available. With the –enable-\/separate-\/fortran option to configure, the user can specify that the C library should not contain the fortran functions. In these cases an additional library, libnetcdff.\+a (note the extra “f”) will be built. This library contains the Fortran functions. Since verion 4.\+1.\+3, the net\+C\+DF Fortran software and library is always distinct from the net\+C\+DF C library, but depends on it. If it is installed as a shared library, you need only use ‘-\/lnetcdff’ to specify the Fortran library for linking.

For more information about configure options, See \href{netcdf-install.html#Specifying-the-Environment-for-Building}{\tt Specifying the Environment for Building} in \{No value for ‘i-\/man’\}.

If installed as a shared library, link, using something like\+:

\begin{DoxyVerb}$ f90 -o myprogram myprogram.o -L/usr/local/lib -lnetcdff
\end{DoxyVerb}


If installed as a static library, you will at least need to mention the net\+C\+DF C library and perhaps other libraries, such as hdf5 or curl, depending on how the C library was built. For example\+:

\begin{DoxyVerb}$ f90 -o myprogram myprogram.o -L/usr/local/lib -lnetcdff -lnetcdf
\end{DoxyVerb}


Use of the nf-\/config utility program, installed as part of the netcdf-\/fortran software, provides an easier way to compile and link, without needing to know the details of where the library has been installed, or whether it is installed as a shared or static library.

To see all the options for ‘nf-\/config’, invoke it with the ‘–help’ argument.

Here’s an example of how you could use ‘nf-\/config’ to compile and link a Fortran program in one step\+:

\begin{DoxyVerb}$ f90 myprogram.f90 -o myprogram `nf-config --fflags --flibs`
\end{DoxyVerb}


If it is installed on your system, you could also use the ‘pkg-\/config’ utility to compile and link Fortran programs with the net\+C\+DF libraries. This is especially useful in Makefiles, to insulate them from changes to library versions and dependencies. Here is an example of how you could compile and link a Fortran program with net\+C\+DF libraries using pkg-\/config\+:

\begin{DoxyVerb}$ export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig
$ f90 myprogram.f90 -o myprogram `pkg-config --cflags --libs netcdf-fortran`
\end{DoxyVerb}


where here ‘–cflags’ means compiler flags and ‘libs’ requests that the approriate libraries be linked in. \hypertarget{f90_datasets}{}\section{2 Datasets}\label{f90_datasets}
\hypertarget{f90_datasets_f90-datasets-introduction}{}\subsection{2.\+1 Datasets Introduction }\label{f90_datasets_f90-datasets-introduction}
This chapter presents the interfaces of the net\+C\+DF functions that deal with a net\+C\+DF dataset or the whole net\+C\+DF library.

A net\+C\+DF dataset that has not yet been opened can only be referred to by its dataset name. Once a net\+C\+DF dataset is opened, it is referred to by a net\+C\+DF ID, which is a small nonnegative integer returned when you create or open the dataset. A net\+C\+DF ID is much like a file descriptor in C or a logical unit number in F\+O\+R\+T\+R\+AN. In any single program, the net\+C\+DF I\+Ds of distinct open net\+C\+DF datasets are distinct. A single net\+C\+DF dataset may be opened multiple times and will then have multiple distinct net\+C\+DF I\+Ds; however at most one of the open instances of a single net\+C\+DF dataset should permit writing. When an open net\+C\+DF dataset is closed, the ID is no longer associated with a net\+C\+DF dataset.

Functions that deal with the net\+C\+DF library include\+:


\begin{DoxyItemize}
\item Get version of library.
\item Get error message corresponding to a returned error code.
\end{DoxyItemize}

The operations supported on a net\+C\+DF dataset as a single object are\+:


\begin{DoxyItemize}
\item Create, given dataset name and whether to overwrite or not.
\item Open for access, given dataset name and read or write intent.
\item Put into define mode, to add dimensions, variables, or attributes.
\item Take out of define mode, checking consistency of additions.
\item Close, writing to disk if required.
\item Inquire about the number of dimensions, number of variables, number of global attributes, and ID of the unlimited dimension, if any.
\item Synchronize to disk to make sure it is current.
\item Set and unset nofill mode for optimized sequential writes.
\item After a summary of conventions used in describing the net\+C\+DF interfaces, the rest of this chapter presents a detailed description of the interfaces for these operations.
\end{DoxyItemize}\hypertarget{f90_datasets_f90-netcdf-library-interface-descriptions}{}\subsection{2.\+2 Net\+C\+D\+F Library Interface Descriptions }\label{f90_datasets_f90-netcdf-library-interface-descriptions}
Each interface description for a particular net\+C\+DF function in this and later chapters contains\+:


\begin{DoxyItemize}
\item a description of the purpose of the function;
\item a Fortran 90 interface block that presents the type and order of the formal parameters to the function;
\item a description of each formal parameter in the C interface;
\item a list of possible error conditions; and
\item an example of a Fortran 90 program fragment calling the net\+C\+DF function (and perhaps other net\+C\+DF functions).
\end{DoxyItemize}

The examples follow a simple convention for error handling, always checking the error status returned from each net\+C\+DF function call and calling a handle\+\_\+error function in case an error was detected. For an example of such a function, see Section 5.\+2 \char`\"{}\+Get error message
corresponding to error status\+: nf90\textbackslash{}\+\_\+strerror\char`\"{}.\hypertarget{f90_datasets_f90-nf90_strerror}{}\subsection{2.\+3 N\+F90\+\_\+\+S\+T\+R\+E\+R\+R\+O\+R }\label{f90_datasets_f90-nf90_strerror}
The function N\+F90\+\_\+\+S\+T\+R\+E\+R\+R\+OR returns a static reference to an error message string corresponding to an integer net\+C\+DF error status or to a system error number, presumably returned by a previous call to some other net\+C\+DF function. The list of net\+C\+DF error status codes is available in the appropriate include file for each language binding.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_strerror(ncerr)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: ncerr
  \textcolor{keywordtype}{character(len = 80)}  :: nf90\_strerror
\end{DoxyCode}


{\ttfamily N\+C\+E\+RR}

\+: An error status that might have been returned from a previous call to some net\+C\+DF function.

\subsection*{Errors}

If you provide an invalid integer error status that does not correspond to any net\+C\+DF error message or or to any system error message (as understood by the system strerror function), N\+F90\+\_\+\+S\+T\+R\+E\+R\+R\+OR returns a string indicating that there is no such error status.

\subsection*{Example}

Here is an example of a simple error handling function that uses N\+F90\+\_\+\+S\+T\+R\+E\+R\+R\+OR to print the error message corresponding to the net\+C\+DF error status returned from any net\+C\+DF function call and then exit\+:


\begin{DoxyCode}
\textcolor{keyword}{subroutine }handle\_err(status)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent ( in)} :: status

  \textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keywordflow}{then}
    print *, trim(nf90\_strerror(status))
    stop \textcolor{stringliteral}{"Stopped"}
\textcolor{keywordflow}{  end if}
\textcolor{keyword}{end subroutine }handle\_err
\end{DoxyCode}
\hypertarget{f90_datasets_f90-get-netcdf-library-version-nf90_inq_libvers}{}\subsection{2.\+4 Get net\+C\+D\+F library version\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+L\+I\+B\+V\+E\+R\+S }\label{f90_datasets_f90-get-netcdf-library-version-nf90_inq_libvers}
The function N\+F90\+\_\+\+I\+N\+Q\+\_\+\+L\+I\+B\+V\+E\+RS returns a string identifying the version of the net\+C\+DF library, and when it was built.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_libvers()
  \textcolor{keywordtype}{character(len = 80)} :: nf90\_inq\_libvers
\end{DoxyCode}


\subsection*{Errors}

This function takes no arguments, and returns no error status.

\subsection*{Example}

Here is an example using nf90\+\_\+inq\+\_\+libvers to print the version of the net\+C\+DF library with which the program is linked\+:


\begin{DoxyCode}
print *, trim(nf90\_inq\_libvers())
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_create}{}\subsection{2.\+5 N\+F90\+\_\+\+C\+R\+E\+A\+T\+E }\label{f90_datasets_f90-nf90_create}
This function creates a new net\+C\+DF dataset, returning a net\+C\+DF ID that can subsequently be used to refer to the net\+C\+DF dataset in other net\+C\+DF function calls. The new net\+C\+DF dataset opened for write access and placed in define mode, ready for you to add dimensions, variables, and attributes.

A creation mode flag specifies whether to overwrite any existing dataset with the same name and whether access to the dataset is shared.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_create(path, cmode, ncid, initialsize, bufrsize, cache\_size, &
     cache\_nelems, cache\_preemption, comm, info)
  \textcolor{keywordtype}{implicit none}
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: path
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: cmode
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: initialsize
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(inout)} :: bufrsize
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: cache\_size, cache\_nelems
  \textcolor{keywordtype}{real}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: cache\_preemption
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: comm, info
  \textcolor{keywordtype}{integer} :: nf90\_create
\end{DoxyCode}


{\ttfamily path}

\+: The file name of the new net\+C\+DF dataset.

{\ttfamily cmode}

\+: The creation mode flag. The following flags are available\+: N\+F90\+\_\+\+C\+L\+O\+B\+B\+ER, N\+F90\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER, N\+F90\+\_\+\+S\+H\+A\+RE, N\+F90\+\_\+64\+B\+I\+T\+\_\+\+O\+F\+F\+S\+ET, N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4, and N\+F90\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL. (N\+F90\+\_\+\+H\+D\+F5 is deprecated, use N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4 instead).

A zero value (defined for convenience as N\+F90\+\_\+\+C\+L\+O\+B\+B\+ER) specifies\+: overwrite any existing dataset with the same file name, and buffer and cache accesses for efficiency. The dataset will be in net\+C\+DF classic format. See \href{netcdf.html#NetCDF-Classic-Format-Limitations}{\tt Net\+C\+DF Classic Format Limitations} in Net\+C\+DF Users’ Guide.

Setting N\+F90\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER means you do not want to clobber (overwrite) an existing dataset; an error (N\+F90\+\_\+\+E\+E\+X\+I\+ST) is returned if the specified dataset already exists.

The N\+F90\+\_\+\+S\+H\+A\+RE flag is appropriate when one process may be writing the dataset and one or more other processes reading the dataset concurrently; it means that dataset accesses are not buffered and caching is limited. Since the buffering scheme is optimized for sequential access, programs that do not access data sequentially may see some performance improvement by setting the N\+F90\+\_\+\+S\+H\+A\+RE flag. (This only applies to net\+C\+D\+F-\/3 classic or 64-\/bit offset files.)

Setting N\+F90\+\_\+64\+B\+I\+T\+\_\+\+O\+F\+F\+S\+ET causes net\+C\+DF to create a 64-\/bit offset format file, instead of a net\+C\+DF classic format file. The 64-\/bit offset format imposes far fewer restrictions on very large (i.\+e. over 2 GB) data files. See \href{netcdf.html#Large-File-Support}{\tt Large File Support} in Net\+C\+DF Users’ Guide.

Setting the N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4 flag causes net\+C\+DF to create a net\+C\+D\+F-\/4/\+H\+D\+F5 format output file.

Oring the N\+F90\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL flag with the N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4 flag causes the resulting net\+C\+D\+F-\/4/\+H\+D\+F5 file to restrict itself to the classic model -\/ none of the new net\+C\+D\+F-\/4 data model features, such as groups or user-\/defined types, are allowed in such a file.

{\ttfamily ncid}

\+: Returned net\+C\+DF ID.

The following optional arguments allow additional performance tuning.

{\ttfamily initialsize}

\+: The initial size of the file (in bytes) at creation time. A value of 0 causes the file size to be computed when nf90\+\_\+enddef is called. This is ignored for Net\+C\+D\+F-\/4/\+H\+D\+F5 files.

{\ttfamily bufrsize}

\+: Controls a space versus time trade-\/off, memory allocated in the netcdf library versus number of system calls. Because of internal requirements, the value may not be set to exactly the value requested. The actual value chosen is returned.

The library chooses a system-\/dependent default value if N\+F90\+\_\+\+S\+I\+Z\+E\+H\+I\+N\+T\+\_\+\+D\+E\+F\+A\+U\+LT is supplied as input. If the \char`\"{}preferred I/\+O
    block size\char`\"{} is available from the stat() system call as member st\+\_\+blksize this value is used. Lacking that, twice the system pagesize is used. Lacking a call to discover the system pagesize, the default bufrsize is set to 8192 bytes.

The bufrsize is a property of a given open netcdf descriptor ncid, it is not a persistent property of the netcdf dataset.

This is ignored for Net\+C\+D\+F-\/4/\+H\+D\+F5 files.

{\ttfamily cache\+\_\+size}

\+: If the cache\+\_\+size is provided when creating a net\+C\+D\+F-\/4/\+H\+D\+F5 file, it will be used instead of the default (32000000) as the size, in bytes, of the H\+D\+F5 chunk cache.

{\ttfamily cache\+\_\+nelems}

\+: If cache\+\_\+nelems is provided when creating a net\+C\+D\+F-\/4/\+H\+D\+F5 file, it will be used instead of the default (1000) as the maximum number of elements in the H\+D\+F5 chunk cache.

{\ttfamily cache\+\_\+premtion}

\+: If cache\+\_\+preemption is provided when creating a net\+C\+D\+F-\/4/\+H\+D\+F5 file, it will be used instead of the default (0.\+75) as the preemption value for the H\+D\+F5 chunk cache.

{\ttfamily comm}

\+: If the comm and info parameters are provided the file is created and opened for parallel I/O. Set the comm parameter to the M\+PI communicator (of type M\+P\+I\+\_\+\+Comm). If this parameter is provided the info parameter must also be provided.

{\ttfamily info}

\+: If the comm and info parameters are provided the file is created and opened for parallel I/O. Set the comm parameter to the M\+PI information value (of type M\+P\+I\+\_\+\+Info). If this parameter is provided the comm parameter must also be provided.

\subsection*{Errors}

N\+F90\+\_\+\+C\+R\+E\+A\+TE returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Passing a dataset name that includes a directory that does not exist.
\item Specifying a dataset name of a file that exists and also specifying N\+F90\+\_\+\+N\+O\+C\+L\+O\+B\+B\+ER.
\item Specifying a meaningless value for the creation mode.
\item Attempting to create a net\+C\+DF dataset in a directory where you don’t have permission to create files.
\end{DoxyItemize}

\subsection*{Example}

In this example we create a net\+C\+DF dataset named foo.\+nc; we want the dataset to be created in the current directory only if a dataset with that name does not already exist\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
status = nf90\_create(path = \textcolor{stringliteral}{"foo.nc"}, cmode = nf90\_noclobber, ncid = ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_open}{}\subsection{2.\+6 N\+F90\+\_\+\+O\+P\+E\+N }\label{f90_datasets_f90-nf90_open}
The function N\+F90\+\_\+\+O\+P\+EN opens an existing net\+C\+DF dataset for access.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_open(path, mode, ncid, bufrsize, cache\_size, cache\_nelems, &
                   cache\_preemption, comm, info)
  \textcolor{keywordtype}{implicit none}
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: path
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: mode
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(inout)} :: bufrsize
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: cache\_size, cache\_nelems
  \textcolor{keywordtype}{real}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: cache\_preemption
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: comm, info
  \textcolor{keywordtype}{integer} :: nf90\_open
\end{DoxyCode}


{\ttfamily path}

\+: File name for net\+C\+DF dataset to be opened. This may be an O\+Pe\+N\+D\+AP U\+RL if D\+AP support is enabled.

{\ttfamily mode}

\+: A zero value (or N\+F90\+\_\+\+N\+O\+W\+R\+I\+TE) specifies\+: open the dataset with read-\/only access, buffering and caching accesses for efficiency

Otherwise, the open mode is N\+F90\+\_\+\+W\+R\+I\+TE, N\+F90\+\_\+\+S\+H\+A\+RE, or N\+F90\+\_\+\+W\+R\+I\+T\+E$\vert$\+N\+F90\+\_\+\+S\+H\+A\+RE. Setting the N\+F90\+\_\+\+W\+R\+I\+TE flag opens the dataset with read-\/write access. (\char`\"{}\+Writing\char`\"{} means any kind of change to the dataset, including appending or changing data, adding or renaming dimensions, variables, and attributes, or deleting attributes.) The N\+F90\+\_\+\+S\+H\+A\+RE flag is appropriate when one process may be writing the dataset and one or more other processes reading the dataset concurrently (note that this is not the same as parallel I/O); it means that dataset accesses are not buffered and caching is limited. Since the buffering scheme is optimized for sequential access, programs that do not access data sequentially may see some performance improvement by setting the N\+F90\+\_\+\+S\+H\+A\+RE flag.

{\ttfamily ncid}

\+: Returned net\+C\+DF ID.

The following optional argument allows additional performance tuning.

{\ttfamily bufrsize}

\+: This parameter applies only when opening classic format or 64-\/bit offset files. It is ignored for net\+C\+D\+F-\/4/\+H\+D\+F5 files.

It Controls a space versus time trade-\/off, memory allocated in the netcdf library versus number of system calls. Because of internal requirements, the value may not be set to exactly the value requested. The actual value chosen is returned.

The library chooses a system-\/dependent default value if N\+F90\+\_\+\+S\+I\+Z\+E\+H\+I\+N\+T\+\_\+\+D\+E\+F\+A\+U\+LT is supplied as input. If the \char`\"{}preferred I/\+O
    block size\char`\"{} is available from the stat() system call as member st\+\_\+blksize this value is used. Lacking that, twice the system pagesize is used. Lacking a call to discover the system pagesize, the default bufrsize is set to 8192 bytes.

The bufrsize is a property of a given open netcdf descriptor ncid, it is not a persistent property of the netcdf dataset.

{\ttfamily cache\+\_\+size}

\+: If the cache\+\_\+size is provided when opening a net\+C\+D\+F-\/4/\+H\+D\+F5 file, it will be used instead of the default (32000000) as the size, in bytes, of the H\+D\+F5 chunk cache.

{\ttfamily cache\+\_\+nelems}

\+: If cache\+\_\+nelems is provided when opening a net\+C\+D\+F-\/4/\+H\+D\+F5 file, it will be used instead of the default (1000) as the maximum number of elements in the H\+D\+F5 chunk cache.

{\ttfamily cache\+\_\+premtion}

\+: If cache\+\_\+preemption is provided when opening a net\+C\+D\+F-\/4/\+H\+D\+F5 file, it will be used instead of the default (0.\+75) as the preemption value for the H\+D\+F5 chunk cache.

{\ttfamily comm}

\+: If the comm and info parameters are provided the file is opened for parallel I/O. Set the comm parameter to the M\+PI communicator (of type M\+P\+I\+\_\+\+Comm). If this parameter is provided the info parameter must also be provided.

{\ttfamily info}

\+: If the comm and info parameters are provided the file is opened for parallel I/O. Set the comm parameter to the M\+PI information value (of type M\+P\+I\+\_\+\+Info). If this parameter is provided the comm parameter must also be provided.

\subsection*{Errors}

N\+F90\+\_\+\+O\+P\+EN returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset does not exist.
\item A meaningless mode was specified.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+O\+P\+EN to open an existing net\+C\+DF dataset named foo.\+nc for read-\/only, non-\/shared access\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
status = nf90\_open(path = \textcolor{stringliteral}{"foo.nc"}, mode = nf90\_nowrite, ncid = ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


\subsection*{Example}

Here is an example using N\+F90\+\_\+\+O\+P\+EN to open an existing net\+C\+DF dataset for parallel I/O access. (Note the use of the comm and info parameters). This example is from test program nf\+\_\+test/f90tst\+\_\+parallel.\+f90.


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
 \textcolor{comment}{! Reopen the file.}
 \textcolor{keyword}{call }handle\_err(nf90\_open(file\_name, nf90\_nowrite, ncid, comm = mpi\_comm\_world, &
      info = mpi\_info\_null))
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_redef}{}\subsection{2.\+7 N\+F90\+\_\+\+R\+E\+D\+E\+F }\label{f90_datasets_f90-nf90_redef}
The function N\+F90\+\_\+\+R\+E\+D\+EF puts an open net\+C\+DF dataset into define mode, so dimensions, variables, and attributes can be added or renamed and attributes can be deleted.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_redef(ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{integer}              :: nf90\_redef
\end{DoxyCode}


{\ttfamily ncid}

\+: net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors}

N\+F90\+\_\+\+R\+E\+D\+EF returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset is already in define mode.
\item The specified net\+C\+DF dataset was opened for read-\/only.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+R\+E\+D\+EF to open an existing net\+C\+DF dataset named foo.\+nc and put it into define mode\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid) \textcolor{comment}{! Open dataset}
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_redef(ncid)                       \textcolor{comment}{! Put the file in define mode}
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_enddef}{}\subsection{2.\+8 N\+F90\+\_\+\+E\+N\+D\+D\+E\+F }\label{f90_datasets_f90-nf90_enddef}
The function N\+F90\+\_\+\+E\+N\+D\+D\+EF takes an open net\+C\+DF dataset out of define mode. The changes made to the net\+C\+DF dataset while it was in define mode are checked and committed to disk if no problems occurred. Non-\/record variables may be initialized to a \char`\"{}fill value\char`\"{} as well (see section \href{#NF90_005fSET_005fFILL}{\tt N\+F90\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL}). The net\+C\+DF dataset is then placed in data mode, so variable data can be read or written.

This call may involve copying data under some circumstances. For a more extensive discussion See \href{netcdf.html#File-Structure-and-Performance}{\tt File Structure and Performance} in Net\+C\+DF Users Guide.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_enddef(ncid, h\_minfree, v\_align, v\_minfree, r\_align)
  \textcolor{keywordtype}{integer},           \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent( in)} :: h\_minfree, v\_align, v\_minfree, r\_align
  \textcolor{keywordtype}{integer}                        :: nf90\_enddef
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

The following arguments allow additional performance tuning. Note\+: these arguments expose internals of the netcdf version 1 file format, and may not be available in future netcdf implementations.

The current netcdf file format has three sections\+: the \char`\"{}header\char`\"{} section, the data section for fixed size variables, and the data section for variables which have an unlimited dimension (record variables). The header begins at the beginning of the file. The index (offset) of the beginning of the other two sections is contained in the header. Typically, there is no space between the sections. This causes copying overhead to accrue if one wishes to change the size of the sections, as may happen when changing the names of things, text attribute values, adding attributes or adding variables. Also, for buffered i/o, there may be advantages to aligning sections in certain ways.

The minfree parameters allow one to control costs of future calls to nf90\+\_\+redef or nf90\+\_\+enddef by requesting that some space be available at the end of the section. The default value for both h\+\_\+minfree and v\+\_\+minfree is 0.

The align parameters allow one to set the alignment of the beginning of the corresponding sections. The beginning of the section is rounded up to an index which is a multiple of the align parameter. The flag value N\+F90\+\_\+\+A\+L\+I\+G\+N\+\_\+\+C\+H\+U\+NK tells the library to use the bufrsize (see above) as the align parameter. The default value for both v\+\_\+align and r\+\_\+align is 4 bytes.

{\ttfamily h\+\_\+minfree}

\+: Size of the pad (in bytes) at the end of the \char`\"{}header\char`\"{} section.

{\ttfamily v\+\_\+minfree}

\+: Size of the pad (in bytes) at the end of the data section for fixed size variables.

{\ttfamily v\+\_\+align}

\+: The alignment of the beginning of the data section for fixed size variables.

{\ttfamily r\+\_\+align}

\+: The alignment of the beginning of the data section for variables which have an unlimited dimension (record variables).

\subsection*{Errors}

N\+F90\+\_\+\+E\+N\+D\+D\+EF returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF dataset is not in define mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The size of one or more variables exceed the size constraints for whichever variant of the file format is in use).
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+E\+N\+D\+D\+EF to finish the definitions of a new net\+C\+DF dataset named foo.\+nc and put it into data mode\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
status = nf90\_create(\textcolor{stringliteral}{"foo.nc"}, nf90\_noclobber, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...  \textcolor{comment}{!  create dimensions, variables, attributes}
status = nf90\_enddef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_close}{}\subsection{2.\+9 N\+F90\+\_\+\+C\+L\+O\+S\+E }\label{f90_datasets_f90-nf90_close}
The function N\+F90\+\_\+\+C\+L\+O\+SE closes an open net\+C\+DF dataset. If the dataset is in define mode, N\+F90\+\_\+\+E\+N\+D\+D\+EF will be called before closing. (In this case, if N\+F90\+\_\+\+E\+N\+D\+D\+EF returns an error, N\+F90\+\_\+\+A\+B\+O\+RT will automatically be called to restore the dataset to the consistent state before define mode was last entered.) After an open net\+C\+DF dataset is closed, its net\+C\+DF ID may be reassigned to the next net\+C\+DF dataset that is opened or created.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_close(ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{integer}              :: nf90\_close
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors}

N\+F90\+\_\+\+C\+L\+O\+SE returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Define mode was entered and the automatic call made to N\+F90\+\_\+\+E\+N\+D\+D\+EF failed.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+C\+L\+O\+SE to finish the definitions of a new net\+C\+DF dataset named foo.\+nc and release its net\+C\+DF ID\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
status = nf90\_create(\textcolor{stringliteral}{"foo.nc"}, nf90\_noclobber, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...  \textcolor{comment}{!  create dimensions, variables, attributes}
status = nf90\_close(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_inquire-family}{}\subsection{2.\+10 N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E Family }\label{f90_datasets_f90-nf90_inquire-family}
The N\+F90\+\_\+\+I\+N\+Q\+U\+I\+RE subroutine returns information about an open net\+C\+DF dataset, given its net\+C\+DF ID. The subroutine can be called from either define mode or data mode, and returns values for any or all of the following\+: the number of dimensions, the number of variables, the number of global attributes, and the dimension ID of the dimension defined with unlimited length, if any. An additional function, N\+F90\+\_\+\+I\+N\+Q\+\_\+\+F\+O\+R\+M\+AT, returns the (rarely needed) format version.

No I/O is performed when N\+F90\+\_\+\+I\+N\+Q\+U\+I\+RE is called, since the required information is available in memory for each open net\+C\+DF dataset.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inquire(ncid, nDimensions, nVariables, nAttributes, &
                      unlimitedDimId, formatNum)
  \textcolor{keywordtype}{integer},           \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: ndimensions, nvariables, &
                                    nattributes, unlimiteddimid, &
                                    formatnum
  \textcolor{keywordtype}{integer}                        :: nf90\_inquire
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily n\+Dimensions}

\+: Returned number of dimensions defined for this net\+C\+DF dataset.

{\ttfamily n\+Variables}

\+: Returned number of variables defined for this net\+C\+DF dataset.

{\ttfamily n\+Attributes}

\+: Returned number of global attributes defined for this net\+C\+DF dataset.

{\ttfamily unlimited\+Dim\+ID}

\+: Returned ID of the unlimited dimension, if there is one for this net\+C\+DF dataset. If no unlimited length dimension has been defined, -\/1 is returned.

{\ttfamily format}

\+: Returned integer indicating format version for this dataset, one of nf90\+\_\+format\+\_\+classic, nf90\+\_\+format\+\_\+64bit, nf90\+\_\+format\+\_\+netcdf4, or nf90\+\_\+format\+\_\+netcdf4\+\_\+classic. These are rarely needed by users or applications, since thhe library recognizes the format of a file it is accessing and handles it accordingly.

\subsection*{Errors}

Function N\+F90\+\_\+\+I\+N\+Q\+U\+I\+RE returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+I\+N\+Q\+U\+I\+RE to find out about a net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, ndims, nvars, nglobalatts, unlimdimid
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...  
status = nf90\_inquire(ncid, ndims, nvars, nglobalatts, unlimdimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire(ncid, ndimensions = ndims, &
                      unlimiteddimid = unlimdimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_sync}{}\subsection{2.\+11 N\+F90\+\_\+\+S\+Y\+N\+C }\label{f90_datasets_f90-nf90_sync}
The function N\+F90\+\_\+\+S\+Y\+NC offers a way to synchronize the disk copy of a net\+C\+DF dataset with in-\/memory buffers. There are two reasons you might want to synchronize after writes\+:


\begin{DoxyItemize}
\item To minimize data loss in case of abnormal termination, or
\item To make data available to other processes for reading immediately after it is written. But note that a process that already had the dataset open for reading would not see the number of records increase when the writing process calls N\+F90\+\_\+\+S\+Y\+NC; to accomplish this, the reading process must call N\+F90\+\_\+\+S\+Y\+NC.
\end{DoxyItemize}

This function is backward-\/compatible with previous versions of the net\+C\+DF library. The intent was to allow sharing of a net\+C\+DF dataset among multiple readers and one writer, by having the writer call N\+F90\+\_\+\+S\+Y\+NC after writing and the readers call N\+F90\+\_\+\+S\+Y\+NC before each read. For a writer, this flushes buffers to disk. For a reader, it makes sure that the next read will be from disk rather than from previously cached buffers, so that the reader will see changes made by the writing process (e.\+g., the number of records written) without having to close and reopen the dataset. If you are only accessing a small amount of data, it can be expensive in computer resources to always synchronize to disk after every write, since you are giving up the benefits of buffering.

An easier way to accomplish sharing (and what is now recommended) is to have the writer and readers open the dataset with the N\+F90\+\_\+\+S\+H\+A\+RE flag, and then it will not be necessary to call N\+F90\+\_\+\+S\+Y\+NC at all. However, the N\+F90\+\_\+\+S\+Y\+NC function still provides finer granularity than the N\+F90\+\_\+\+S\+H\+A\+RE flag, if only a few net\+C\+DF accesses need to be synchronized among processes.

It is important to note that changes to the ancillary data, such as attribute values, are not propagated automatically by use of the N\+F90\+\_\+\+S\+H\+A\+RE flag. Use of the N\+F90\+\_\+\+S\+Y\+NC function is still required for this purpose.

Sharing datasets when the writer enters define mode to change the data schema requires extra care. In previous releases, after the writer left define mode, the readers were left looking at an old copy of the dataset, since the changes were made to a new copy. The only way readers could see the changes was by closing and reopening the dataset. Now the changes are made in place, but readers have no knowledge that their internal tables are now inconsistent with the new dataset schema. If net\+C\+DF datasets are shared across redefinition, some mechanism external to the net\+C\+DF library must be provided that prevents access by readers during redefinition and causes the readers to call N\+F90\+\_\+\+S\+Y\+NC before any subsequent access.

When calling N\+F90\+\_\+\+S\+Y\+NC, the net\+C\+DF dataset must be in data mode. A net\+C\+DF dataset in define mode is synchronized to disk only when N\+F90\+\_\+\+E\+N\+D\+D\+EF is called. A process that is reading a net\+C\+DF dataset that another process is writing may call N\+F90\+\_\+\+S\+Y\+NC to get updated with the changes made to the data by the writing process (e.\+g., the number of records written), without having to close and reopen the dataset.

Data is automatically synchronized to disk when a net\+C\+DF dataset is closed, or whenever you leave define mode.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_sync(ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{integer}              :: nf90\_sync
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors}

N\+F90\+\_\+\+S\+Y\+NC returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The net\+C\+DF dataset is in define mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+S\+Y\+NC to synchronize the disk writes of a net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...  
\textcolor{comment}{! write data or change attributes}
...  
status = nf90\_sync(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_abort}{}\subsection{2.\+12 N\+F90\+\_\+\+A\+B\+O\+R\+T }\label{f90_datasets_f90-nf90_abort}
You no longer need to call this function, since it is called automatically by N\+F90\+\_\+\+C\+L\+O\+SE in case the dataset is in define mode and something goes wrong with committing the changes. The function N\+F90\+\_\+\+A\+B\+O\+RT just closes the net\+C\+DF dataset, if not in define mode. If the dataset is being created and is still in define mode, the dataset is deleted. If define mode was entered by a call to N\+F90\+\_\+\+R\+E\+D\+EF, the net\+C\+DF dataset is restored to its state before definition mode was entered and the dataset is closed.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_abort(ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{integer}              :: nf90\_abort
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

\subsection*{Errors}

N\+F90\+\_\+\+A\+B\+O\+RT returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item When called from define mode while creating a net\+C\+DF dataset, deletion of the dataset failed.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+A\+B\+O\+RT to back out of redefinitions of a dataset named foo.\+nc\+:


\begin{DoxyCode}
 \textcolor{keywordtype}{use }netcdf
 \textcolor{keywordtype}{implicit none}
 \textcolor{keywordtype}{integer} :: ncid, status, latdimid
 ...
 status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
 \textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
 ...  
 status = nf90\_redef(ncid)
 \textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
 ...  
 status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"Lat"}, 18, latdimid)
 \textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keywordflow}{then} \textcolor{comment}{! Dimension definition failed}
   \textcolor{keyword}{call }handle\_err(status)
   status = nf90\_abort(ncid) \textcolor{comment}{! Abort redefinitions}
   \textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{keywordflow}{ end if}
...
\end{DoxyCode}
\hypertarget{f90_datasets_f90-nf90_set_fill}{}\subsection{2.\+13 N\+F90\+\_\+\+S\+E\+T\+\_\+\+F\+I\+L\+L }\label{f90_datasets_f90-nf90_set_fill}
This function is intended for advanced usage, to optimize writes under some circumstances described below. The function N\+F90\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL sets the fill mode for a net\+C\+DF dataset open for writing and returns the current fill mode in a return parameter. The fill mode can be specified as either N\+F90\+\_\+\+F\+I\+LL or N\+F90\+\_\+\+N\+O\+F\+I\+LL. The default behavior corresponding to N\+F90\+\_\+\+F\+I\+LL is that data is pre-\/filled with fill values, that is fill values are written when you create non-\/record variables or when you write a value beyond data that has not yet been written. This makes it possible to detect attempts to read data before it was written. See section \href{#Fill-Values}{\tt Fill Values}, for more information on the use of fill values. See \href{netcdf.html#Attribute-Conventions}{\tt Attribute Conventions} in \{No value for ‘n-\/man’\}, for information about how to define your own fill values.

The behavior corresponding to N\+F90\+\_\+\+N\+O\+F\+I\+LL overrides the default behavior of prefilling data with fill values. This can be used to enhance performance, because it avoids the duplicate writes that occur when the net\+C\+DF library writes fill values that are later overwritten with data.

A value indicating which mode the net\+C\+DF dataset was already in is returned. You can use this value to temporarily change the fill mode of an open net\+C\+DF dataset and then restore it to the previous mode.

After you turn on N\+F90\+\_\+\+N\+O\+F\+I\+LL mode for an open net\+C\+DF dataset, you must be certain to write valid data in all the positions that will later be read. Note that nofill mode is only a transient property of a net\+C\+DF dataset open for writing\+: if you close and reopen the dataset, it will revert to the default behavior. You can also revert to the default behavior by calling N\+F90\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL again to explicitly set the fill mode to N\+F90\+\_\+\+F\+I\+LL.

There are three situations where it is advantageous to set nofill mode\+:


\begin{DoxyEnumerate}
\item Creating and initializing a net\+C\+DF dataset. In this case, you should set nofill mode before calling N\+F90\+\_\+\+E\+N\+D\+D\+EF and then write completely all non-\/record variables and the initial records of all the record variables you want to initialize.
\item Extending an existing record-\/oriented net\+C\+DF dataset. Set nofill mode after opening the dataset for writing, then append the additional records to the dataset completely, leaving no intervening unwritten records.
\item Adding new variables that you are going to initialize to an existing net\+C\+DF dataset. Set nofill mode before calling N\+F90\+\_\+\+E\+N\+D\+D\+EF then write all the new variables completely.
\end{DoxyEnumerate}

If the net\+C\+DF dataset has an unlimited dimension and the last record was written while in nofill mode, then the dataset may be shorter than if nofill mode was not set, but this will be completely transparent if you access the data only through the net\+C\+DF interfaces.

The use of this feature may not be available (or even needed) in future releases. Programmers are cautioned against heavy reliance upon this feature.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_set\_fill(ncid, fillmode, old\_mode)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: ncid, fillmode
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: old\_mode
  \textcolor{keywordtype}{integer}              :: nf90\_set\_fill
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily fillmode}

\+: Desired fill mode for the dataset, either N\+F90\+\_\+\+N\+O\+F\+I\+LL or N\+F90\+\_\+\+F\+I\+LL.

{\ttfamily old\+\_\+mode}

\+: Returned current fill mode of the dataset before this call, either N\+F90\+\_\+\+N\+O\+F\+I\+LL or N\+F90\+\_\+\+F\+I\+LL.

\subsection*{Errors}

N\+F90\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The specified net\+C\+DF ID refers to a dataset open for read-\/only access.
\item The fill mode argument is neither N\+F90\+\_\+\+N\+O\+F\+I\+LL nor N\+F90\+\_\+\+F\+I\+LL..
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+S\+E\+T\+\_\+\+F\+I\+LL to set nofill mode for subsequent writes of a net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, oldmode
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...  
\textcolor{comment}{! Write data with prefilling behavior}
...  
status = nf90\_set\_fill(ncid, nf90\_nofill, oldmode)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{!  Write data with no prefilling}
...
\end{DoxyCode}
 \hypertarget{f90_groups}{}\section{3 Groups}\label{f90_groups}
Net\+C\+D\+F-\/4 added support for hierarchical groups within net\+C\+DF datasets.

Groups are identified with a ncid, which identifies both the open file, and the group within that file. When a file is opened with N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE, the ncid for the root group of that file is provided. Using that as a starting point, users can add new groups, or list and navigate existing groups.

All net\+C\+DF calls take a ncid which determines where the call will take its action. For example, the N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR function takes a ncid as its first parameter. It will create a variable in whichever group its ncid refers to. Use the root ncid provided by N\+F90\+\_\+\+C\+R\+E\+A\+TE or N\+F90\+\_\+\+O\+P\+EN to create a variable in the root group. Or use N\+F90\+\_\+\+D\+E\+F\+\_\+\+G\+RP to create a group and use its ncid to define a variable in the new group.

Variable are only visible in the group in which they are defined. The same applies to attributes. “\+Global” attributes are defined in whichever group is refered to by the ncid.

Dimensions are visible in their groups, and all child groups.

Group operations are only permitted on net\+C\+D\+F-\/4 files -\/ that is, files created with the H\+D\+F5 flag in nf90\+\_\+create. (see section \href{#NF90_005fCREATE}{\tt N\+F90\+\_\+\+C\+R\+E\+A\+TE}). Groups are not compatible with the net\+C\+DF classic data model, so files created with the N\+F90\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL file cannot contain groups (except the root group).\hypertarget{f90_groups_f90-find-a-group-id-nf90_inq_ncid}{}\subsection{3.\+1 Find a Group I\+D\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+N\+C\+I\+D }\label{f90_groups_f90-find-a-group-id-nf90_inq_ncid}
Given an ncid and group name (N\+U\+LL or \char`\"{}\char`\"{} gets root group), return ncid of the named group.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_ncid(ncid, name, grp\_ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: grp\_ncid
  \textcolor{keywordtype}{integer} :: nf90\_inq\_ncid
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily N\+A\+ME}

\+: A character array that holds the name of the desired group. Must be less then N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily G\+R\+P\+ID}

\+: The ID of the group will go here.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}

This example is from nf90\+\_\+test/ftst\+\_\+groups.\+F.\hypertarget{f90_groups_f90-get-a-list-of-groups-in-a-group-nf90_inq_grps}{}\subsection{3.\+2 Get a List of Groups in a Group\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+S }\label{f90_groups_f90-get-a-list-of-groups-in-a-group-nf90_inq_grps}
Given a location id, return the number of groups it contains, and an array of their ncids.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grps(ncid, numgrps, ncids)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: numgrps
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ncids
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grps
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily N\+U\+M\+G\+R\+PS}

\+: An integer which will get number of groups in this group.

{\ttfamily N\+C\+I\+DS}

\+: An array of ints which will receive the I\+Ds of all the groups in this group.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90_groups_f90-find-all-the-variables-in-a-group-nf90_inq_varids}{}\subsection{3.\+3 Find all the Variables in a Group\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+I\+D\+S }\label{f90_groups_f90-find-all-the-variables-in-a-group-nf90_inq_varids}
Find all varids for a location.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_varids(ncid, nvars, varids)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: nvars
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: varids
  \textcolor{keywordtype}{integer} :: nf90\_inq\_varids
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily V\+A\+R\+I\+DS}

\+: An already allocated array to store the list of varids. Use nf90\+\_\+inq\+\_\+nvars to find out how many variables there are. (see section \href{#NF90_005fINQUIRE_005fVARIABLE}{\tt Get Information about a Variable from Its I\+D\+: N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+V\+A\+R\+I\+A\+B\+LE}).

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90_groups_f90-find-all-dimensions-visible-in-a-group-nf90_inq_dimids}{}\subsection{3.\+4 Find all Dimensions Visible in a Group\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+I\+D\+S }\label{f90_groups_f90-find-all-dimensions-visible-in-a-group-nf90_inq_dimids}
Find all dimids for a location. This finds all dimensions in a group, or any of its parents.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_dimids(ncid, ndims, dimids, include\_parents)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ndims
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: dimids
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: include\_parents
  \textcolor{keywordtype}{integer} :: nf90\_inq\_dimids
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily N\+D\+I\+MS}

\+: Returned number of dimensions for this location. If include\+\_\+parents is non-\/zero, number of dimensions visible from this group, which includes dimensions in parent groups.

{\ttfamily D\+I\+M\+I\+DS}

\+: An array of ints when the dimids of the visible dimensions will be stashed. Use nf90\+\_\+inq\+\_\+ndims to find out how many dims are visible from this group. (see section \href{#f90-get-information-about-a-variable-from-its-id-nf90_inquire_variable}{\tt Get Information about a Variable from Its I\+D\+: N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+V\+A\+R\+I\+A\+B\+LE} ).

{\ttfamily I\+N\+C\+L\+U\+D\+E\+\_\+\+P\+A\+R\+E\+N\+TS}

\+: If zero, only the group specified by N\+C\+ID will be searched for dimensions. Otherwise parent groups will be searched too.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90_groups_f90-find-the-length-of-a-groups-full-name-nf90_inq_grpname_len}{}\subsection{3.\+5 Find the Length of a Group’s Full Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+L\+E\+N }\label{f90_groups_f90-find-the-length-of-a-groups-full-name-nf90_inq_grpname_len}
Given ncid, find length of the full name. (Root group is named \char`\"{}/\char`\"{}, with length 1.)

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grpname\_len(ncid, len)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: len
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grpname\_len
\textcolor{keyword}{end function }nf90\_inq\_grpname\_len
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily L\+EN}

\+: An integer where the length will be placed.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90_groups_f90-find-a-groups-name-nf90_inq_grpname}{}\subsection{3.\+6 Find a Group’s Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E }\label{f90_groups_f90-find-a-groups-name-nf90_inq_grpname}
Given ncid, find relative name of group. (Root group is named \char`\"{}/\char`\"{}).

The name provided by this function is relative to the parent group. For a full path name for the group is, with all parent groups included, separated with a forward slash (as in Unix directory names) See section \href{#f90-find-a-groups-full-name-nf90_inq_grpname_full}{\tt Find a Group’s Full Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+F\+U\+LL}.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grpname(ncid, name)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grpname
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily N\+A\+ME}

\+: The name of the group will be copied to this character array. The name will be less than N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME in length.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90_groups_f90-find-a-groups-full-name-nf90_inq_grpname_full}{}\subsection{3.\+7 Find a Group’s Full Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+M\+E\+\_\+\+F\+U\+L\+L }\label{f90_groups_f90-find-a-groups-full-name-nf90_inq_grpname_full}
Given ncid, find complete name of group. (Root group is named \char`\"{}/\char`\"{}).

The name provided by this function is a full path name for the group is, with all parent groups included, separated with a forward slash (as in Unix directory names). For a name relative to the parent group See section \href{#f90-find-a-groups-name-nf90_inq_grpname}{\tt Find a Group’s Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+N\+A\+ME}.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grpname\_full(ncid, len, name)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: len
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grpname\_full
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id for this operation.

{\ttfamily L\+EN}

\+: The length of the full group name will go here.

{\ttfamily N\+A\+ME}

\+: The name of the group will be copied to this character array.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}

This example is from test program nf\+\_\+test/f90tst\+\_\+grps.\+f90.


\begin{DoxyCode}
\textcolor{comment}{call check(nf90\_inq\_grpname\_full(grpid1, len, name\_in))}
\textcolor{keywordflow}{if} (name\_in .ne. grp1\_full\_name) stop 62
\end{DoxyCode}
\hypertarget{f90_groups_f90-find-a-groups-parent-nf90_inq_grp_parent}{}\subsection{3.\+8 Find a Group’s Parent\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+P\+A\+R\+E\+N\+T }\label{f90_groups_f90-find-a-groups-parent-nf90_inq_grp_parent}
Given ncid, find the ncid of the parent group.

When used with the root group, this function returns the N\+F90\+\_\+\+E\+N\+O\+G\+RP error (since the root group h has no parent.)

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grp\_parent(ncid, parent\_ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: parent\_ncid
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grp\_parent
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id.

{\ttfamily P\+A\+R\+E\+N\+T\+\_\+\+N\+C\+ID}

\+: The ncid of the parent group will be copied here.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+G\+RP}

\+: No parent group found (i.\+e. this is the root group).

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90_groups_f90-find-a-group-by-name-nf90_inq_grp_ncid}{}\subsection{3.\+9 Find a Group by Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+N\+C\+I\+D }\label{f90_groups_f90-find-a-group-by-name-nf90_inq_grp_ncid}
Given a group name an an ncid, find the ncid of the group id.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grp\_ncid(ncid, name, grpid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: grpid
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grp\_ncid

  nf90\_inq\_grp\_ncid = nf\_inq\_grp\_ncid(ncid, name, grpid)
\textcolor{keyword}{end function }nf90\_inq\_grp\_ncid
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id to look in.

{\ttfamily G\+R\+P\+\_\+\+N\+A\+ME}

\+: The name of the group that should be found.

{\ttfamily G\+R\+P\+\_\+\+N\+C\+ID}

\+: This will get the group id, if it is found.

\subsection*{Return Codes}

The following return codes may be returned by this function.

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+I\+N\+V\+AL}

\+: No name provided or name longer than N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+G\+RP}

\+: Named group not found.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}

This example is from test program nf\+\_\+test/f90tst\+\_\+grps.\+f90.


\begin{DoxyCode}
\textcolor{comment}{! Get the group ids for the newly reopened file.}
\textcolor{comment}{call check(nf90\_inq\_grp\_ncid(ncid, GRP1\_NAME, grpid1))}
\textcolor{comment}{call check(nf90\_inq\_grp\_ncid(grpid1, GRP2\_NAME, grpid2))}
\textcolor{comment}{call check(nf90\_inq\_grp\_ncid(grpid2, GRP3\_NAME, grpid3))}
\textcolor{comment}{call check(nf90\_inq\_grp\_ncid(grpid3, GRP4\_NAME, grpid4))}
\end{DoxyCode}
\hypertarget{f90_groups_f90-find-a-group-by-its-fully-qualified-name-nf90_inq_grp_full_ncid}{}\subsection{3.\+10 Find a Group by its Fully-\/qualified Name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+G\+R\+P\+\_\+\+F\+U\+L\+L\+\_\+\+N\+C\+I\+D }\label{f90_groups_f90-find-a-group-by-its-fully-qualified-name-nf90_inq_grp_full_ncid}
Given a fully qualified group name an an ncid, find the ncid of the group id.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_grpname\_full(ncid, len, name)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: len
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer} :: nf90\_inq\_grpname\_full

  nf90\_inq\_grpname\_full = nf\_inq\_grpname\_full(ncid, len, name)
\textcolor{keyword}{end function }nf90\_inq\_grpname\_full
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id to look in.

{\ttfamily F\+U\+L\+L\+\_\+\+N\+A\+ME}

\+: The fully-\/qualified group name.

{\ttfamily G\+R\+P\+\_\+\+N\+C\+ID}

\+: This will get the group id, if it is found.

\subsection*{Return Codes}

The following return codes may be returned by this function.

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+I\+N\+V\+AL}

\+: No name provided or name longer than N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+G\+RP}

\+: Named group not found.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}

This example is from test program nf\+\_\+test/tstf90\+\_\+grps.\+f90.


\begin{DoxyCode}
\textcolor{comment}{! Check for the groups with full group names.}
\textcolor{keyword}{write}(grp1\_full\_name, \textcolor{stringliteral}{'(AA)'}) \textcolor{stringliteral}{'/'}, grp1\_name
\textcolor{keyword}{call }check(nf90\_inq\_grp\_full\_ncid(ncid, grp1\_full\_name, grpid1))
\end{DoxyCode}
\hypertarget{f90_groups_f90-create-a-new-group-nf90_def_grp}{}\subsection{3.\+11 Create a New Group\+: N\+F90\+\_\+\+D\+E\+F\+\_\+\+G\+R\+P }\label{f90_groups_f90-create-a-new-group-nf90_def_grp}
Create a group. Its location id is returned in new\+\_\+ncid.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_grp(parent\_ncid, name, new\_ncid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: parent\_ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: new\_ncid
  \textcolor{keywordtype}{integer} :: nf90\_def\_grp
\end{DoxyCode}


{\ttfamily P\+A\+R\+E\+N\+T\+\_\+\+N\+C\+ID}

\+: The group id of the parent group.

{\ttfamily N\+A\+ME}

\+: The name of the new group, which must be different from the name of any variable within the same parent group.

{\ttfamily N\+E\+W\+\_\+\+N\+C\+ID}

\+: The ncid of the new group will be placed there.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: That name is in use. Group names must be unique within a group.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: Name exceed max length N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag H\+D\+F5. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+P\+E\+RM}

\+: Attempt to write to a read-\/only file.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode.

\subsection*{Example}


\begin{DoxyCode}
\textcolor{comment}{C     Create the netCDF file.}
      retval = nf90\_create(file\_name, nf90\_netcdf4, ncid)
      \textcolor{keywordflow}{if} (retval .ne. nf90\_noerr) \textcolor{keyword}{call }handle\_err(retval)

\textcolor{comment}{C     Create a group and a subgroup.}
      retval = nf90\_def\_grp(ncid, group\_name, grpid)
      \textcolor{keywordflow}{if} (retval .ne. nf90\_noerr) \textcolor{keyword}{call }handle\_err(retval)
      retval = nf90\_def\_grp(grpid, sub\_group\_name, sub\_grpid)
      \textcolor{keywordflow}{if} (retval .ne. nf90\_noerr) \textcolor{keyword}{call }handle\_err(retval)
\end{DoxyCode}
 \hypertarget{f90_dimensions}{}\section{4 Dimensions}\label{f90_dimensions}
\hypertarget{f90_dimensions_f90-dimensions-introduction}{}\subsection{4.\+1 Dimensions Introduction }\label{f90_dimensions_f90-dimensions-introduction}
Dimensions for a net\+C\+DF dataset are defined when it is created, while the net\+C\+DF dataset is in define mode. Additional dimensions may be added later by reentering define mode. A net\+C\+DF dimension has a name and a length. At most one dimension in a net\+C\+DF dataset can have the unlimited length, which means variables using this dimension can grow along this dimension.

There is a suggested limit (512) to the number of dimensions that can be defined in a single net\+C\+DF dataset. The limit is the value of the constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+D\+I\+MS. The purpose of the limit is to make writing generic applications simpler. They need only provide an array of N\+F90\+\_\+\+M\+A\+X\+\_\+\+D\+I\+MS dimensions to handle any net\+C\+DF dataset. The implementation of the net\+C\+DF library does not enforce this advisory maximum, so it is possible to use more dimensions, if necessary, but net\+C\+DF utilities that assume the advisory maximums may not be able to handle the resulting net\+C\+DF datasets.

Ordinarily, the name and length of a dimension are fixed when the dimension is first defined. The name may be changed later, but the length of a dimension (other than the unlimited dimension) cannot be changed without copying all the data to a new net\+C\+DF dataset with a redefined dimension length.

A net\+C\+DF dimension in an open net\+C\+DF dataset is referred to by a small integer called a dimension ID. In the Fortran 90 interface, dimension I\+Ds are 1, 2, 3, ..., in the order in which the dimensions were defined.

Operations supported on dimensions are\+:


\begin{DoxyItemize}
\item Create a dimension, given its name and length.
\item Get a dimension ID from its name.
\item Get a dimension’s name and length from its ID.
\item Rename a dimension.
\end{DoxyItemize}\hypertarget{f90_dimensions_f90-nf90_def_dim}{}\subsection{4.\+2 N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+I\+M }\label{f90_dimensions_f90-nf90_def_dim}
The function N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM adds a new dimension to an open net\+C\+DF dataset in define mode. It returns (as an argument) a dimension ID, given the net\+C\+DF ID, the dimension name, and the dimension length. At most one unlimited length dimension, called the record dimension, may be defined for each net\+C\+DF dataset.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_dim(ncid, name, len, dimid)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: len
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent(out)} :: dimid
  \textcolor{keywordtype}{integer}                          :: nf90\_def\_dim
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily name}

\+: Dimension name.

{\ttfamily len}

\+: Length of dimension; that is, number of values for this dimension as an index to variables that use it. This should be either a positive integer or the predefined constant N\+F90\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED.

{\ttfamily dimid}

\+: Returned dimension ID.

\subsection*{Errors}

N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The net\+C\+DF dataset is not in definition mode.
\item The specified dimension name is the name of another existing dimension.
\item The specified length is not greater than zero.
\item The specified length is unlimited, but there is already an unlimited length dimension defined for this net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM to create a dimension named lat of length 18 and a unlimited dimension named rec in a new net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, latdimid, recorddimid
...
status = nf90\_create(\textcolor{stringliteral}{"foo.nc"}, nf90\_noclobber, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"Lat"}, 18, latdimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"Record"}, nf90\_unlimited, recorddimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_dimensions_f90-nf90_inq_dimid}{}\subsection{4.\+3 N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+I\+D }\label{f90_dimensions_f90-nf90_inq_dimid}
The function N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID returns (as an argument) the ID of a net\+C\+DF dimension, given the name of the dimension. If ndims is the number of dimensions defined for a net\+C\+DF dataset, each dimension has an ID between 1 and ndims.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_dimid(ncid, name, dimid)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent(out)} :: dimid
  \textcolor{keywordtype}{integer}                          :: nf90\_inq\_dimid
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily name}

\+: Dimension name.

{\ttfamily dimid}

\+: Returned dimension ID.

\subsection*{Errors}

N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The name that was specified is not the name of a dimension in the net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID to determine the dimension ID of a dimension named lat, assumed to have been defined previously in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, latdimid
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_dimid(ncid, \textcolor{stringliteral}{"Lat"}, latdimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_dimensions_f90-nf90_inquire_dimension}{}\subsection{4.\+4 N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+D\+I\+M\+E\+N\+S\+I\+O\+N }\label{f90_dimensions_f90-nf90_inquire_dimension}
This function information about a net\+C\+DF dimension. Information about a dimension includes its name and its length. The length for the unlimited dimension, if any, is the number of records written so far.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inquire\_dimension(ncid, dimid, name, len)
  \textcolor{keywordtype}{integer},                       \textcolor{keywordtype}{intent( in)} :: ncid, dimid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: len
  \textcolor{keywordtype}{integer}                                    :: nf90\_inquire\_dimension
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily dimid}

\+: Dimension ID, from a previous call to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID or N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM.

{\ttfamily name}

\+: Returned dimension name. The caller must allocate space for the returned name. The maximum possible length, in characters, of a dimension name is given by the predefined constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily len}

\+: Returned length of dimension. For the unlimited dimension, this is the current maximum value used for writing any variables with this dimension, that is the maximum record number.

\subsection*{Errors}

These functions return the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The dimension ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+IM to determine the length of a dimension named lat, and the name and current maximum length of the unlimited dimension for an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, latdimid, recorddimid
\textcolor{keywordtype}{integer} :: nlats, nrecords
\textcolor{keywordtype}{character(len = nf90\_max\_name)} :: recorddimname
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Get ID of unlimited dimension}
status = nf90\_inquire(ncid, unlimiteddimid = recorddimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_dimid(ncid, \textcolor{stringliteral}{"Lat"}, latdimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! How many values of "lat" are there?}
status = nf90\_inquire\_dimension(ncid, latdimid, len = nlats)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! What is the name of the unlimited dimension, how many records are there?}
status = nf90\_inquire\_dimension(ncid, recorddimid, &
                                name = recorddimname, len = records)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90_dimensions_f90-nf90_rename_dim}{}\subsection{4.\+5 N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+I\+M }\label{f90_dimensions_f90-nf90_rename_dim}
The function N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM renames an existing dimension in a net\+C\+DF dataset open for writing. If the new name is longer than the old name, the net\+C\+DF dataset must be in define mode. You cannot rename a dimension to have the same name as another dimension.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_rename\_dim(ncid, dimid, name)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: dimid
  \textcolor{keywordtype}{integer}                          :: nf90\_rename\_dim
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily dimid}

\+: Dimension ID, from a previous call to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+D\+I\+M\+ID or N\+F90\+\_\+\+D\+E\+F\+\_\+\+D\+IM.

{\ttfamily name}

\+: New dimension name.

\subsection*{Errors}

N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The new name is the name of another dimension.
\item The dimension ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The new name is longer than the old name and the net\+C\+DF dataset is not in define mode.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+D\+IM to rename the dimension lat to latitude in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, latdimid
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Put in define mode so we can rename the dimension}
status = nf90\_redef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Get the dimension ID for "Lat"...}
status = nf90\_inq\_dimid(ncid, \textcolor{stringliteral}{"Lat"}, latdimid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! ... and change the name to "Latitude".}
status = nf90\_rename\_dim(ncid, latdimid, \textcolor{stringliteral}{"Latitude"})
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Leave define mode}
status = nf90\_enddef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
 \hypertarget{f90-user-defined-data-types}{}\section{5 User Defined Data Types}\label{f90-user-defined-data-types}
\hypertarget{f90-user-defined-data-types_f90-user-defined-types-introduction}{}\subsection{5.\+1 User Defined Types Introduction }\label{f90-user-defined-data-types_f90-user-defined-types-introduction}
Net\+C\+D\+F-\/4 has added support for four different user defined data types.

{\ttfamily compound type}

\+: Like a C struct, a compound type is a collection of types, including other user defined types, in one package.

{\ttfamily variable length array type}

\+: The variable length array may be used to store ragged arrays.

{\ttfamily opaque type}

\+: This type has only a size per element, and no other type information.

{\ttfamily enum type}

\+: Like an enumeration in C, this type lets you assign text values to integer values, and store the integer values.

Users may construct user defined type with the various N\+F90\+\_\+\+D\+E\+F\+\_\+$\ast$ functions described in this section. They may learn about user defined types by using the N\+F90\+\_\+\+I\+N\+Q\+\_\+ functions defined in this section.

Once types are constructed, define variables of the new type with N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR (see section \href{#NF90_005fDEF_005fVAR}{\tt Create a Variable\+: {\ttfamily N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR}}). Write to them with N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR (see section \href{#NF90_005fPUT_005fVAR}{\tt Writing Data Values\+: {\ttfamily N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR}}). Read data of user-\/defined type with N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR (see section \href{#NF90_005fGET_005fVAR}{\tt Reading Data Values\+: {\ttfamily N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR}}).

Create attributes of the new type with N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT (see section \href{#NF90_005fPUT_005fATT}{\tt Create an Attribute\+: N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT}). Read attributes of the new type with N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+TT (see section \href{#NF90_005fGET_005fATT}{\tt Get Attribute’s Values\+: N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+TT}).\hypertarget{f90-user-defined-data-types_f90-learn-the-ids-of-all-types-in-group-nf90_inq_typeids}{}\subsection{5.\+2 Learn the I\+Ds of All Types in Group\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E\+I\+D\+S }\label{f90-user-defined-data-types_f90-learn-the-ids-of-all-types-in-group-nf90_inq_typeids}
Learn the number of types defined in a group, and their I\+Ds.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_typeids(ncid, ntypes, typeids)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ntypes
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: typeids
  \textcolor{keywordtype}{integer} :: nf90\_inq\_typeids
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group id.

{\ttfamily N\+T\+Y\+P\+ES}

\+: A pointer to int which will get the number of types defined in the group. If N\+U\+LL, ignored.

{\ttfamily T\+Y\+P\+E\+I\+DS}

\+: A pointer to an int array which will get the typeids. If N\+U\+LL, ignored.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+B\+A\+D\+ID}

\+: Bad ncid.

\subsection*{Example}\hypertarget{f90-user-defined-data-types_f90-find-a-typeid-from-group-and-name-nf90_inq_typeid}{}\subsection{5.\+3 Find a Typeid from Group and Name\+: nf90\+\_\+inq\+\_\+typeid }\label{f90-user-defined-data-types_f90-find-a-typeid-from-group-and-name-nf90_inq_typeid}
Given a group ID and a type name, find the ID of the type. If the type is not found in the group, then the parents are searched. If still not found, the entire file is searched.

\subsection*{Usage}


\begin{DoxyCode}
int nf90\_inq\_typeid(int ncid, char *name, nf90\_type *typeidp);
\end{DoxyCode}


{\ttfamily ncid}

\+: The group id.

{\ttfamily name}

\+: The name of a type.

{\ttfamily typeidp}

\+: The typeid, if found.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad ncid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE}

\+: Can’t find type.

\subsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-about-a-user-defined-type-nf90_inq_type}{}\subsection{5.\+4 Learn About a User Defined Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+T\+Y\+P\+E }\label{f90-user-defined-data-types_f90-learn-about-a-user-defined-type-nf90_inq_type}
Given an ncid and a typeid, get the information about a type. This function will work on any type, including atomic and any user defined type, whether compound, opaque, enumeration, or variable length array.

For even more information about a user defined type \href{#NF90_005fINQ_005fUSER_005fTYPE}{\tt Learn About a User Defined Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+U\+S\+E\+R\+\_\+\+T\+Y\+PE}.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_type(ncid, xtype, name, size)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: size
  \textcolor{keywordtype}{integer} :: nf90\_inq\_type
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid for the group containing the type (ignored for atomic types).

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, N\+F90\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE, N\+F90\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM, N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR, or as found in netcdf.\+inc in the list of atomic types (N\+F90\+\_\+\+C\+H\+AR, N\+F90\+\_\+\+I\+NT, etc.).

{\ttfamily N\+A\+ME}

\+: The name of the user defined type will be copied here. It will be N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME bytes or less. For atomic types, the type name from C\+DL will be given.

{\ttfamily S\+I\+Z\+EP}

\+: The (in-\/memory) size of the type (in bytes) will be copied here. V\+L\+EN type size is the size of one element of the V\+L\+EN. String size is returned as the size of one char.

\subsection*{Return Codes}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad typeid.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Seeking a user-\/defined type in a net\+C\+D\+F-\/3 file.

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: Seeking a user-\/defined type in a net\+C\+D\+F-\/4 file for which classic model has been turned on.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID}

\+: Bad group ID in ncid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Type ID not found.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-about-a-user-defined-type-nf90_inq_user_type}{}\subsection{5.\+5 Learn About a User Defined Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+U\+S\+E\+R\+\_\+\+T\+Y\+P\+E }\label{f90-user-defined-data-types_f90-learn-about-a-user-defined-type-nf90_inq_user_type}
Given an ncid and a typeid, get the information about a user defined type. This function will work on any user defined type, whether compound, opaque, enumeration, or variable length array.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_user\_type(ncid, xtype, name, size, base\_typeid, nfields, class)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: size
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: base\_typeid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: nfields
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: class
  \textcolor{keywordtype}{integer} :: nf90\_inq\_user\_type
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid for the group containing the user defined type.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, N\+F90\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE, N\+F90\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM, N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME}

\+: The name of the user defined type will be copied here. It will be N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME bytes or less.

{\ttfamily S\+I\+ZE}

\+: The (in-\/memory) size of the user defined type will be copied here.

{\ttfamily B\+A\+S\+E\+\_\+\+N\+F90\+\_\+\+T\+Y\+PE}

\+: The base typeid will be copied here for vlen and enum types.

{\ttfamily N\+F\+I\+E\+L\+DS}

\+: The number of fields will be copied here for enum and compound types.

{\ttfamily C\+L\+A\+SS}

\+: The class of the user defined type, N\+F90\+\_\+\+V\+L\+EN, N\+F90\+\_\+\+O\+P\+A\+Q\+UE, N\+F90\+\_\+\+E\+N\+UM, or N\+F90\+\_\+\+C\+O\+M\+P\+O\+U\+ND, will be copied here.

\subsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad typeid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+F\+I\+E\+L\+D\+ID}

\+: Bad fieldid.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsection*{Example}\hypertarget{f90-user-defined-data-types_f90-set-a-variable-length-array-with-nf90_put_vlen_element}{}\subsubsection{5.\+5.\+1 Set a Variable Length Array with N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT}\label{f90-user-defined-data-types_f90-set-a-variable-length-array-with-nf90_put_vlen_element}
Use this to set the element of the (potentially) n-\/dimensional array of V\+L\+EN. That is, this sets the data in one variable length array.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{INTEGER }\textcolor{keyword}{FUNCTION }nf90\_put\_vlen\_element(INTEGER NCID, INTEGER XTYPE,
        CHARACTER*(*) vlen\_element, integer len, data)
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid of the file that contains the V\+L\+EN type.

{\ttfamily X\+T\+Y\+PE}

\+: The type of the V\+L\+EN.

{\ttfamily V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT}

\+: The V\+L\+EN element to be set.

{\ttfamily L\+EN}

\+: The number of entries in this array.

{\ttfamily D\+A\+TA}

\+: The data to be stored. Must match the base type of this V\+L\+EN.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE}

\+: Can’t find the typeid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: ncid invalid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID}

\+: Group ID part of ncid was invalid.

\subsubsection*{Example}

This example is from nf90\+\_\+test/ftst\+\_\+vars4.\+F.


\begin{DoxyCode}
\textcolor{comment}{C     Set up the vlen with this helper function, since F90 can't deal}
\textcolor{comment}{C     with pointers.}
      retval = nf90\_put\_vlen\_element(ncid, vlen\_typeid, vlen,
     &     vlen\_len, data1)
      \textcolor{keywordflow}{if} (retval .ne. nf90\_noerr) \textcolor{keyword}{call }handle\_err(retval)
\end{DoxyCode}
\hypertarget{f90-user-defined-data-types_f90-set-a-variable-length-array-with-nf90_get_vlen_element}{}\subsubsection{5.\+5.\+2 Set a Variable Length Array with N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT}\label{f90-user-defined-data-types_f90-set-a-variable-length-array-with-nf90_get_vlen_element}
Use this to set the element of the (potentially) n-\/dimensional array of V\+L\+EN. That is, this sets the data in one variable length array.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{INTEGER }\textcolor{keyword}{FUNCTION }nf90\_get\_vlen\_element(INTEGER NCID, INTEGER XTYPE,
        CHARACTER*(*) vlen\_element, integer len, data)
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid of the file that contains the V\+L\+EN type.

{\ttfamily X\+T\+Y\+PE}

\+: The type of the V\+L\+EN.

{\ttfamily V\+L\+E\+N\+\_\+\+E\+L\+E\+M\+E\+NT}

\+: The V\+L\+EN element to be set.

{\ttfamily L\+EN}

\+: This will be set to the number of entries in this array.

{\ttfamily D\+A\+TA}

\+: The data will be copied here. Sufficient storage must be available or bad things will happen to you.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE}

\+: Can’t find the typeid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: ncid invalid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID}

\+: Group ID part of ncid was invalid.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-compound-types-introduction}{}\subsection{5.\+6 Compound Types Introduction }\label{f90-user-defined-data-types_f90-compound-types-introduction}
Net\+C\+D\+F-\/4 added support for compound types, which allow users to construct a new type -\/ a combination of other types, like a C struct.

Compound types are not supported in classic or 64-\/bit offset format files.

To write data in a compound type, first use nf90\+\_\+def\+\_\+compound to create the type, multiple calls to nf90\+\_\+insert\+\_\+compound to add to the compound type, and then write data with the appropriate nf90\+\_\+put\+\_\+var1, nf90\+\_\+put\+\_\+vara, nf90\+\_\+put\+\_\+vars, or nf90\+\_\+put\+\_\+varm call.

To read data written in a compound type, you must know its structure. Use the N\+F90\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND functions to learn about the compound type.

In Fortran a character buffer must be used for the compound data. The user must read the data from within that buffer in the same way that the C compiler which compiled net\+C\+DF would store the structure.

The use of compound types introduces challenges and portability issues for Fortran users.\hypertarget{f90-user-defined-data-types_f90-creating-a-compound-type-nf90_def_compound}{}\subsubsection{5.\+6.\+1 Creating a Compound Type\+: N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{f90-user-defined-data-types_f90-creating-a-compound-type-nf90_def_compound}
Create a compound type. Provide an ncid, a name, and a total size (in bytes) of one element of the completed compound type.

After calling this function, fill out the type with repeated calls to N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND (see section \href{#NF90_005fINSERT_005fCOMPOUND}{\tt Inserting a Field into a Compound Type\+: N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND}). Call N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND once for each field you wish to insert into the compound type.

Note that there does not seem to be a fully portable way to read such types into structures in Fortran 90 (and there are no structures in Fortran 77). Dozens of top-\/notch programmers are swarming over this problem in a sub-\/basement of Unidata’s giant underground bunker in Wyoming.

Fortran users may use character buffers to read and write compound types. User are invited to try classic Fortran features such as the equivilence and the common block statment.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_compound(ncid, size, name, typeid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: size
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: typeid
  \textcolor{keywordtype}{integer} :: nf90\_def\_compound
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The groupid where this compound type will be created.

{\ttfamily S\+I\+ZE}

\+: The size, in bytes, of the compound type.

{\ttfamily N\+A\+ME}

\+: The name of the new compound type.

{\ttfamily T\+Y\+P\+E\+I\+DP}

\+: The typeid of the new type will be placed here.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: That name is in use. Compound type names must be unique in the data file.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: Name exceeds max length N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+P\+E\+RM}

\+: Attempt to write to a read-\/only file.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-inserting-a-field-into-a-compound-type-nf90_insert_compound}{}\subsubsection{5.\+6.\+2 Inserting a Field into a Compound Type\+: N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{f90-user-defined-data-types_f90-inserting-a-field-into-a-compound-type-nf90_insert_compound}
Insert a named field into a compound type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_insert\_compound(ncid, xtype, name, offset, field\_typeid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: offset
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: field\_typeid
  \textcolor{keywordtype}{integer} :: nf90\_insert\_compound
\end{DoxyCode}


{\ttfamily T\+Y\+P\+E\+ID}

\+: The typeid for this compound type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME}

\+: The name of the new field.

{\ttfamily O\+F\+F\+S\+ET}

\+: Offset in byte from the beginning of the compound type for this field.

{\ttfamily F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID}

\+: The type of the field to be inserted.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: That name is in use. Field names must be unique within a compound type.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: Name exceed max length N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-inserting-an-array-field-into-a-compound-type-nf90_insert_array_compound}{}\subsubsection{5.\+6.\+3 Inserting an Array Field into a Compound Type\+: N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{f90-user-defined-data-types_f90-inserting-an-array-field-into-a-compound-type-nf90_insert_array_compound}
Insert a named array field into a compound type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_insert\_array\_compound(ncid, xtype, name, offset, field\_typeid, &
     ndims, dim\_sizes)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: offset
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: field\_typeid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ndims
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: dim\_sizes
  \textcolor{keywordtype}{integer} :: nf90\_insert\_array\_compound
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ID of the file that contains the array type and the compound type.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this compound type, as returned by nf90\+\_\+def\+\_\+compound, or nf90\+\_\+inq\+\_\+var.

{\ttfamily N\+A\+ME}

\+: The name of the new field.

{\ttfamily O\+F\+F\+S\+ET}

\+: Offset in byte from the beginning of the compound type for this field.

{\ttfamily F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID}

\+: The base type of the array to be inserted.

{\ttfamily N\+D\+I\+MS}

\+: The number of dimensions for the array to be inserted.

{\ttfamily D\+I\+M\+\_\+\+S\+I\+Z\+ES}

\+: An array containing the sizes of each dimension.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: That name is in use. Field names must be unique within a compound type.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: Name exceed max length N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode.

{\ttfamily N\+F90\+\_\+\+E\+T\+Y\+P\+E\+D\+E\+F\+I\+N\+ED}

\+: Attempt to change type that has already been committed. The first time the file leaves define mode, all defined types are committed, and can’t be changed. If you wish to add an array to a compound type, you must do so before the compound type is committed.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-about-a-compound-type-nf90_inq_compound}{}\subsubsection{5.\+6.\+4 Learn About a Compound Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND}\label{f90-user-defined-data-types_f90-learn-about-a-compound-type-nf90_inq_compound}
Get the number of fields, length in bytes, and name of a compound type.

In addtion to the N\+F90\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+ND function, three additional functions are provided which get only the name, size, and number of fields.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_compound(ncid, xtype, name, size, nfields)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: size
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: nfields
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound

\textcolor{keyword}{function }nf90\_inq\_compound\_name(ncid, xtype, name)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_name

\textcolor{keyword}{function }nf90\_inq\_compound\_size(ncid, xtype, size)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: size
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_size

\textcolor{keyword}{function }nf90\_inq\_compound\_nfields(ncid, xtype, nfields)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: nfields
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_nfields
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ID of any group in the file that contains the compound type.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this compound type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME}

\+: Character array which will get the name of the compound type. It will have a maximum length of N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily S\+I\+Z\+EP}

\+: The size of the compound type in bytes will be put here.

{\ttfamily N\+F\+I\+E\+L\+D\+SP}

\+: The number of fields in the compound type will be placed here.

\subsubsection*{Return Codes}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Couldn’t find this ncid.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Not a net\+C\+D\+F-\/4/\+H\+D\+F5 file.

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: A net\+C\+D\+F-\/4/\+H\+D\+F5 file, but with C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL. No user defined types are allowed in the classic model.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE}

\+: This type not a compound type.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad type id.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-about-a-field-of-a-compound-type-nf90_inq_compound_field}{}\subsubsection{5.\+6.\+5 Learn About a Field of a Compound Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+F\+I\+E\+LD}\label{f90-user-defined-data-types_f90-learn-about-a-field-of-a-compound-type-nf90_inq_compound_field}
Get information about one of the fields of a compound type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_compound\_field(ncid, xtype, fieldid, name, offset, &
     field\_typeid, ndims, dim\_sizes)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: fieldid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: offset
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: field\_typeid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ndims
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: dim\_sizes
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_field

\textcolor{keyword}{function }nf90\_inq\_compound\_fieldname(ncid, xtype, fieldid, name)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: fieldid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_fieldname

\textcolor{keyword}{function }nf90\_inq\_compound\_fieldindex(ncid, xtype, name, fieldid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: fieldid
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_fieldindex

\textcolor{keyword}{function }nf90\_inq\_compound\_fieldoffset(ncid, xtype, fieldid, offset)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: fieldid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: offset
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_fieldoffset

\textcolor{keyword}{function }nf90\_inq\_compound\_fieldtype(ncid, xtype, fieldid, field\_typeid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: fieldid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: field\_typeid
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_fieldtype

\textcolor{keyword}{function }nf90\_inq\_compound\_fieldndims(ncid, xtype, fieldid, ndims)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: fieldid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: ndims
  \textcolor{keywordtype}{integer} :: nf90\_inq\_compound\_fieldndims

\textcolor{keyword}{function }nf90\_inq\_cmp\_fielddim\_sizes(ncid, xtype, fieldid, dim\_sizes)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: fieldid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: dim\_sizes
  \textcolor{keywordtype}{integer} :: nf90\_inq\_cmp\_fielddim\_sizes
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The groupid where this compound type exists.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this compound type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily F\+I\+E\+L\+D\+ID}

\+: A one-\/based index number specifying a field in the compound type.

{\ttfamily N\+A\+ME}

\+: A character array which will get the name of the field. The name will be N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME characters, at most.

{\ttfamily O\+F\+F\+S\+E\+TP}

\+: An integer which will get the offset of the field.

{\ttfamily F\+I\+E\+L\+D\+\_\+\+T\+Y\+P\+E\+ID}

\+: An integer which will get the typeid of the field.

{\ttfamily N\+D\+I\+M\+SP}

\+: An integer which will get the number of dimensions of the field.

{\ttfamily D\+I\+M\+\_\+\+S\+I\+Z\+E\+SP}

\+: An integer array which will get the dimension sizes of the field.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad type id.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-variable-length-array-introduction}{}\subsection{5.\+7 Variable Length Array Introduction }\label{f90-user-defined-data-types_f90-variable-length-array-introduction}
Net\+C\+D\+F-\/4 added support for a variable length array type. This is not supported in classic or 64-\/bit offset files, or in net\+C\+D\+F-\/4 files which were created with the N\+F90\+\_\+\+C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+D\+EL flag.

A variable length array is represented in C as a structure from H\+D\+F5, the nf90\+\_\+vlen\+\_\+t structure. It contains a len member, which contains the length of that array, and a pointer to the array.

So an array of V\+L\+EN in C is an array of nc\+\_\+vlen\+\_\+t structures. The only way to handle this in Fortran is with a character buffer sized correctly for the platform.

V\+L\+EN arrays are handled differently with respect to allocation of memory. Generally, when reading data, it is up to the user to malloc (and subsequently free) the memory needed to hold the data. It is up to the user to ensure that enough memory is allocated.

With V\+L\+E\+Ns, this is impossible. The user cannot know the size of an array of V\+L\+EN until after reading the array. Therefore when reading V\+L\+EN arrays, the net\+C\+DF library will allocate the memory for the data within each V\+L\+EN.

It is up to the user, however, to eventually free this memory. This is not just a matter of one call to free, with the pointer to the array of V\+L\+E\+Ns; each V\+L\+EN contains a pointer which must be freed.

Compression is permitted but may not be effective for V\+L\+EN data, because the compression is applied to the nc\+\_\+vlen\+\_\+t structures, rather than the actual data.\hypertarget{f90-user-defined-data-types_f90-define-a-variable-length-array-vlen-nf90_def_vlen}{}\subsubsection{5.\+7.\+1 Define a Variable Length Array (\+V\+L\+E\+N)\+: N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+L\+EN}\label{f90-user-defined-data-types_f90-define-a-variable-length-array-vlen-nf90_def_vlen}
Use this function to define a variable length array type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_vlen(ncid, name, base\_typeid, xtypeid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: base\_typeid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: xtypeid
  \textcolor{keywordtype}{integer} :: nf90\_def\_vlen
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid of the file to create the V\+L\+EN type in.

{\ttfamily N\+A\+ME}

\+: A name for the V\+L\+EN type.

{\ttfamily B\+A\+S\+E\+\_\+\+T\+Y\+P\+E\+ID}

\+: The typeid of the base type of the V\+L\+EN. For example, for a V\+L\+EN of shorts, the base type is N\+F90\+\_\+\+S\+H\+O\+RT. This can be a user defined type.

{\ttfamily X\+T\+Y\+P\+EP}

\+: The typeid of the new V\+L\+EN type will be set here.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME exceeded.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: Name is already in use.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Attribute or variable name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: ncid invalid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID}

\+: Group ID part of ncid was invalid.

{\ttfamily N\+F90\+\_\+\+E\+I\+N\+V\+AL}

\+: Size is invalid.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+M\+EM}

\+: Out of memory.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learning-about-a-variable-length-array-vlen-type-nf90_inq_vlen}{}\subsubsection{5.\+7.\+2 Learning about a Variable Length Array (\+V\+L\+E\+N) Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+L\+EN}\label{f90-user-defined-data-types_f90-learning-about-a-variable-length-array-vlen-type-nf90_inq_vlen}
Use this type to learn about a vlen.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_vlen(ncid, xtype, name, datum\_size, base\_nc\_type)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: datum\_size
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: base\_nc\_type
  \textcolor{keywordtype}{integer} :: nf90\_inq\_vlen
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid of the file that contains the V\+L\+EN type.

{\ttfamily X\+T\+Y\+PE}

\+: The type of the V\+L\+EN to inquire about.

{\ttfamily N\+A\+ME}

\+: The name of the V\+L\+EN type. The name will be N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME characters or less.

{\ttfamily D\+A\+T\+U\+M\+\_\+\+S\+I\+Z\+EP}

\+: A pointer to a size\+\_\+t, this will get the size of one element of this vlen.

{\ttfamily B\+A\+S\+E\+\_\+\+N\+F90\+\_\+\+T\+Y\+P\+EP}

\+: An integer that will get the type of the V\+L\+EN base type. (In other words, what type is this a V\+L\+EN of?)

\paragraph*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE}

\+: Can’t find the typeid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: ncid invalid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+G\+R\+P\+ID}

\+: Group ID part of ncid was invalid.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-releasing-memory-for-a-variable-length-array-vlen-type-nf90_free_vlen}{}\subsubsection{5.\+7.\+3 Releasing Memory for a Variable Length Array (\+V\+L\+E\+N) Type\+: N\+F90\+\_\+\+F\+R\+E\+E\+\_\+\+V\+L\+EN}\label{f90-user-defined-data-types_f90-releasing-memory-for-a-variable-length-array-vlen-type-nf90_free_vlen}
When a V\+L\+EN is read into user memory from the file, the H\+D\+F5 library performs memory allocations for each of the variable length arrays contained within the V\+L\+EN structure. This memory must be freed by the user to avoid memory leaks.

This violates the normal net\+C\+DF expectation that the user is responsible for all memory allocation. But, with V\+L\+EN arrays, the underlying H\+D\+F5 library allocates the memory for the user, and the user is responsible for deallocating that memory.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_free\_vlen(vl)
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: vlen
  \textcolor{keywordtype}{integer} :: nf90\_free\_vlen
\textcolor{keyword}{end function }nf90\_free\_vlen
\end{DoxyCode}


{\ttfamily VL}

\+: The variable length array structure which is to be freed.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE}

\+: Can’t find the typeid.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-opaque-type-introduction}{}\subsection{5.\+8 Opaque Type Introduction }\label{f90-user-defined-data-types_f90-opaque-type-introduction}
Net\+C\+D\+F-\/4 added support for the opaque type. This is not supported in classic or 64-\/bit offset files.

The opaque type is a type which is a collection of objects of a known size. (And each object is the same size). Nothing is known to net\+C\+DF about the contents of these blobs of data, except their size in bytes, and the name of the type.

To use an opaque type, first define it with \href{#NF90_005fDEF_005fOPAQUE}{\tt Creating Opaque Types\+: N\+F90\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE}. If encountering an enum type in a new data file, use \href{#NF90_005fINQ_005fOPAQUE}{\tt Learn About an Opaque Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+O\+P\+A\+Q\+UE} to learn its name and size.\hypertarget{f90-user-defined-data-types_f90-creating-opaque-types-nf90_def_opaque}{}\subsubsection{5.\+8.\+1 Creating Opaque Types\+: N\+F90\+\_\+\+D\+E\+F\+\_\+\+O\+P\+A\+Q\+UE}\label{f90-user-defined-data-types_f90-creating-opaque-types-nf90_def_opaque}
Create an opaque type. Provide a size and a name.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_opaque(ncid, size, name, xtype)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: size
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: xtype
  \textcolor{keywordtype}{integer} :: nf90\_def\_opaque
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The groupid where the type will be created. The type may be used anywhere in the file, no matter what group it is in.

{\ttfamily N\+A\+ME}

\+: The name for this type. Must be shorter than N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily S\+I\+ZE}

\+: The size of each opaque object.

{\ttfamily T\+Y\+P\+E\+I\+DP}

\+: Pointer where the new typeid for this type is returned. Use this typeid when defining variables of this type with \href{#NF90_005fDEF_005fVAR}{\tt Create a Variable\+: {\ttfamily N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR}}.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad typeid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+F\+I\+E\+L\+D\+ID}

\+: Bad fieldid.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-about-an-opaque-type-nf90_inq_opaque}{}\subsubsection{5.\+8.\+2 Learn About an Opaque Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+O\+P\+A\+Q\+UE}\label{f90-user-defined-data-types_f90-learn-about-an-opaque-type-nf90_inq_opaque}
Given a typeid, get the information about an opaque type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_opaque(ncid, xtype, name, size)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: size
  \textcolor{keywordtype}{integer} :: nf90\_inq\_opaque
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid for the group containing the opaque type.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this opaque type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+C\+O\+M\+P\+O\+U\+ND, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME}

\+: The name of the opaque type will be copied here. It will be N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME bytes or less.

{\ttfamily S\+I\+Z\+EP}

\+: The size of the opaque type will be copied here.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad typeid.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+F\+I\+E\+L\+D\+ID}

\+: Bad fieldid.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-enum-type-introduction}{}\subsection{5.\+9 Enum Type Introduction }\label{f90-user-defined-data-types_f90-enum-type-introduction}
Net\+C\+D\+F-\/4 added support for the enum type. This is not supported in classic or 64-\/bit offset files.\hypertarget{f90-user-defined-data-types_f90-creating-a-enum-type-nf90_def_enum}{}\subsubsection{5.\+9.\+1 Creating a Enum Type\+: N\+F90\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM}\label{f90-user-defined-data-types_f90-creating-a-enum-type-nf90_def_enum}
Create an enum type. Provide an ncid, a name, and a base integer type.

After calling this function, fill out the type with repeated calls to N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM (see section \href{#NF90_005fINSERT_005fENUM}{\tt Inserting a Field into a Enum Type\+: N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM}). Call N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM once for each value you wish to make part of the enumeration.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_enum(ncid, base\_typeid, name, typeid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: base\_typeid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: typeid
  \textcolor{keywordtype}{integer} :: nf90\_def\_enum
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The groupid where this compound type will be created.

{\ttfamily B\+A\+S\+E\+\_\+\+T\+Y\+P\+E\+ID}

\+: The base integer type for this enum. Must be one of\+: N\+F90\+\_\+\+B\+Y\+TE, N\+F90\+\_\+\+U\+B\+Y\+TE, N\+F90\+\_\+\+S\+H\+O\+RT, N\+F90\+\_\+\+U\+S\+H\+O\+RT, N\+F90\+\_\+\+I\+NT, N\+F90\+\_\+\+U\+I\+NT, N\+F90\+\_\+\+I\+N\+T64, N\+F90\+\_\+\+U\+I\+N\+T64.

{\ttfamily N\+A\+ME}

\+: The name of the new enum type.

{\ttfamily T\+Y\+P\+E\+I\+DP}

\+: The typeid of the new type will be placed here.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: That name is in use. Compound type names must be unique in the data file.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: Name exceeds max length N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+P\+E\+RM}

\+: Attempt to write to a read-\/only file.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-inserting-a-field-into-a-enum-type-nf90_insert_enum}{}\subsubsection{5.\+9.\+2 Inserting a Field into a Enum Type\+: N\+F90\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+E\+N\+UM}\label{f90-user-defined-data-types_f90-inserting-a-field-into-a-enum-type-nf90_insert_enum}
Insert a named member into a enum type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_insert\_enum(ncid, xtype, name, value)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: value
  \textcolor{keywordtype}{integer} :: nf90\_insert\_enum
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The ncid of the group which contains the type.

{\ttfamily T\+Y\+P\+E\+ID}

\+: The typeid for this enum type, as returned by nf90\+\_\+def\+\_\+enum, or nf90\+\_\+inq\+\_\+var.

{\ttfamily I\+D\+E\+N\+T\+I\+F\+I\+ER}

\+: The identifier of the new member.

{\ttfamily V\+A\+L\+UE}

\+: The value that is to be associated with this member.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+ID}

\+: Bad group id.

{\ttfamily N\+F90\+\_\+\+E\+N\+A\+M\+E\+I\+N\+U\+SE}

\+: That name is in use. Field names must be unique within a enum type.

{\ttfamily N\+F90\+\_\+\+E\+M\+A\+X\+N\+A\+ME}

\+: Name exceed max length N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME}

\+: Name contains illegal characters.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Attempting a net\+C\+D\+F-\/4 operation on a net\+C\+D\+F-\/3 file. Net\+C\+D\+F-\/4 operations can only be performed on files defined with a create mode which includes flag N\+F90\+\_\+\+N\+E\+T\+C\+D\+F4. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3}

\+: This file was created with the strict netcdf-\/3 flag, therefore netcdf-\/4 operations are not allowed. (see section \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}).

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-about-a-enum-type-nf90_inq_enum}{}\subsubsection{5.\+9.\+3 Learn About a Enum Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+UM}\label{f90-user-defined-data-types_f90-learn-about-a-enum-type-nf90_inq_enum}
Get information about a user-\/defined enumeration type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_enum(ncid, xtype, name, base\_nc\_type, base\_size, num\_members)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: base\_nc\_type
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: base\_size
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: num\_members
  \textcolor{keywordtype}{integer} :: nf90\_inq\_enum
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The group ID of the group which holds the enum type.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this enum type, as returned by N\+F90\+\_\+\+D\+E\+F\+\_\+\+E\+N\+UM, or N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR.

{\ttfamily N\+A\+ME}

\+: Character array which will get the name. It will have a maximum length of N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily B\+A\+S\+E\+\_\+\+N\+F90\+\_\+\+T\+Y\+PE}

\+: An integer which will get the base integer type of this enum.

{\ttfamily B\+A\+S\+E\+\_\+\+S\+I\+ZE}

\+: An integer which will get the size (in bytes) of the base integer type of this enum.

{\ttfamily N\+U\+M\+\_\+\+M\+E\+M\+B\+E\+RS}

\+: An integer which will get the number of members defined for this enumeration type.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad type id.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-the-name-of-a-enum-type-nf90_inq_enum_member}{}\subsubsection{5.\+9.\+4 Learn the Name of a Enum Type\+: nf90\+\_\+inq\+\_\+enum\+\_\+member}\label{f90-user-defined-data-types_f90-learn-the-name-of-a-enum-type-nf90_inq_enum_member}
Get information about a member of an enum type.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_enum\_member(ncid, xtype, idx, name, value)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: idx
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: value
  \textcolor{keywordtype}{integer} :: nf90\_inq\_enum\_member
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The groupid where this enum type exists.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this enum type.

{\ttfamily I\+DX}

\+: The one-\/based index number for the member of interest.

{\ttfamily N\+A\+ME}

\+: A character array which will get the name of the member. It will have a maximum length of N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily V\+A\+L\+UE}

\+: An integer that will get the value associated with this member.

\subsubsection*{Errors}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad type id.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

\subsubsection*{Example}\hypertarget{f90-user-defined-data-types_f90-learn-the-name-of-a-enum-type-nf90_inq_enum_ident}{}\subsubsection{5.\+9.\+5 Learn the Name of a Enum Type\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+U\+M\+\_\+\+I\+D\+E\+NT}\label{f90-user-defined-data-types_f90-learn-the-name-of-a-enum-type-nf90_inq_enum_ident}
Get the name which is associated with an enum member value.

This is similar to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+E\+N\+U\+M\+\_\+\+M\+E\+M\+B\+ER, but instead of using the index of the member, you use the value of the member.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_enum\_ident(ncid, xtype, value, idx)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: xtype
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: value
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: idx
  \textcolor{keywordtype}{integer} :: nf90\_inq\_enum\_ident
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: The groupid where this enum type exists.

{\ttfamily X\+T\+Y\+PE}

\+: The typeid for this enum type.

{\ttfamily V\+A\+L\+UE}

\+: The value for which an identifier is sought.

{\ttfamily I\+D\+E\+N\+T\+I\+F\+I\+ER}

\+: A character array that will get the identifier. It will have a maximum length of N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

\subsubsection*{Return Code}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+P\+E\+ID}

\+: Bad type id, or not an enum type.

{\ttfamily N\+F90\+\_\+\+E\+H\+D\+F\+E\+RR}

\+: An error was reported by the H\+D\+F5 layer.

{\ttfamily N\+F90\+\_\+\+E\+I\+N\+V\+AL}

\+: The value was not found in the enum.

\subsubsection*{Example}\hypertarget{f90-variables}{}\section{6 Variables}\label{f90-variables}
\hypertarget{f90-variables_f90-variables-introduction}{}\subsection{6.\+1 Variables Introduction }\label{f90-variables_f90-variables-introduction}
Variables for a net\+C\+DF dataset are defined when the dataset is created, while the net\+C\+DF dataset is in define mode. Other variables may be added later by reentering define mode. A net\+C\+DF variable has a name, a type, and a shape, which are specified when it is defined. A variable may also have values, which are established later in data mode.

Ordinarily, the name, type, and shape are fixed when the variable is first defined. The name may be changed, but the type and shape of a variable cannot be changed. However, a variable defined in terms of the unlimited dimension can grow without bound in that dimension.

A net\+C\+DF variable in an open net\+C\+DF dataset is referred to by a small integer called a variable ID.

Variable I\+Ds reflect the order in which variables were defined within a net\+C\+DF dataset. Variable I\+Ds are 1, 2, 3,..., in the order in which the variables were defined. A function is available for getting the variable ID from the variable name and vice-\/versa.

Attributes (see \href{#Attributes}{\tt Attributes}) may be associated with a variable to specify such properties as units.

Operations supported on variables are\+:


\begin{DoxyItemize}
\item Create a variable, given its name, data type, and shape.
\item Get a variable ID from its name.
\item Get a variable’s name, data type, shape, and number of attributes from its ID.
\item Put a data value into a variable, given variable ID, indices, and value.
\item Put an array of values into a variable, given variable ID, corner indices, edge lengths, and a block of values.
\item Put a subsampled or mapped array-\/section of values into a variable, given variable ID, corner indices, edge lengths, stride vector, index mapping vector, and a block of values.
\item Get a data value from a variable, given variable ID and indices.
\item Get an array of values from a variable, given variable ID, corner indices, and edge lengths.
\item Get a subsampled or mapped array-\/section of values from a variable, given variable ID, corner indices, edge lengths, stride vector, and index mapping vector.
\item Rename a variable.
\end{DoxyItemize}\hypertarget{f90-variables_f90-language-types-corresponding-to-netcdf-external-data-types}{}\subsection{6.\+2 Language Types Corresponding to net\+C\+D\+F external data types }\label{f90-variables_f90-language-types-corresponding-to-netcdf-external-data-types}
The following table gives the net\+C\+DF external data types and the corresponding type constants for defining variables in the F\+O\+R\+T\+R\+AN interface\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Type }&\textbf{ F\+O\+R\+T\+R\+AN A\+PI Mnemonic }&\textbf{ Bits  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Type }&\textbf{ F\+O\+R\+T\+R\+AN A\+PI Mnemonic }&\textbf{ Bits  }\\\cline{1-3}
\endhead
byte &N\+F90\+\_\+\+B\+Y\+TE &8 \\\cline{1-3}
char &N\+F90\+\_\+\+C\+H\+AR &8 \\\cline{1-3}
short &N\+F90\+\_\+\+S\+H\+O\+RT &16 \\\cline{1-3}
int &N\+F90\+\_\+\+I\+NT &32 \\\cline{1-3}
float &N\+F90\+\_\+\+F\+L\+O\+AT &32 \\\cline{1-3}
double &N\+F90\+\_\+\+D\+O\+U\+B\+LE &64 \\\cline{1-3}
\end{longtabu}


The first column gives the net\+C\+DF external data type, which is the same as the C\+DL data type. The next column gives the corresponding Fortran 90 parameter for use in net\+C\+DF functions (the parameters are defined in the net\+C\+DF Fortran 90 module netcdf.\+f90). The last column gives the number of bits used in the external representation of values of the corresponding type.

Note that there are no net\+C\+DF types corresponding to 64-\/bit integers or to characters wider than 8 bits in the current version of the net\+C\+DF library.\hypertarget{f90-variables_f90-create-a-variable-nf90_def_var}{}\subsection{6.\+3 Create a Variable\+: `\+N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R` }\label{f90-variables_f90-create-a-variable-nf90_def_var}
The function N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR adds a new variable to an open net\+C\+DF dataset in define mode. It returns (as an argument) a variable ID, given the net\+C\+DF ID, the variable name, the variable type, the number of dimensions, and a list of the dimension I\+Ds.

Optional arguments allow additional settings for variables in net\+C\+D\+F-\/4/\+H\+D\+F5 files. These parameters allow data compression and control of the layout of the data on disk for performance tuning. These parameters may also be used to set the chunk sizes to get chunked storage, or to set the contiguous flag to get contiguous storage.

Variables that make use of one or more unlimited dimensions, compression, or checksums must use chunking. Such variables are created with default chunk sizes of 1 for each unlimited dimension and the dimension length for other dimensions, except that if the resulting chunks are too large, the default chunk sizes for non-\/record dimensions are reduced.

All parameters after the varid are optional, and only supported if net\+C\+DF was built with net\+C\+D\+F-\/4 features enabled, and if the variable is in a net\+C\+D\+F-\/4/\+H\+D\+F5 file.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_def\_var(ncid, name, xtype, dimids, varid, contiguous, &
      chunksizes, deflate\_level, shuffle, fletcher32, endianness, &
      cache\_size, cache\_nelems, cache\_preemption)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent( in)} :: xtype
  \textcolor{keywordtype}{integer}, scalar or \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional} :: dimids
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: varid
  \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: contiguous
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: chunksizes
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: deflate\_level
  \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: shuffle, fletcher32
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: endianness
   \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(in)} :: cache\_size, cache\_nelems, cache\_preemption
  \textcolor{keywordtype}{integer}                                      :: nf90\_def\_var
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily name}

\+: Variable name.

{\ttfamily xtype}

\+: One of the set of predefined net\+C\+DF external data types. The type of this parameter, N\+F90\+\_\+\+T\+Y\+PE, is defined in the net\+C\+DF header file. The valid net\+C\+DF external data types are N\+F90\+\_\+\+B\+Y\+TE, N\+F90\+\_\+\+C\+H\+AR, N\+F90\+\_\+\+S\+H\+O\+RT, N\+F90\+\_\+\+I\+NT, N\+F90\+\_\+\+F\+L\+O\+AT, and N\+F90\+\_\+\+D\+O\+U\+B\+LE. If the file is a Net\+C\+D\+F-\/4/\+H\+D\+F5 file, the additional types N\+F90\+\_\+\+U\+B\+Y\+TE, N\+F90\+\_\+\+U\+S\+H\+O\+RT, N\+F90\+\_\+\+U\+I\+NT, N\+F90\+\_\+\+I\+N\+T64, N\+F90\+\_\+\+U\+I\+N\+T64, and N\+F90\+\_\+\+S\+T\+R\+I\+NG may be used, as well as a user defined type ID.

{\ttfamily dimids}

\+: Scalar or vector of dimension I\+Ds corresponding to the variable dimensions. For example, a vector of 2 dimension I\+Ds specifies a 2-\/dimensional matrix.

If an integer is passed for this parameter, a 1-\/D variable is created.

If this parameter is not passed (or is a 1D array of size zero) it means the variable is a scalar with no dimensions.

For classic data model files, if the ID of the unlimited dimension is included, it must be first. In expanded model net\+C\+D\+F4/\+H\+D\+F5 files, there may be any number of unlimited dimensions, and they may be used in any element of the dimids array.

This argument is optional, and if absent specifies a scalar with no dimensions.

{\ttfamily varid}

\+: Returned variable ID.

{\ttfamily storage}

\+: If N\+F90\+\_\+\+C\+O\+N\+T\+I\+G\+U\+O\+US, then contiguous storage is used for this variable. Variables that use deflation, shuffle filter, or checksums, or that have one or more unlimited dimensions cannot use contiguous storage.

If N\+F90\+\_\+\+C\+H\+U\+N\+K\+ED, then chunked storage is used for this variable. Chunk sizes may be specified with the chunksizes parameter. Default sizes will be used if chunking is required and this function is not called.

By default contiguous storage is used for fix-\/sized variables when conpression, chunking, shuffle, and checksums are not used.

{\ttfamily chunksizes}

\+: An array of chunk number of elements. This array has the number of elements along each dimension of the data chunk. The array must have the one chunksize for each dimension in the variable.

The total size of a chunk must be less than 4 GiB. That is, the product of all chunksizes and the size of the data (or the size of nc\+\_\+vlen\+\_\+t for V\+L\+EN types) must be less than 4 GiB. (This is a very large chunk size in any case.)

If not provided, but chunked data are needed, then default chunksizes will be chosen. For more information see \href{netcdf.html#Chunking}{\tt \{No value for ‘n-\/man’\}} in \{No value for ‘n-\/man’\}.

{\ttfamily shuffle}

\+: If non-\/zero, turn on the shuffle filter.

{\ttfamily deflate\+\_\+level}

\+: If the deflate parameter is non-\/zero, set the deflate level to this value. Must be between 1 and 9.

{\ttfamily fletcher32}

\+: Set to true to turn on fletcher32 checksums for this variable.

{\ttfamily endianness}

\+: Set to N\+F90\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+L\+I\+T\+T\+LE for little-\/endian format, N\+F90\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+IG for big-\/endian format, and N\+F90\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+N\+A\+T\+I\+VE (the default) for the native endianness of the platform.

{\ttfamily cache\+\_\+size}

\+: The size of the per-\/variable cache in Mega\+Bytes.

{\ttfamily cache\+\_\+nelems}

\+: The number slots in the per-\/variable chunk cache (should be a prime number larger than the number of chunks in the cache).

{\ttfamily cache\+\_\+preemption}

\+: The preemtion value must be between 0 and 100 inclusive and indicates how much chunks that have been fully read are favored for preemption. A value of zero means fully read chunks are treated no differently than other chunks (the preemption is strictly L\+RU) while a value of 100 means fully read chunks are always preempted before other chunks.

\subsection*{Return Codes}

N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error.


\begin{DoxyItemize}
\item N\+F90\+\_\+\+E\+B\+A\+D\+N\+A\+ME The specified variable name is the name of another existing variable.
\item N\+F90\+\_\+\+E\+B\+A\+D\+T\+Y\+PE The specified type is not a valid net\+C\+DF type.
\item N\+F90\+\_\+\+E\+M\+A\+X\+D\+I\+MS The specified number of dimensions is negative or more than the constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+V\+A\+R\+\_\+\+D\+I\+MS, the maximum number of dimensions permitted for a net\+C\+DF variable. (Does not apply to net\+C\+D\+F-\/4/\+H\+D\+F5 files unless they were created with the C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+DE flag.)
\item N\+F90\+\_\+\+E\+B\+A\+D\+D\+IM One or more of the dimension I\+Ds in the list of dimensions is not a valid dimension ID for the net\+C\+DF dataset.
\item N\+F90\+\_\+\+E\+M\+A\+X\+V\+A\+RS The number of variables would exceed the constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+V\+A\+RS, the maximum number of variables permitted in a classic net\+C\+DF dataset. (Does not apply to net\+C\+D\+F-\/4/\+H\+D\+F5 files unless they were created with the C\+L\+A\+S\+S\+I\+C\+\_\+\+M\+O\+DE flag.)
\item N\+F90\+\_\+\+B\+A\+D\+ID The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4 Net\+C\+D\+F-\/4 operation attempted on a files that is not a net\+C\+D\+F-\/4/\+H\+D\+F5 file. Only variables in Net\+C\+D\+F-\/4/\+H\+D\+F5 files may use compression, chunking, and endianness control.
\item N\+F90\+\_\+\+E\+N\+O\+T\+V\+AR Can’t find this variable.
\item N\+F90\+\_\+\+E\+I\+N\+V\+AL Invalid input. This may be because contiguous storage is requested for a variable that has compression, checksums, chunking, or one or more unlimited dimensions.
\item N\+F90\+\_\+\+E\+L\+A\+T\+E\+D\+EF This variable has already been the subject of a N\+F90\+\_\+\+E\+N\+D\+D\+EF call. Once enddef has been called, it is impossible to set the chunking for a variable. (In net\+C\+D\+F-\/4/\+H\+D\+F5 files N\+F90\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write.)
\item N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F90\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag. (see section \href{#NF90_005fCREATE}{\tt N\+F90\+\_\+\+C\+R\+E\+A\+TE}).
\item N\+F90\+\_\+\+E\+S\+T\+R\+I\+C\+T\+N\+C3 Trying to create a var some place other than the root group in a net\+C\+DF file with N\+F90\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 turned on.
\end{DoxyItemize}

\subsubsection*{Example}

Here is an example using N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR to create a variable named rh of type double with three dimensions, time, lat, and lon in a new net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: status, ncid
\textcolor{keywordtype}{integer} :: londimid, latdimid, timedimid
\textcolor{keywordtype}{integer} :: rhvarid
...
status = nf90\_create(\textcolor{stringliteral}{"foo.nc"}, nf90\_noclobber, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
...
\textcolor{comment}{! Define the dimensions}
status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"lat"}, 5, latdimid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"lon"}, 10, londimid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"time"}, nf90\_unlimited, timedimid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
...
\textcolor{comment}{! Define the variable}
status = nf90\_def\_var(ncid, \textcolor{stringliteral}{"rh"}, nf90\_double, &
                      (/ londimid, latdimid, timedimid /), rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
\end{DoxyCode}


In the following example, from nf\+\_\+test/f90tst\+\_\+vars2.\+f90, chunking, checksums, and endianness control are all used in a net\+C\+D\+F-\/4/\+H\+D\+F5 file.


\begin{DoxyCode}
\textcolor{comment}{! Create the netCDF file.}
\textcolor{comment}{call check(nf90\_create(FILE\_NAME, nf90\_netcdf4, ncid, cache\_nelems = CACHE\_NELEMS, &}
     cache\_size = cache\_size))

\textcolor{comment}{! Define the dimensions.}
\textcolor{comment}{call check(nf90\_def\_dim(ncid, "x", NX, x\_dimid))}
\textcolor{comment}{call check(nf90\_def\_dim(ncid, "y", NY, y\_dimid))}
dimids =  (/ y\_dimid, x\_dimid /)

\textcolor{comment}{! Define some variables.}
\textcolor{comment}{chunksizes = (/ NY, NX /)}
\textcolor{comment}{call check(nf90\_def\_var(ncid, VAR1\_NAME, NF90\_INT, dimids, varid1, chunksizes = chunksizes, &}
     shuffle = .true., fletcher32 = .true., endianness = nf90\_endian\_big\textcolor{comment}{, deflate\_level = deflate\_level))}
\textcolor{comment}{call check(nf90\_def\_var(ncid, VAR2\_NAME, NF90\_INT, dimids, varid2, contiguous = .TRUE.))}
\textcolor{comment}{call check(nf90\_def\_var(ncid, VAR3\_NAME, NF90\_INT64, varid3))}
\textcolor{comment}{call check(nf90\_def\_var(ncid, VAR4\_NAME, NF90\_INT, x\_dimid, varid4, contiguous = .TRUE.))}
\end{DoxyCode}
\hypertarget{f90-variables_f90-define-fill-parameters-for-a-variable-nf90_def_var_fill}{}\subsection{6.\+4 Define Fill Parameters for a Variable\+: `nf90\+\_\+def\+\_\+var\+\_\+fill` }\label{f90-variables_f90-define-fill-parameters-for-a-variable-nf90_def_var_fill}
The function N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+A\+R\+\_\+\+F\+I\+LL sets the fill parameters for a variable in a net\+C\+D\+F-\/4 file.

This function must be called after the variable is defined, but before N\+F90\+\_\+\+E\+N\+D\+D\+EF is called.

\subsection*{Usage}


\begin{DoxyCode}
nf90\_def\_var\_fill(\textcolor{keywordtype}{INTEGER} ncid, \textcolor{keywordtype}{INTEGER} varid, \textcolor{keywordtype}{INTEGER} no\_fill, fill\_value);
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID}

\+: Variable ID.

{\ttfamily N\+O\+\_\+\+F\+I\+LL}

\+: Set to non-\/zero value to set no\+\_\+fill mode on a variable. When this mode is on, fill values will not be written for the variable. This is helpful in high performance applications. For net\+C\+D\+F-\/4/\+H\+D\+F5 files (whether classic model or not), this may only be changed after the variable is defined, but before it is committed to disk (i.\+e. before the first N\+F90\+\_\+\+E\+N\+D\+D\+EF after the N\+F90\+\_\+\+D\+E\+F\+\_\+\+V\+AR.) For classic and 64-\/bit offset file, the no\+\_\+fill mode may be turned on and off at any time.

{\ttfamily F\+I\+L\+L\+\_\+\+V\+A\+L\+UE}

\+: A value which will be used as the fill value for the variable. Must be the same type as the variable. This will be written to a \+\_\+\+Fill\+Value attribute, created for this purpose. If N\+U\+LL, this argument will be ignored.

\subsection*{Return Codes}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+B\+A\+D\+ID}

\+: Bad ncid.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+V\+AR}

\+: Can’t find this variable.

{\ttfamily N\+F90\+\_\+\+E\+L\+A\+T\+E\+D\+EF}

\+: This variable has already been the subject of a N\+F90\+\_\+\+E\+N\+D\+D\+EF call. In net\+C\+D\+F-\/4 files N\+F90\+\_\+\+E\+N\+D\+D\+EF will be called automatically for any data read or write. Once enddef has been called, it is impossible to set the fill for a variable.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+I\+N\+D\+E\+F\+I\+NE}

\+: Not in define mode. This is returned for net\+C\+DF classic or 64-\/bit offset files, or for net\+C\+D\+F-\/4 files, when they were been created with N\+F90\+\_\+\+S\+T\+R\+I\+C\+T\+\_\+\+N\+C3 flag. (see section \href{#NF90_005fCREATE}{\tt N\+F90\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily N\+F90\+\_\+\+E\+P\+E\+RM}

\+: Attempt to create object in read-\/only file.

\subsection*{Example}\hypertarget{f90-variables_f90-learn-about-fill-parameters-for-a-variable-nf90_inq_var_fill}{}\subsection{6.\+5 Learn About Fill Parameters for a Variable\+: `\+N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+I\+L\+L` }\label{f90-variables_f90-learn-about-fill-parameters-for-a-variable-nf90_inq_var_fill}
The function N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+\_\+\+F\+I\+LL returns the fill settings for a variable in a net\+C\+D\+F-\/4 file.

\subsection*{Usage}


\begin{DoxyCode}
nf90\_inq\_var\_fill(\textcolor{keywordtype}{INTEGER} ncid, \textcolor{keywordtype}{INTEGER} varid, \textcolor{keywordtype}{INTEGER} no\_fill, fill\_value)
\end{DoxyCode}


{\ttfamily N\+C\+ID}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily V\+A\+R\+ID}

\+: Variable ID.

{\ttfamily N\+O\+\_\+\+F\+I\+LL}

\+: An integer which will get a 1 if no\+\_\+fill mode is set for this variable, and a zero if it is not set

{\ttfamily F\+I\+L\+L\+\_\+\+V\+A\+L\+UE}

\+: This will get the fill value for this variable. This parameter will be ignored if it is N\+U\+LL.

\subsection*{Return Codes}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+B\+A\+D\+ID}

\+: Bad ncid.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+N\+C4}

\+: Not a net\+C\+D\+F-\/4 file.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+V\+AR}

\+: Can’t find this variable.

\subsection*{Example}\hypertarget{f90-variables_f90-get-information-about-a-variable-from-its-id-nf90_inquire_variable}{}\subsection{6.\+6 Get Information about a Variable from Its I\+D\+: N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+V\+A\+R\+I\+A\+B\+L\+E }\label{f90-variables_f90-get-information-about-a-variable-from-its-id-nf90_inquire_variable}
N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+V\+A\+R\+I\+A\+B\+LE returns information about a net\+C\+DF variable given its ID. Information about a variable includes its name, type, number of dimensions, a list of dimension I\+Ds describing the shape of the variable, and the number of variable attributes that have been assigned to the variable.

All parameters after n\+Atts are optional, and only supported if net\+C\+DF was built with net\+C\+D\+F-\/4 features enabled, and if the variable is in a net\+C\+D\+F-\/4/\+H\+D\+F5 file.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inquire\_variable(ncid, varid, name, xtype, ndims, dimids, nAtts, &
     contiguous, chunksizes, deflate\_level, shuffle, fletcher32, endianness)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid, varid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: xtype, ndims
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: dimids
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: natts
  \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: contiguous
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(out)} :: chunksizes
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: deflate\_level
  \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: shuffle, fletcher32
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent(out)} :: endianness
  \textcolor{keywordtype}{integer} :: nf90\_inquire\_variable
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID.

{\ttfamily name}

\+: Returned variable name. The caller must allocate space for the returned name. The maximum possible length, in characters, of a variable name is given by the predefined constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily xtype}

\+: Returned variable type, one of the set of predefined net\+C\+DF external data types. The valid net\+C\+DF external data types are N\+F90\+\_\+\+B\+Y\+TE, N\+F90\+\_\+\+C\+H\+AR, N\+F90\+\_\+\+S\+H\+O\+RT, N\+F90\+\_\+\+I\+NT, N\+F90\+\_\+\+F\+L\+O\+AT, A\+ND N\+F90\+\_\+\+D\+O\+U\+B\+LE.

{\ttfamily ndims}

\+: Returned number of dimensions the variable was defined as using. For example, 2 indicates a matrix, 1 indicates a vector, and 0 means the variable is a scalar with no dimensions.

{\ttfamily dimids}

\+: Returned vector of $\ast$ndimsp dimension I\+Ds corresponding to the variable dimensions. The caller must allocate enough space for a vector of at least $\ast$ndimsp integers to be returned. The maximum possible number of dimensions for a variable is given by the predefined constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+V\+A\+R\+\_\+\+D\+I\+MS.

{\ttfamily natts}

\+: Returned number of variable attributes assigned to this variable.

{\ttfamily contiguous}

\+: On return, set to N\+F90\+\_\+\+C\+O\+N\+T\+I\+G\+U\+O\+US if this variable uses contiguous storage, N\+F90\+\_\+\+C\+H\+U\+N\+K\+ED if it uses chunked storage.

{\ttfamily chunksizes}

\+: An array of chunk sizes. The array must have the one element for each dimension in the variable.

{\ttfamily shuffle}

\+: True if the shuffle filter is turned on for this variable.

{\ttfamily deflate\+\_\+level}

\+: The deflate\+\_\+level from 0 to 9. A value of zero indicates no deflation is in use.

{\ttfamily fletcher32}

\+: Set to true if the fletcher32 checksum filter is turned on for this variable.

{\ttfamily endianness}

\+: Will be set to N\+F90\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+L\+I\+T\+T\+LE if this variable is stored in little-\/endian format, N\+F90\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+B\+IG if it is stored in big-\/endian format, and N\+F90\+\_\+\+E\+N\+D\+I\+A\+N\+\_\+\+N\+A\+T\+I\+VE if the endianness is not set, and the variable is not created yet.

These functions return the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+AR to find out about a variable named rh in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
   \textcolor{keywordtype}{use }netcdf
   \textcolor{keywordtype}{implicit none}
   \textcolor{keywordtype}{integer}                            :: status, ncid, &
                                         rhvarid       &
                                         numdims, numatts
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(nf90\_max\_var\_dims)} :: rhdimids
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_variable(ncid, rhvarid, ndims = numdims, natts = numatts)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_variable(ncid, rhvarid, dimids = rhdimids(:numdims))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-variables_f90-get-the-id-of-a-variable-from-the-name-nf90_inq_varid}{}\subsection{6.\+7 Get the I\+D of a variable from the name\+: N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+I\+D }\label{f90-variables_f90-get-the-id-of-a-variable-from-the-name-nf90_inq_varid}
Given the name of a varaible, nf90\+\_\+inq\+\_\+varid finds the variable ID.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inq\_varid(ncid, name, varid)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(out)} :: varid
  \textcolor{keywordtype}{integer} :: nf90\_inq\_varid
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily name}

\+: The variable name. The maximum possible length, in characters, of a variable name is given by the predefined constant N\+F90\+\_\+\+M\+A\+X\+\_\+\+N\+A\+ME.

{\ttfamily varid}

\+: Variable ID.

These functions return the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item Variable not found.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+ID to find out about a variable named rh in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
   \textcolor{keywordtype}{use }netcdf
   \textcolor{keywordtype}{implicit none}
   \textcolor{keywordtype}{integer}                            :: status, ncid, &
                                         rhvarid       &
                                         numdims, numatts
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(nf90\_max\_var\_dims)} :: rhdimids
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_error(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_variable(ncid, rhvarid, ndims = numdims, natts = numatts)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_variable(ncid, rhvarid, dimids = rhdimids(:numdims))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-variables_f90-writing-data-values-nf90_put_var}{}\subsection{6.\+8 Writing Data Values\+: N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R }\label{f90-variables_f90-writing-data-values-nf90_put_var}
The function N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR puts one or more data values into the variable of an open net\+C\+DF dataset that is in data mode. Required inputs are the net\+C\+DF ID, the variable ID, and one or more data values. Optional inputs may indicate the starting position of the data values in the net\+C\+DF variable (argument start), the sampling frequency with which data values are written into the net\+C\+DF variable (argument stride), and a mapping between the dimensions of the data array and the net\+C\+DF variable (argument map). The values to be written are associated with the net\+C\+DF variable by assuming that the first dimension of the net\+C\+DF variable varies fastest in the Fortran 90 interface. Data values are converted to the external type of the variable, if necessary.

Take care when using the simplest forms of this interface with record variables (variables that use the N\+F90\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension) when you don’t specify how many records are to be written. If you try to write all the values of a record variable into a net\+C\+DF file that has no record data yet (hence has 0 records), nothing will be written. Similarly, if you try to write all the values of a record variable from an array but there are more records in the file than you assume, more in-\/memory data will be accessed than you expect, which may cause a segmentation violation. To avoid such problems, it is better to specify start and count arguments for variables that use the N\+F90\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension.

\subsubsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_put\_var(ncid, varid, values, start, count, stride, map)
  \textcolor{keywordtype}{integer},                         \textcolor{keywordtype}{intent( in)} :: ncid, varid
  any valid \textcolor{keywordtype}{type}, scalar or array of any rank, &
                                   \textcolor{keywordtype}{intent( in)} :: values
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent( in)} :: start, count, stride, map
  \textcolor{keywordtype}{integer}                                      :: nf90\_put\_var
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID.

{\ttfamily values}

\+: The data value(s) to be written. The data may be of any type, and may be a scalar or an array of any rank. You cannot put C\+H\+A\+R\+A\+C\+T\+ER data into a numeric variable or numeric data into a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur. See \href{netcdf.html#Type-Conversion}{\tt Type Conversion} in Net\+C\+DF Users Guide.

{\ttfamily start}

\+: A vector of integers specifying the index in the variable where the first (or only) of the data values will be written. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The elements of start correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for writing the data values.

By default, start(\+:) = 1.

{\ttfamily count}

\+: A vector of integers specifying the number of indices selected along each dimension. To write a single value, for example, specify count as (1, 1, ..., 1). The elements of count correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of count corresponds to a count of the number of records to write.

By default, count(\+:num\+Dims) = shape(values) and count(num\+Dims + 1\+:) = 1, where num\+Dims = size(shape(values)).

{\ttfamily stride}

\+: A vector of integers that specifies the sampling interval along each dimension of the net\+C\+DF variable. The elements of the stride vector correspond, in order, to the net\+C\+DF variable’s dimensions (stride(1) gives the sampling interval along the most rapidly varying dimension of the net\+C\+DF variable). Sampling intervals are specified in type-\/independent units of elements (a value of 1 selects consecutive elements of the net\+C\+DF variable along the corresponding dimension, a value of 2 selects every other element, etc.).

By default, stride(\+:) = 1.

{\ttfamily imap}

\+: A vector of integers that specifies the mapping between the dimensions of a net\+C\+DF variable and the in-\/memory structure of the internal data array. The elements of the index mapping vector correspond, in order, to the net\+C\+DF variable’s dimensions (map(1) gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the net\+C\+DF variable). Distances between elements are specified in units of elements.

By default, edge\+Lengths = shape(values), and map = (/ 1, (product(edge\+Lengths(\+:i)), i = 1, size(edge\+Lengths) -\/ 1) /), that is, there is no mapping.

Use of Fortran 90 intrinsic functions (including reshape, transpose, and spread) may let you avoid using this argument.

\subsection*{Errors}

N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+A\+R1\+\_\+ type returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified indices were out of range for the rank of the specified variable. For example, a negative index or an index that is larger than the corresponding dimension length will cause an error.
\item The specified value is out of the range of values representable by the external data type of the variable.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR to set the (4,3,2) element of the variable named rh to 0.\+5 in an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we assume that we know that rh is dimensioned with lon, lat, and time, so we want to set the value of rh that corresponds to the fourth lon value, the third lat value, and the second time value\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, rhvarid, status
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_put\_var(ncid, rhvarid, 0.5, start = (/ 4, 3, 2 /) )
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


In this example we use N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR to add or change all the values of the variable named rh to 0.\+5 in an existing net\+C\+DF dataset named foo.\+nc. We assume that we know that rh is dimensioned with lon, lat, and time. In this example we query the net\+C\+DF file to discover the lengths of the dimensions, then use the Fortran 90 intrinsic function reshape to create a temporary array of data values which is the same shape as the net\+C\+DF variable.


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}                               :: ncid, rhvarid,status,          &
                                         londimid, latdimid, timedimid, &
                                         numlons, numlats, numtimes,    &
                                         i
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(nf90\_max\_var\_dims)} :: dimids
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! How big is the netCDF variable, that is, what are the lengths of}
\textcolor{comment}{!   its constituent dimensions?}
status = nf90\_inquire\_variable(ncid, rhvarid, dimids = dimids)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_dimension(ncid, dimids(1), len = numlons)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_dimension(ncid, dimids(2), len = numlats)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_dimension(ncid, dimids(3), len = numtimes)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Make a temporary array the same shape as the netCDF variable.}
status = nf90\_put\_var(ncid, rhvarid, &
                      reshape( &
                        (/ (0.5, i = 1, numlons * numlats * numtimes) /) , &
                       shape = (/ numlons, numlats, numtimes /) )
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


Here is an example using N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR to add or change a section of the variable named rh to 0.\+5 in an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we assume that we know that rh is dimensioned with lon, lat, and time, that there are ten lon values, five lat values, and three time values, and that we want to replace all the values at the last time.


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}            :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter} :: numlons = 10, numlats = 5, numtimes = 3
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} &
                   :: rhvalues
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Fill in all values at the last time}
rhvalues(:, :) = 0.5
status = nf90\_put\_var(ncid, rhvarid,rhvalues,       &
                      start = (/ 1, 1, numtimes /), &
                      count = (/ numlats, numlons, 1 /))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


Here is an example of using N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR to write every other point of a net\+C\+DF variable named rh having dimensions (6, 4).


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}            :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter} :: numlons = 6, numlats = 4
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} &
                   :: rhvalues = 0.5
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Fill in every other value using an array section}
status = nf90\_put\_var(ncid, rhvarid, rhvalues(::2, ::2), &
                      stride = (/ 2, 2 /))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


The following map vector shows the default mapping between a 2x3x4 net\+C\+DF variable and an internal array of the same shape\+:


\begin{DoxyCode}
\textcolor{keywordtype}{real},    \textcolor{keywordtype}{dimension(2, 3, 4)}:: a  \textcolor{comment}{! same shape as netCDF variable}
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(3)}      :: map  = (/ 1, 2, 6 /)
                    \textcolor{comment}{! netCDF dimension inter-element distance}
                    \textcolor{comment}{! ---------------- ----------------------}
                    \textcolor{comment}{! most rapidly varying       1}
                    \textcolor{comment}{! intermediate               2 (= map(1)*2)}
                    ! most slowly varying        6 (= map(2)*3)
\end{DoxyCode}


Using the map vector above obtains the same result as simply not passing a map vector at all.

Here is an example of using nf90\+\_\+put\+\_\+var to write a net\+C\+DF variable named rh whose dimensions are the transpose of the Fortran 90 array\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}                           :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter}                :: numlons = 6, numlats = 4
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} :: rhvalues
\textcolor{comment}{! netCDF variable has dimensions (numLats, numLons)}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{!Write transposed values: map vector would be (/ 1, numLats /) for}
\textcolor{comment}{!   no transposition}
status = nf90\_put\_var(ncid, rhvarid,rhvalues, map = (/ numlons, 1 /))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


The same effect can be obtained more simply using Fortran 90 intrinsic functions\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}                           :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter}                :: numlons = 6, numlats = 4
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} :: rhvalues
\textcolor{comment}{! netCDF variable has dimensions (numLats, numLons)}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_put\_var(ncid, rhvarid, transpose(rhvalues))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-variables_f90-reading-data-values-nf90_get_var}{}\subsection{6.\+9 Reading Data Values\+: N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+A\+R }\label{f90-variables_f90-reading-data-values-nf90_get_var}
The function N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR gets one or more data values from a net\+C\+DF variable of an open net\+C\+DF dataset that is in data mode. Required inputs are the net\+C\+DF ID, the variable ID, and a specification for the data values into which the data will be read. Optional inputs may indicate the starting position of the data values in the net\+C\+DF variable (argument start), the sampling frequency with which data values are read from the net\+C\+DF variable (argument stride), and a mapping between the dimensions of the data array and the net\+C\+DF variable (argument map). The values to be read are associated with the net\+C\+DF variable by assuming that the first dimension of the net\+C\+DF variable varies fastest in the Fortran 90 interface. Data values are converted from the external type of the variable, if necessary.

Take care when using the simplest forms of this interface with record variables (variables that use the N\+F90\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension) when you don’t specify how many records are to be read. If you try to read all the values of a record variable into an array but there are more records in the file than you assume, more data will be read than you expect, which may cause a segmentation violation. To avoid such problems, it is better to specify the optional start and count arguments for variables that use the N\+F90\+\_\+\+U\+N\+L\+I\+M\+I\+T\+ED dimension.

In net\+C\+DF classic model the maximum integer size is N\+F90\+\_\+\+I\+NT, the 4-\/byte signed integer. Reading variables into an eight-\/byte integer array from a classic model file will read from an N\+F90\+\_\+\+I\+NT. Reading variables into an eight-\/byte integer in a net\+C\+D\+F-\/4/\+H\+D\+F5 (without classic model flag) will read from an N\+F90\+\_\+\+I\+N\+T64

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_get\_var(ncid, varid, values, start, count, stride, map)
  \textcolor{keywordtype}{integer},                         \textcolor{keywordtype}{intent( in)} :: ncid, varid
  any valid \textcolor{keywordtype}{type}, scalar or array of any rank, &
                                   \textcolor{keywordtype}{intent(out)} :: values
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{optional}, \textcolor{keywordtype}{intent( in)} :: start, count, stride, map
  \textcolor{keywordtype}{integer}                                      :: nf90\_get\_var
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID.

{\ttfamily values}

\+: The data value(s) to be read. The data may be of any type, and may be a scalar or an array of any rank. You cannot read C\+H\+A\+R\+A\+C\+T\+ER data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur. See \href{netcdf.html#Type-Conversion}{\tt Type Conversion} in Net\+C\+DF Users Guide.

{\ttfamily start}

\+: A vector of integers specifying the index in the variable from which the first (or only) of the data values will be read. The indices are relative to 1, so for example, the first data value of a variable would have index (1, 1, ..., 1). The elements of start correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last index would correspond to the starting record number for writing the data values.

By default, start(\+:) = 1.

{\ttfamily count}

\+: A vector of integers specifying the number of indices selected along each dimension. To read a single value, for example, specify count as (1, 1, ..., 1). The elements of count correspond, in order, to the variable’s dimensions. Hence, if the variable is a record variable, the last element of count corresponds to a count of the number of records to read.

By default, count(\+:num\+Dims) = shape(values) and count(num\+Dims + 1\+:) = 1, where num\+Dims = size(shape(values)).

{\ttfamily stride}

\+: A vector of integers that specifies the sampling interval along each dimension of the net\+C\+DF variable. The elements of the stride vector correspond, in order, to the net\+C\+DF variable’s dimensions (stride(1) gives the sampling interval along the most rapidly varying dimension of the net\+C\+DF variable). Sampling intervals are specified in type-\/independent units of elements (a value of 1 selects consecutive elements of the net\+C\+DF variable along the corresponding dimension, a value of 2 selects every other element, etc.).

By default, stride(\+:) = 1.

{\ttfamily map}

\+: A vector of integers that specifies the mapping between the dimensions of a net\+C\+DF variable and the in-\/memory structure of the internal data array. The elements of the index mapping vector correspond, in order, to the net\+C\+DF variable’s dimensions (map(1) gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the net\+C\+DF variable). Distances between elements are specified in units of elements.

By default, edge\+Lengths = shape(values), and map = (/ 1, (product(edge\+Lengths(\+:i)), i = 1, size(edge\+Lengths) -\/ 1) /), that is, there is no mapping.

Use of Fortran 90 intrinsic functions (including reshape, transpose, and spread) may let you avoid using this argument.

\subsection*{Errors}

N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The assumed or specified start, count, and stride generate an index which is out of range. Note that no error checking is possible on the map vector.
\item One or more of the specified values are out of the range of values representable by the desired type.
\item The specified net\+C\+DF is in define mode rather than data mode.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

(As noted above, another possible source of error is using this interface to read all the values of a record variable without specifying the number of records. If there are more records in the file than you assume, more data will be read than you expect!)

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR to read the (4,3,2) element of the variable named rh from an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we assume that we know that rh is dimensioned with lon, lat, and time, so we want to read the value of rh that corresponds to the fourth lon value, the third lat value, and the second time value\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, rhvarid, status
\textcolor{keywordtype}{real}    :: rhvalue
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
-
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_get\_var(ncid, rhvarid, rhvalue, start = (/ 4, 3, 2 /) )
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


In this example we use N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR to read all the values of the variable named rh from an existing net\+C\+DF dataset named foo.\+nc. We assume that we know that rh is dimensioned with lon, lat, and time. In this example we query the net\+C\+DF file to discover the lengths of the dimensions, then allocate a Fortran 90 array the same shape as the net\+C\+DF variable.

use netcdf implicit none integer \+:\+: nc\+Id, rh\+Var\+Id, \& lon\+Dim\+ID, lat\+Dim\+Id, time\+Dim\+Id, \& num\+Lons, num\+Lats, num\+Times, \& status integer, dimension(nf90\+\_\+max\+\_\+var\+\_\+dims) \+:\+: dim\+I\+Ds real, dimension(\+:, \+:, \+:), allocatable \+:\+: rh\+Values ... status = nf90\+\_\+open(\char`\"{}foo.\+nc\char`\"{}, nf90\+\_\+\+No\+Write, ncid) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status) ... status = nf90\+\_\+inq\+\_\+varid(ncid, \char`\"{}rh\char`\"{}, rh\+Var\+Id) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status) ! How big is the net\+C\+DF variable, that is, what are the lengths of ! its constituent dimensions? status = nf90\+\_\+inquire\+\_\+variable(ncid, rh\+Var\+Id, dimids = dim\+I\+Ds) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status) status = nf90\+\_\+inquire\+\_\+dimension(ncid, dim\+I\+Ds(1), len = num\+Lons) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status) status = nf90\+\_\+inquire\+\_\+dimension(ncid, dim\+I\+Ds(2), len = num\+Lats) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status) status = nf90\+\_\+inquire\+\_\+dimension(ncid, dim\+I\+Ds(3), len = num\+Times) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status) allocate(rh\+Values(num\+Lons, num\+Lats, num\+Times)) ... status = nf90\+\_\+get\+\_\+var(ncid, rh\+Var\+Id, rh\+Values) if(status /= nf90\+\_\+\+No\+Err) call handle\+\_\+err(status)

Here is an example using N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR to read a section of the variable named rh from an existing net\+C\+DF dataset named foo.\+nc. For simplicity in this example, we assume that we know that rh is dimensioned with lon, lat, and time, that there are ten lon values, five lat values, and three time values, and that we want to replace all the values at the last time.


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}            :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter} :: numlons = 10, numlats = 5, numtimes = 3
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats, numTimes)} &
                   :: rhvalues
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{!Read the values at the last time by passing an array section}
status = nf90\_get\_var(ncid, rhvarid, rhvalues(:, :, 3), &
                      start = (/ 1, 1, numtimes /),     &
                      count = (/ numlons, numlats, 1 /))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


Here is an example of using N\+F90\+\_\+\+G\+E\+T\+\_\+\+V\+AR to read every other point of a net\+C\+DF variable named rh having dimensions (6, 4).


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}            :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter} :: numlons = 6, numlats = 4
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} &
                   :: rhvalues
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Read every other value into an array section}
status = nf90\_get\_var(ncid, rhvarid, rhvalues(::2, ::2) &
                      stride = (/ 2, 2 /))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


The following map vector shows the default mapping between a 2x3x4 net\+C\+DF variable and an internal array of the same shape\+:


\begin{DoxyCode}
\textcolor{keywordtype}{real},    \textcolor{keywordtype}{dimension(2, 3, 4)}:: a  \textcolor{comment}{! same shape as netCDF variable}
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{dimension(3)}      :: map  = (/ 1, 2, 6 /)
                    \textcolor{comment}{! netCDF dimension inter-element distance}
                    \textcolor{comment}{! ---------------- ----------------------}
                    \textcolor{comment}{! most rapidly varying       1}
                    \textcolor{comment}{! intermediate               2 (= map(1)*2)}
                    ! most slowly varying        6 (= map(2)*3)
\end{DoxyCode}


Using the map vector above obtains the same result as simply not passing a map vector at all.

Here is an example of using nf90\+\_\+get\+\_\+var to read a net\+C\+DF variable named rh whose dimensions are the transpose of the Fortran 90 array\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}                           :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter}                :: numlons = 6, numlats = 4
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} :: rhvalues
\textcolor{comment}{! netCDF variable has dimensions (numLats, numLons)}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Read transposed values: map vector would be (/ 1, numLats /) for}
\textcolor{comment}{!   no transposition}
status = nf90\_get\_var(ncid, rhvarid,rhvalues, map = (/ numlons, 1 /))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}


The same effect can be obtained more simply, though using more memory, using Fortran 90 intrinsic functions\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}                           :: ncid, rhvarid, status
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter}                :: numlons = 6, numlats = 4
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} :: rhvalues
\textcolor{comment}{! netCDF variable has dimensions (numLats, numLons)}
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(numLons, numLats)} :: tempvalues
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_get\_var(ncid, rhvarid, tempvalues))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
rhvalues(:, :) = transpose(tempvalues)
\end{DoxyCode}
\hypertarget{f90-variables_f90-reading-and-writing-character-string-values}{}\subsection{6.\+10 Reading and Writing Character String Values }\label{f90-variables_f90-reading-and-writing-character-string-values}
Character strings are not a primitive net\+C\+DF external data type under the classic net\+C\+DF data model, in part because F\+O\+R\+T\+R\+AN does not support the abstraction of variable-\/length character strings (the F\+O\+R\+T\+R\+AN L\+EN function returns the static length of a character string, not its dynamic length). As a result, a character string cannot be written or read as a single object in the net\+C\+DF interface. Instead, a character string must be treated as an array of characters, and array access must be used to read and write character strings as variable data in net\+C\+DF datasets. Furthermore, variable-\/length strings are not supported by the net\+C\+DF classic interface except by convention; for example, you may treat a zero byte as terminating a character string, but you must explicitly specify the length of strings to be read from and written to net\+C\+DF variables.

Character strings as attribute values are easier to use, since the strings are treated as a single unit for access. However, the value of a character-\/string attribute in the classic net\+C\+DF interface is still an array of characters with an explicit length that must be specified when the attribute is defined.

When you define a variable that will have character-\/string values, use a character-\/position dimension as the most quickly varying dimension for the variable (the first dimension for the variable in Fortran 90). The length of the character-\/position dimension will be the maximum string length of any value to be stored in the character-\/string variable. Space for maximum-\/length strings will be allocated in the disk representation of character-\/string variables whether you use the space or not. If two or more variables have the same maximum length, the same character-\/position dimension may be used in defining the variable shapes.

To write a character-\/string value into a character-\/string variable, use either entire variable access or array access. The latter requires that you specify both a corner and a vector of edge lengths. The character-\/position dimension at the corner should be one for Fortran 90. If the length of the string to be written is n, then the vector of edge lengths will specify n in the character-\/position dimension, and one for all the other dimensions\+: (n, 1, 1, ..., 1).

In Fortran 90, fixed-\/length strings may be written to a net\+C\+DF dataset without a terminating character, to save space. Variable-\/length strings should follow the C convention of writing strings with a terminating zero byte so that the intended length of the string can be determined when it is later read by either C or Fortran 90 programs. It is the users responsibility to provide such null termination.

If you are writing data in the default prefill mode (see next section), you can ensure that simple strings represented as 1-\/dimensional character arrays are null terminated in the net\+C\+DF file by writing fewer characters than the length declared when the variable was defined. That way, the extra unwritten characters will be filled with the default character fill value, which is a null byte. The Fortran intrinsic T\+R\+IM function can be used to trim trailing blanks from the character string argument to N\+F90\+\_\+\+P\+U\+T\+\_\+\+V\+AR to make the argument shorter than the declared length. If prefill is not on, the data writer must explicitly provide a null terminating byte.

Here is an example illustrating this way of writing strings to character array variables\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} status
\textcolor{keywordtype}{integer}                           :: ncid, oceanstrlenid, oceanid
\textcolor{keywordtype}{integer}, \textcolor{keywordtype}{parameter}                :: maxoceannamelen = 20
\textcolor{keywordtype}{character}, (len = maxoceannamelen):: ocean
...
status = nf90\_create(\textcolor{stringliteral}{"foo.nc"}, nf90\_noclobber, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_def\_dim(ncid, \textcolor{stringliteral}{"oceanStrLen"}, maxoceannamelen, oceanstrlenid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_def\_var(ncid, \textcolor{stringliteral}{"ocean"}, nf90\_char, (/ oceanstrlenid /), oceanid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Leave define mode, which prefills netCDF variables with fill values}
status = nf90\_enddef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Note that this assignment adds blank fill}
ocean = \textcolor{stringliteral}{"Pacific"}
\textcolor{comment}{! Using trim removes trailing blanks, prefill provides null}
\textcolor{comment}{! termination, so C programs can later get intended string.}
status = nf90\_put\_var(ncid, oceanid, trim(ocean))
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-variables_f90-fill-values}{}\subsection{6.\+11 Fill Values }\label{f90-variables_f90-fill-values}
What happens when you try to read a value that was never written in an open net\+C\+DF dataset? You might expect that this should always be an error, and that you should get an error message or an error status returned. You do get an error if you try to read data from a net\+C\+DF dataset that is not open for reading, if the variable ID is invalid for the specified net\+C\+DF dataset, or if the specified indices are not properly within the range defined by the dimension lengths of the specified variable. Otherwise, reading a value that was not written returns a special fill value used to fill in any undefined values when a net\+C\+DF variable is first written.

You may ignore fill values and use the entire range of a net\+C\+DF external data type, but in this case you should make sure you write all data values before reading them. If you know you will be writing all the data before reading it, you can specify that no prefilling of variables with fill values will occur by calling writing. This may provide a significant performance gain for net\+C\+DF writes.

The variable attribute \+\_\+\+Fill\+Value may be used to specify the fill value for a variable. There are default fill values for each type, defined in module netcdf\+: N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+C\+H\+AR, N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+I\+N\+T1 (same as N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+B\+Y\+TE), N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+I\+N\+T2 (same as N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+S\+H\+O\+RT), N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+I\+NT, N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+R\+E\+AL (same as N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+F\+L\+O\+AT), and N\+F90\+\_\+\+F\+I\+L\+L\+\_\+\+D\+O\+U\+B\+LE

The net\+C\+DF byte and character types have different default fill values. The default fill value for characters is the zero byte, a useful value for detecting the end of variable-\/length C character strings. If you need a fill value for a byte variable, it is recommended that you explicitly define an appropriate \+\_\+\+Fill\+Value attribute, as generic utilities such as ncdump will not assume a default fill value for byte variables.

Type conversion for fill values is identical to type conversion for other values\+: attempting to convert a value from one type to another type that can’t represent the value results in a range error. Such errors may occur on writing or reading values from a larger type (such as double) to a smaller type (such as float), if the fill value for the larger type cannot be represented in the smaller type.\hypertarget{f90-variables_f90-nf90_rename_var}{}\subsection{6.\+12 N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+A\+R }\label{f90-variables_f90-nf90_rename_var}
The function N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR changes the name of a net\+C\+DF variable in an open net\+C\+DF dataset. If the new name is longer than the old name, the net\+C\+DF dataset must be in define mode. You cannot rename a variable to have the name of any existing variable.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_rename\_var(ncid, varid, newname)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid, varid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: newname
  \textcolor{keywordtype}{integer}                          :: nf90\_rename\_var
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID.

{\ttfamily newname}

\+: New name for the specified variable.

\subsection*{Errors}

N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The new name is in use as the name of another variable.
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+V\+AR to rename the variable rh to rel\+\_\+hum in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, rhvarid, status
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_redef(ncid)  \textcolor{comment}{! Enter define mode to change variable name}
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_rename\_var(ncid, rhvarid, \textcolor{stringliteral}{"rel\_hum"})
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_enddef(ncid) \textcolor{comment}{! Leave define mode}
\textcolor{keywordflow}{if}(status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-variables_f90-change-between-collective-and-independent-parallel-access-nf90_var_par_access}{}\subsection{6.\+13 Change between Collective and Independent Parallel Access\+: N\+F90\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+S\+S }\label{f90-variables_f90-change-between-collective-and-independent-parallel-access-nf90_var_par_access}
The function N\+F90\+\_\+\+V\+A\+R\+\_\+\+P\+A\+R\+\_\+\+A\+C\+C\+E\+SS changes whether read/write operations on a parallel file system are performed collectively or independently (the default) on the variable. This function can only be called if the file was created (see \href{#NF90_005fCREATE}{\tt N\+F90\+\_\+\+C\+R\+E\+A\+TE}) or opened (see \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}) for parallel I/O.

This function is only available if the net\+C\+DF library was built with parallel I/O enabled.

Calling this function affects only the open file -\/ information about whether a variable is to be accessed collectively or independently is not written to the data file. Every time you open a file on a parallel file system, all variables default to independent operations. The change of a variable to collective access lasts only as long as that file is open.

The variable can be changed from collective to independent, and back, as often as desired.

Classic and 64-\/bit offset files, when opened for parallel access, use the parallel-\/netcdf (a.\+k.\+a. pnetcdf) library, which does not allow per-\/variable changes of access mode -\/ the entire file must be access independently or collectively. For classic and 64-\/bit offset files, the nf90\+\_\+var\+\_\+par\+\_\+access function changes the access for all variables in the file.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_var\_par\_access(ncid, varid, access)
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: ncid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: varid
  \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: access
  \textcolor{keywordtype}{integer} :: nf90\_var\_par\_access
\textcolor{keyword}{end function }nf90\_var\_par\_access
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN (see \href{#NF90_005fOPEN}{\tt N\+F90\+\_\+\+O\+P\+EN}) or N\+F90\+\_\+\+C\+R\+E\+A\+TE (see \href{#NF90_005fCREATE}{\tt N\+F90\+\_\+\+C\+R\+E\+A\+TE}).

{\ttfamily varid}

\+: Variable ID.

{\ttfamily access}

\+: N\+F90\+\_\+\+I\+N\+D\+E\+P\+E\+N\+D\+E\+NT to set this variable to independent operations. N\+F90\+\_\+\+C\+O\+L\+L\+E\+C\+T\+I\+VE to set it to collective operations.

\subsection*{Return Values}

{\ttfamily N\+F90\+\_\+\+N\+O\+E\+RR}

\+: No error.

{\ttfamily N\+F90\+\_\+\+E\+N\+O\+T\+V\+AR}

\+: No variable found.

{\ttfamily N\+F90\+\_\+\+N\+O\+P\+AR}

\+: File not opened for parallel access.

\subsection*{Example}

This example comes from test program nf\+\_\+test/f90tst\+\_\+parallel.\+f90. For this test to be run, net\+C\+DF must have been built with a parallel-\/enabled H\+D\+F5, and –enable-\/parallel-\/tests must have been used when configuring netcdf.


\begin{DoxyCode}
\textcolor{comment}{! Reopen the file.}
\textcolor{comment}{call handle\_err(nf90\_open(FILE\_NAME, nf90\_nowrite, ncid, comm = MPI\_COMM\_WORLD, &}
     info = mpi\_info\_null))

\textcolor{comment}{! Set collective access on this variable. This will cause all}
\textcolor{comment}{! reads/writes to happen together on every processor.}
\textcolor{comment}{call handle\_err(nf90\_var\_par\_access(ncid, varid, nf90\_collective))}

\textcolor{comment}{! Read this processor's data.}
\textcolor{comment}{call handle\_err(nf90\_get\_var(ncid, varid, data\_in, start = start, count = count))}
\end{DoxyCode}
 \hypertarget{f90-attributes}{}\section{7 Attributes}\label{f90-attributes}
\hypertarget{f90-attributes_f90-attributes-introduction}{}\subsection{7.\+1 Attributes Introduction }\label{f90-attributes_f90-attributes-introduction}
Attributes may be associated with each net\+C\+DF variable to specify such properties as units, special values, maximum and minimum valid values, scaling factors, and offsets. Attributes for a net\+C\+DF dataset are defined when the dataset is first created, while the net\+C\+DF dataset is in define mode. Additional attributes may be added later by reentering define mode. A net\+C\+DF attribute has a net\+C\+DF variable to which it is assigned, a name, a type, a length, and a sequence of one or more values. An attribute is designated by its variable ID and name. When an attribute name is not known, it may be designated by its variable ID and number in order to determine its name, using the function N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME.

The attributes associated with a variable are typically defined immediately after the variable is created, while still in define mode. The data type, length, and value of an attribute may be changed even when in data mode, as long as the changed attribute requires no more space than the attribute as originally defined.

It is also possible to have attributes that are not associated with any variable. These are called global attributes and are identified by using N\+F90\+\_\+\+G\+L\+O\+B\+AL as a variable pseudo-\/\+ID. Global attributes are usually related to the net\+C\+DF dataset as a whole and may be used for purposes such as providing a title or processing history for a net\+C\+DF dataset.

Attributes are much more useful when they follow established community conventions. See \href{netcdf.html#Attribute-Conventions}{\tt Attribute Conventions} in \{No value for ‘n-\/man’\}.

Operations supported on attributes are\+:


\begin{DoxyItemize}
\item Create an attribute, given its variable ID, name, data type, length, and value.
\item Get attribute’s data type and length from its variable ID and name.
\item Get attribute’s value from its variable ID and name.
\item Copy attribute from one net\+C\+DF variable to another.
\item Get name of attribute from its number.
\item Rename an attribute.
\item Delete an attribute.
\end{DoxyItemize}\hypertarget{f90-attributes_f90-create-an-attribute-nf90_put_att}{}\subsection{7.\+2 Create an Attribute\+: N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+T\+T }\label{f90-attributes_f90-create-an-attribute-nf90_put_att}
The function N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+T\+Tadds or changes a variable attribute or global attribute of an open net\+C\+DF dataset. If this attribute is new, or if the space required to store the attribute is greater than before, the net\+C\+DF dataset must be in define mode.

\subsection*{Usage}

Although it’s possible to create attributes of all types, text and double attributes are adequate for most purposes.


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_put\_att(ncid, varid, name, values)
  \textcolor{keywordtype}{integer},            \textcolor{keywordtype}{intent( in)} :: ncid, varid
  \textcolor{keywordtype}{character(len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  scalar \textcolor{keywordtype}{character} string or any numeric \textcolor{keywordtype}{type}, scalar, or array of rank 1, &
                      \textcolor{keywordtype}{intent( in)} :: values
  \textcolor{keywordtype}{integer}                         :: nf90\_put\_att
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID of the variable to which the attribute will be assigned or N\+F90\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily name}

\+: Attribute name. Attribute name conventions are assumed by some net\+C\+DF generic applications, e.\+g., ‘units’ as the name for a string attribute that gives the units for a net\+C\+DF variable. See \href{netcdf.html#Attribute-Conventions}{\tt Attribute Conventions} in \{No value for ‘n-\/man’\}.

{\ttfamily values}

\+: A numeric rank 1 array of attribute values or a scalar. The external data type of the attribute is set to match the internal representation of the argument, that is if values is a two byte integer array, the attribute will be of type N\+F90\+\_\+\+I\+N\+T2. Fortran 90 intrinsic functions can be used to convert attributes to the desired type.

\subsection*{Errors}

N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified net\+C\+DF type is invalid.
\item The specified length is negative.
\item The specified open net\+C\+DF dataset is in data mode and the specified attribute would expand.
\item The specified open net\+C\+DF dataset is in data mode and the specified attribute does not already exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item The number of attributes for this variable exceeds N\+F90\+\_\+\+M\+A\+X\+\_\+\+A\+T\+T\+RS.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+P\+U\+T\+\_\+\+A\+TT to add a variable attribute named valid\+\_\+range for a net\+C\+DF variable named rh and a global attribute named title to an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status, rhvarid
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_write, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Enter define mode so we can add the attribute}
status = nf90\_redef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Get the variable ID for "rh"...}
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! ...  put the range attribute, setting it to eight byte reals...}
status = nf90\_put\_att(ncid, rhvarid, \textcolor{stringliteral}{"valid\_range"}, \textcolor{keywordtype}{real}((/ 0, 100 /))
\textcolor{comment}{! ... and the title attribute.}
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_put\_att(ncid, rhvarid, \textcolor{stringliteral}{"title"}, \textcolor{stringliteral}{"example netCDF dataset"}) )
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Leave define mode}
status = nf90\_enddef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-attributes_f90-get-information-about-an-attribute-nf90_inquire_attribute-and-nf90_inq_attname}{}\subsection{7.\+3 Get Information about an Attribute\+: N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+E and N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+M\+E }\label{f90-attributes_f90-get-information-about-an-attribute-nf90_inquire_attribute-and-nf90_inq_attname}
The function N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE returns information about a net\+C\+DF attribute given the variable ID and attribute name. Information about an attribute includes its type, length, name, and number. See N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+TT for getting attribute values.

The function N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME gets the name of an attribute, given its variable ID and number. This function is useful in generic applications that need to get the names of all the attributes associated with a variable, since attributes are accessed by name rather than number in all other attribute functions. The number of an attribute is more volatile than the name, since it can change when other attributes of the same variable are deleted. This is why an attribute number is not called an attribute ID.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_inquire\_attribute(ncid, varid, name, xtype, len, attnum)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)}           :: ncid, varid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)}           :: name
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent(out)}, \textcolor{keywordtype}{optional} :: xtype, len, attnum
  \textcolor{keywordtype}{integer}                                    :: nf90\_inquire\_attribute
\textcolor{keyword}{function }nf90\_inq\_attname(ncid, varid, attnum, name)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid, varid, attnum
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent(out)} :: name
  \textcolor{keywordtype}{integer}                          :: nf90\_inq\_attname
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID of the attribute’s variable, or N\+F90\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily name}

\+: Attribute name. For N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME, this is a pointer to the location for the returned attribute name.

{\ttfamily xtype}

\+: Returned attribute type, one of the set of predefined net\+C\+DF external data types. The valid net\+C\+DF external data types are N\+F90\+\_\+\+B\+Y\+TE, N\+F90\+\_\+\+C\+H\+AR, N\+F90\+\_\+\+S\+H\+O\+RT, N\+F90\+\_\+\+I\+NT, N\+F90\+\_\+\+F\+L\+O\+AT, and N\+F90\+\_\+\+D\+O\+U\+B\+LE.

{\ttfamily len}

\+: Returned number of values currently stored in the attribute. For a string-\/valued attribute, this is the number of characters in the string.

{\ttfamily attnum}

\+: For N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME, the input attribute number; for N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+ID, the returned attribute number. The attributes for each variable are numbered from 1 (the first attribute) to N\+A\+T\+TS, where N\+A\+T\+TS is the number of attributes for the variable, as returned from a call to N\+F90\+\_\+\+I\+N\+Q\+\_\+\+V\+A\+R\+N\+A\+T\+TS.

(If you already know an attribute name, knowing its number is not very useful, because accessing information about an attribute requires its name.)

\subsection*{Errors}

Each function returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\item For N\+F90\+\_\+\+I\+N\+Q\+\_\+\+A\+T\+T\+N\+A\+ME, the specified attribute number is negative or more than the number of attributes defined for the specified variable.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE to inquire about the lengths of an attribute named valid\+\_\+range for a net\+C\+DF variable named rh and a global attribute named title in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid, status
\textcolor{keywordtype}{integer} :: rhvarid                       \textcolor{comment}{! Variable ID}
\textcolor{keywordtype}{integer} :: validrangelength, titlelength \textcolor{comment}{! Attribute lengths}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Get the variable ID for "rh"...}
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! ...  get the length of the "valid\_range" attribute...}
status = nf90\_inquire\_attribute(ncid, rhvarid, \textcolor{stringliteral}{"valid\_range"}, &
                          len = validrangelength)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! ... and the global title attribute.}
status = nf90\_inquire\_attribute(ncid, nf90\_global, \textcolor{stringliteral}{"title"}, len = titlelength)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-attributes_f90-get-attributes-values-nf90_get_att}{}\subsection{7.\+4 Get Attribute’s Values\+: N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+T\+T }\label{f90-attributes_f90-get-attributes-values-nf90_get_att}
Function nf90\+\_\+get\+\_\+att gets the value(s) of a net\+C\+DF attribute, given its variable ID and name.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_get\_att(ncid, varid, name, values)
  \textcolor{keywordtype}{integer},            \textcolor{keywordtype}{intent( in)} :: ncid, varid
  \textcolor{keywordtype}{character(len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  any valid \textcolor{keywordtype}{type}, scalar or array of rank 1, &
                      \textcolor{keywordtype}{intent(out)} :: values
  \textcolor{keywordtype}{integer}                         :: nf90\_get\_att
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: Variable ID of the attribute’s variable, or N\+F90\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily name}

\+: Attribute name.

{\ttfamily values}

\+: Returned attribute values. All elements of the vector of attribute values are returned, so you must provide enough space to hold them. If you don’t know how much space to reserve, call N\+F90\+\_\+\+I\+N\+Q\+U\+I\+R\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+TE first to find out the length of the attribute. If there is only a single attribute values may be a scalar. If the attribute is of type character values should be a varble of type character with the len Fortran 90 attribute set to an appropriate value (i.\+e. character (len = 80) \+:\+: values). You cannot read character data from a numeric variable or numeric data from a text variable. For numeric data, if the type of data differs from the net\+C\+DF variable type, type conversion will occur. See \href{netcdf.html#Type-Conversion}{\tt Type Conversion} in Net\+C\+DF Users Guide.

\subsection*{Errors}


\begin{DoxyCode}
nf90\(\backslash\)\_get\(\backslash\)\_att\(\backslash\)\_ \textcolor{keyword}{type} returns the \textcolor{keywordtype}{value} nf90\(\backslash\)\_noerr \textcolor{keywordflow}{if} no errors
occurred. otherwise, the returned status indicates an error. possible
causes of errors include:

-   the variable id is invalid for the specified netcdf dataset.
-   the specified attribute does not exist.
-   the specified netcdf id does not refer to an \textcolor{keyword}{open} netcdf dataset.
-   one or more of the attribute values are out of the range of values
    representable by the desired type.
\end{DoxyCode}


\subsection*{Example}

Here is an example using N\+F90\+\_\+\+G\+E\+T\+\_\+\+A\+TT to determine the values of an attribute named valid\+\_\+range for a net\+C\+DF variable named rh and a global attribute named title in an existing net\+C\+DF dataset named foo.\+nc. In this example, it is assumed that we don’t know how many values will be returned, so we first inquire about the length of the attributes to make sure we have enough space to store them\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer}              :: ncid, status
\textcolor{keywordtype}{integer}              :: rhvarid                       \textcolor{comment}{! Variable ID}
\textcolor{keywordtype}{integer}              :: validrangelength, titlelength \textcolor{comment}{! Attribute lengths}
\textcolor{keywordtype}{real}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{allocatable}, &
                     :: validrange
\textcolor{keywordtype}{character (len = 80)} :: title
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Find the lengths of the attributes}
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_attribute(ncid, rhvarid, \textcolor{stringliteral}{"valid\_range"}, &
                          len = validrangelength)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inquire\_attribute(ncid, nf90\_global, \textcolor{stringliteral}{"title"}, len = titlelength)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{!Allocate space to hold attribute values, check string lengths}
\textcolor{keyword}{allocate}(validrange(validrangelength), stat = status)
\textcolor{keywordflow}{if}(status /= 0 .or. len(title) < titlelength)
  print *, \textcolor{stringliteral}{"Not enough space to put attribute values."}
  \textcolor{keywordflow}{exit}
\textcolor{keywordflow}{end if}
\textcolor{comment}{! Read the attributes.}
status = nf90\_get\_att(ncid, rhvarid, \textcolor{stringliteral}{"valid\_range"}, validrange)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_get\_att(ncid, nf90\_global, \textcolor{stringliteral}{"title"}, title)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-attributes_f90-copy-attribute-from-one-netcdf-to-another-nf90_copy_att}{}\subsection{7.\+5 Copy Attribute from One Net\+C\+D\+F to Another\+: N\+F90\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+T\+T }\label{f90-attributes_f90-copy-attribute-from-one-netcdf-to-another-nf90_copy_att}
The function N\+F90\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT copies an attribute from one open net\+C\+DF dataset to another. It can also be used to copy an attribute from one variable to another within the same net\+C\+DF dataset.

If used to copy an attribute of user-\/defined type, then that user-\/defined type must already be defined in the target file. In the case of user-\/defined attributes, enddef/redef is called for ncid\+\_\+in and ncid\+\_\+out if they are in define mode. (This is the ensure that all user-\/defined types are committed to the file(s) before the copy is attempted.)

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_copy\_att(ncid\_in, varid\_in, name, ncid\_out, varid\_out)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid\_in,  varid\_in
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid\_out, varid\_out
  \textcolor{keywordtype}{integer}                          :: nf90\_copy\_att
\end{DoxyCode}


{\ttfamily ncid\+\_\+in}

\+: The net\+C\+DF ID of an input net\+C\+DF dataset from which the attribute will be copied, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid\+\_\+in}

\+: ID of the variable in the input net\+C\+DF dataset from which the attribute will be copied, or N\+F90\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily name}

\+: Name of the attribute in the input net\+C\+DF dataset to be copied.

{\ttfamily ncid\+\_\+out}

\+: The net\+C\+DF ID of the output net\+C\+DF dataset to which the attribute will be copied, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE. It is permissible for the input and output net\+C\+DF I\+Ds to be the same. The output net\+C\+DF dataset should be in define mode if the attribute to be copied does not already exist for the target variable, or if it would cause an existing target attribute to grow.

{\ttfamily varid\+\_\+out}

\+: ID of the variable in the output net\+C\+DF dataset to which the attribute will be copied, or N\+F90\+\_\+\+G\+L\+O\+B\+AL to copy to a global attribute.

\subsection*{Errors}

N\+F90\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The input or output variable ID is invalid for the specified net\+C\+DF dataset.
\item The specified attribute does not exist.
\item The output net\+C\+DF is not in define mode and the attribute is new for the output dataset is larger than the existing attribute.
\item The input or output net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+C\+O\+P\+Y\+\_\+\+A\+TT to copy the variable attribute units from the variable rh in an existing net\+C\+DF dataset named foo.\+nc to the variable avgrh in another existing net\+C\+DF dataset named bar.\+nc, assuming that the variable avgrh already exists, but does not yet have a units attribute\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid1, ncid2, status
\textcolor{keywordtype}{integer} :: rhvarid, avgrhvarid    \textcolor{comment}{! Variable ID}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid1)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_open(\textcolor{stringliteral}{"bar.nc"}, nf90\_write, ncid2)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Find the IDs of the variables}
status = nf90\_inq\_varid(ncid1, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_inq\_varid(ncid1, \textcolor{stringliteral}{"avgrh"}, avgrhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_redef(ncid2)   \textcolor{comment}{! Enter define mode}
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\textcolor{comment}{! Copy variable attribute from "rh" in file 1 to "avgrh" in file 1}
status = nf90\_copy\_att(ncid1, rhvarid, \textcolor{stringliteral}{"units"}, ncid2, avgrhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_enddef(ncid2)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-attributes_f90-rename-an-attribute-nf90_rename_att}{}\subsection{7.\+6 Rename an Attribute\+: N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+T\+T }\label{f90-attributes_f90-rename-an-attribute-nf90_rename_att}
The function N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT changes the name of an attribute. If the new name is longer than the original name, the net\+C\+DF dataset must be in define mode. You cannot rename an attribute to have the same name as another attribute of the same variable.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_rename\_att(ncid, varid, curname, newname)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid,  varid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: curname, newname
  \textcolor{keywordtype}{integer}                          :: nf90\_rename\_att
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE

{\ttfamily varid}

\+: ID of the attribute’s variable, or N\+F90\+\_\+\+G\+L\+O\+B\+AL for a global attribute

{\ttfamily curname}

\+: The current attribute name.

{\ttfamily newname}

\+: The new name to be assigned to the specified attribute. If the new name is longer than the current name, the net\+C\+DF dataset must be in define mode.

\subsection*{Errors}

N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified variable ID is not valid.
\item The new attribute name is already in use for another attribute of the specified variable.
\item The specified net\+C\+DF dataset is in data mode and the new name is longer than the old name.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+R\+E\+N\+A\+M\+E\+\_\+\+A\+TT to rename the variable attribute units to Units for a variable rh in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid1, status
\textcolor{keywordtype}{integer} :: rhvarid         \textcolor{comment}{! Variable ID}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Find the IDs of the variables}
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_rename\_att(ncid, rhvarid, \textcolor{stringliteral}{"units"}, \textcolor{stringliteral}{"Units"})
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
\hypertarget{f90-attributes_f90-nf90_del_att}{}\subsection{7.\+7 N\+F90\+\_\+\+D\+E\+L\+\_\+\+A\+T\+T }\label{f90-attributes_f90-nf90_del_att}
The function N\+F90\+\_\+\+D\+E\+L\+\_\+\+A\+TT deletes a net\+C\+DF attribute from an open net\+C\+DF dataset. The net\+C\+DF dataset must be in define mode.

\subsection*{Usage}


\begin{DoxyCode}
\textcolor{keyword}{function }nf90\_del\_att(ncid, varid, name)
  \textcolor{keywordtype}{integer},             \textcolor{keywordtype}{intent( in)} :: ncid, varid
  \textcolor{keywordtype}{character (len = *)}, \textcolor{keywordtype}{intent( in)} :: name
  \textcolor{keywordtype}{integer}                          :: nf90\_del\_att
\end{DoxyCode}


{\ttfamily ncid}

\+: Net\+C\+DF ID, from a previous call to N\+F90\+\_\+\+O\+P\+EN or N\+F90\+\_\+\+C\+R\+E\+A\+TE.

{\ttfamily varid}

\+: ID of the attribute’s variable, or N\+F90\+\_\+\+G\+L\+O\+B\+AL for a global attribute.

{\ttfamily name}

\+: The name of the attribute to be deleted.

\subsection*{Errors}

N\+F90\+\_\+\+D\+E\+L\+\_\+\+A\+TT returns the value N\+F90\+\_\+\+N\+O\+E\+RR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include\+:


\begin{DoxyItemize}
\item The specified variable ID is not valid.
\item The specified net\+C\+DF dataset is in data mode.
\item The specified attribute does not exist.
\item The specified net\+C\+DF ID does not refer to an open net\+C\+DF dataset.
\end{DoxyItemize}

\subsection*{Example}

Here is an example using N\+F90\+\_\+\+D\+E\+L\+\_\+\+A\+TT to delete the variable attribute Units for a variable rh in an existing net\+C\+DF dataset named foo.\+nc\+:


\begin{DoxyCode}
\textcolor{keywordtype}{use }netcdf
\textcolor{keywordtype}{implicit none}
\textcolor{keywordtype}{integer} :: ncid1, status
\textcolor{keywordtype}{integer} :: rhvarid         \textcolor{comment}{! Variable ID}
...
status = nf90\_open(\textcolor{stringliteral}{"foo.nc"}, nf90\_nowrite, ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
\textcolor{comment}{! Find the IDs of the variables}
status = nf90\_inq\_varid(ncid, \textcolor{stringliteral}{"rh"}, rhvarid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
...
status = nf90\_redef(ncid)   \textcolor{comment}{! Enter define mode}
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_del\_att(ncid, rhvarid, \textcolor{stringliteral}{"Units"})
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
status = nf90\_enddef(ncid)
\textcolor{keywordflow}{if} (status /= nf90\_noerr) \textcolor{keyword}{call }handle\_err(status)
\end{DoxyCode}
 